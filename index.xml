<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>db@uoit</title>
    <link>http://db.science.uoit.ca/index.xml</link>
    <description>Recent content on db@uoit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 01 Sep 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://db.science.uoit.ca/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Hello sandbox</title>
      <link>http://db.science.uoit.ca/slides/sandbox/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/slides/sandbox/</guid>
      <description>

&lt;h1 id=&#34;sandbox&#34;&gt;Sandbox&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is clojure.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn hello [world] (println world))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_1&#34;&gt;___________&lt;/h1&gt;

&lt;p&gt;Another slide&lt;/p&gt;

&lt;p&gt;&lt;a class=&#34;my-first-slide&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;button id=&#34;click&#34;&gt;Click me&lt;/button&gt;&lt;/p&gt;

&lt;style&gt;
button {
  font-family: &#34;Roboto&#34;;
  background: #aaa;
  outline: none;
  border: none;
  border-radius: 3px;
}
&lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Building a desk</title>
      <link>http://db.science.uoit.ca/writings/build-desk/</link>
      <pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/writings/build-desk/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-0.jpg&#34; alt=&#34;The block in its initial condition&#34; /&gt;
Someone gave me a really gorgeous piece of wood.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s exactly what I was hoping to get my hands on.  Given that I have
absolutely minimal experience working with woods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I got a steel brush for a few bucks.
The wood is completely dry, and it was surprisingly easy to remove the dusty
layer off the surface with some hard brushing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-1-brush.jpg&#34; alt=&#34;Steel brush&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-2-corner.jpg&#34; alt=&#34;Rough corner&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The block of wood is full of unique characteristics.  After all, it&amp;rsquo;s these
things that make it so much fun.
This particular piece has a rough corner.  I didn&amp;rsquo;t want to do much about it
except sawing it lightly, and sanding down possible splitters.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I got some wood oil and stains from Canadian Tires.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-3-stain.jpg&#34; alt=&#34;Starting to stain the wood&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-4-stained.jpg&#34; alt=&#34;The next day...&#34; /&gt;
After a few coats of wood stain and gloss finish, it looks absolutely great.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;The legs are from IKEA.  Putting the legs are easy enough.  The wood is quite
soft, and it&amp;rsquo;s really quite easy to drill the guiding holes for the screws.&lt;/p&gt;

&lt;p&gt;The only really hard part is that the wood is not perfectly flat, so I had to
put some inserts and adjusted them repeated to make sure that the legs are
perfectly leveled.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-5-legs.jpg&#34; alt=&#34;Putting on the legs&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-6-finished.jpg&#34; alt=&#34;All done.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Finally&lt;/em&gt;, it&amp;rsquo;s all done.  Actually, it was so much easier than I thought It
would have been.  I am so thankful that the wood was already nicely polished
to start with.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I am happy to report that this blog is written on the desk.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-7-workstation.jpg&#34; alt=&#34;Workstation...&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&#34;sign&#34;&gt;Ken Pu &lt;br&gt; July 15, Oshawa&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/insert-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/insert-sort/</guid>
      <description>

&lt;h1 id=&#34;basic-programming&#34;&gt;Basic programming&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We use &lt;em&gt;Python&lt;/em&gt; for this course.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Basic Python will do for the most part of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you are not used to Python (anymore), you are only &lt;em&gt;one&lt;/em&gt; day away
of catching up.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codecademy.com/learn/python&#34;&gt;https://www.codecademy.com/learn/python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;programming-this-course&#34;&gt;Programming &amp;amp; This Course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t need much programming for this course because we absolutely will be
focused on the &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But &amp;hellip;&lt;/p&gt;

&lt;p&gt;The reality is that &lt;em&gt;programming&lt;/em&gt; is absolutely essential.&lt;/p&gt;

&lt;h1 id=&#34;basic-programming-for-this-course&#34;&gt;Basic programming for this course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [1, 2, 3]

print &amp;quot;The middle number is %d&amp;quot; % x[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need arrays as a fundamental data structure.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student:
    name = &amp;quot;Unknown&amp;quot;
    age = 18

    def __init__(self, name):
        self.name = name

jack = Student(&amp;quot;Jack&amp;quot;)

print &amp;quot;%s: %s&amp;quot; % (jack.name, jack.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need objects.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;i = 0
while i &amp;lt; 10:
  print i
  i += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(10):
  print i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Various loops are needed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ==================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def reverse_string(s):
    reversed_s = &amp;quot;&amp;quot;
    for c in s:
      reversed_s += c
    return reversed_s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need functions, mostly to better organize the implementation of an algorithm.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ============&lt;/p&gt;

&lt;p&gt;We may need to rely on external Python libraries for data generation and visualization of algorithmic actions.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;random-graph.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import networkx as nx
import matplotlib.pyplot as plot

G = nx.erdos_renyi_graph(100, 0.015)
nx.draw(G)
plot.save(&amp;quot;random-graph.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-sorting-problem&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 9:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Input:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An array of elements: $x$
where the elements are to be compared by a &lt;em&gt;comparator&lt;/em&gt; function:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$f(x_1, x_2) \in \left[
\begin{array}{cc}
-1 &amp;amp; x_1 &amp;lt; x_2 \\
0 &amp;amp; x_1 = x_2 \\
1 &amp;amp; x_1 &amp;gt; x_2
\end{array}\right.$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Output:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A permutation $y$ of the array of $x$, such that&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\forall i,j\in[0, \mathrm{length}(y)],\quad i\leq j \implies y[i] \leq y[j]$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This is called &lt;em&gt;comparison based sorting&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The comparison function can be arbitrary, and it defines the ordering.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-sorting-problem-1&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Permutation $\pi : [0, n] \to [0, n]$ such that &lt;code&gt;$i\not= j\implies \pi(i)\not=\pi(j)$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a sorting problem $(x, f)$, there can be multiple non-unique permutations that sorts $x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [3, 2, 2, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;insertion-sort&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a highly &lt;em&gt;inefficient&lt;/em&gt; sorting algorithm.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s simple enough that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It&amp;rsquo;s intuitive.&lt;/li&gt;
&lt;li&gt;It can be fully analyzed relatively easily.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;insertion-sort-the-intuition&#34;&gt;Insertion sort: the intuition&lt;/h1&gt;

&lt;p&gt;Suppose you have an array such that the &lt;em&gt;initial&lt;/em&gt; subarray is already sorted.  But the last element may be out of place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x&#34;&gt;+---+---+---+----+---+
| 2 | 4 | 5 | 10 | x |
+---+---+---+----+---+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is a procedure to rearrange such array?  Imagine that &lt;code&gt;x=7&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;insertion-sort-1&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=cards.png width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Chapter 2, Figure 2.1 of textbook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python nu&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;try-it-out&#34;&gt;Try it out&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;import random
A = [random.randint(0, 100) for i in range(10)]
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;insertion_sort(A)
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/python&#39;
    
    style=&#39;max-width:100%;width:100%;height:500px&#39;&gt;&lt;/iframe&gt;



&lt;h1 id=&#34;analysis-of-correctness&#34;&gt;Analysis of correctness&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Intuition is not to be trusted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can formally prove that an algorithm is correct.
But first, we need some machinery.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;loop-invariance&#34;&gt;Loop invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consider a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;total = 0
count = 0

for v in array:
  total += v
  count += 1

avg = total / count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Precondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; *true at the start of
the loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Postcondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true at by the end of
the loop.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Loop invariance&lt;/strong&gt;:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true
&lt;span style=color:#44f;font-size:120%&gt;right at the end&lt;/span&gt;
of each iteration of
the loop.&lt;/p&gt;

&lt;p&gt;At the &lt;em&gt;end&lt;/em&gt; of the $i$-th iteration:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;$_i$ $\not=$ &lt;code&gt;0&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_{i+1} \geq$&lt;/code&gt; &lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_i$&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-down&#34;&gt;&lt;/i&gt;:
This is not a loop-invariance because it may not be true.
Consider if $v &amp;lt; 0$ for some iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are two loops, with &lt;code&gt;while&lt;/code&gt;-loop nested in the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-1&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Inner-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If we assume that $A[0 .. j-1]$ is sorted, then
the following loop invariance holds for the &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;

&lt;p&gt;At the end of the iteration, we have $A[i\dots j]$ is sorted.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;Can we say anything about &lt;code&gt;A[j+1]&lt;/code&gt; to &lt;code&gt;A[len(A)-1]&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-2&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outer-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The subarray &lt;code&gt;A[0 .. j]&lt;/code&gt; is sorted after the $j$-th iteration of the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;: We prove by induction on $j$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Base case&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$j=0$, trivially true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Induction&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;A[0 .. j-1]&lt;/code&gt; is sorted, by the inner-loop invariance, moving key to
&lt;code&gt;A[i+1]&lt;/code&gt; makes &lt;code&gt;A[0 .. j]&lt;/code&gt; sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-3&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Theorem&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;insertion_sort&lt;/code&gt; algorithm always correctly sorts the input array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By the outer-loop invariance, by the end of the last iteration,
with $j=$&lt;code&gt;len(A)-1&lt;/code&gt;, the entire array &lt;code&gt;A[0 .. len(A)-1]&lt;/code&gt; is sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h3 id=&#34;every-statement-takes-the-same-amount-of-time&#34;&gt;Every statement takes the same amount of time.&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not exactly correct, but it is accurate enough to gauge the
performance of algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;corollary&#34;&gt;&lt;em&gt;Corollary&lt;/em&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;We measure the number of lines executed by the program before an array is
completely sorted by &lt;code&gt;insertion_sort&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;$T_\mathrm{LOC}(\mathrm{length}(A)) \Rightarrow T(n)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Best case analysis&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Average case analysis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let $n = \mathrm{length}(A)$&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The outer-loop &lt;em&gt;always&lt;/em&gt; iterates $n$ times.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The inner loop iterates &lt;em&gt;in the worst case&lt;/em&gt; $j$ times.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;$$ T(n) \leq \sum_{j=0}^n j = \frac{n(n-1)}{2}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;insert_sort&lt;/code&gt; is a pretty inefficient algorithm.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;45 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4950&lt;/td&gt;
&lt;td&gt;5 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;499500&lt;/td&gt;
&lt;td&gt;0.5 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;499999500000&lt;/td&gt;
&lt;td&gt;5.9 days&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A more efficient algorithm (to be discussed later):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;23 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;460&lt;/td&gt;
&lt;td&gt;0.46 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;6907&lt;/td&gt;
&lt;td&gt;6.9 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;13815510&lt;/td&gt;
&lt;td&gt;13.8 $s$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;INSERTION sort&lt;/li&gt;
&lt;li&gt;Analysis of correctness by loop-invariance&lt;/li&gt;
&lt;li&gt;Performance analysis by counting lines executed&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Text: 2.1, 2.2,&lt;/p&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is INSERTION sort a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/merge-sort/</guid>
      <description>

&lt;h1 id=&#34;mergesort&#34;&gt;Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Divide and conquer, when and when not&amp;hellip;&lt;/li&gt;
&lt;li&gt;Bottom-up&lt;/li&gt;
&lt;li&gt;Top-down&lt;/li&gt;
&lt;li&gt;Correctness&lt;/li&gt;
&lt;li&gt;Complexity analysis&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;divide-and-conquer&#34;&gt;Divide and conquer&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a way to instruct &amp;ldquo;simple&amp;rdquo; solver to solve a complex problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;Minion.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;office-messy-desk.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;divide-and-conquer-and-combine&#34;&gt;Divide and conquer (and combine)&lt;/h1&gt;

&lt;p&gt;Divide:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a problem $P$, the division of a problem is a procedure
that produces a collection of &lt;em&gt;smaller&lt;/em&gt; problems &lt;code&gt;$\mathbf{Q} = \{Q_1, Q_2, \dots\}$&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each sub-problem &lt;code&gt;$Q_i\in\mathbf{Q}$&lt;/code&gt; (hopefully) is easier to solve.
Let &lt;code&gt;$S_i = \mathrm{solve}(Q_i)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hopefully, the solutions of subproblems, ${S_i}$, are not useless toward the
solution of $P$.&lt;/p&gt;

&lt;p&gt;We need a procedure to combine:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\mathrm{solve}(P) = \mathrm{combine}(S_1, S_2, S_3, \dots)$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;example-cleaning-a-mess&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;Minion.jpg&#34; style=&#34;float:left;width:80px;margin:0 20px 0px 0&#34;&gt;&lt;/img&gt;
Consider how you can instruct a minion to clean a messy office.  The minion
is overwhelmed by the mess of the entire office.  Divide and conquer is a great
way to solve the cleaning problem.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are some assumptions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The minion can clean up a very small section of an office - like a drawer, or
a book shelf.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If every section of an office is organized, we deem the whole office
organized.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;example-cleaning-a-mess-1&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide(Office) = &lt;code&gt;{Bookshelf, Desk, Floor, Cabinet, Drawer, $\dots$}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conquer: the minion can clean up each section&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine: Nothing needs to be done&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Divide &amp;amp; Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A list of numbers can be divided into smaller lists.
If a list is so small, we can sort it trivially.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How small does a list need to be for us to know how to sort it?&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-1&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we have two lists that are already sorted, can we figure out how to combine
them in a sorted way?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;+---+---+---+---+
| 1 | 5 | 6 | 8 |          \
+---+---+---+---+          |
                           |
                           +------&amp;gt;  combined sorted list
                           |
+---+---+---+---+----+     |
| 3 | 4 | 5 | 8 | 10 |     /
+---+---+---+---+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-2&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 10:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def merge(list1, list2):
    i, j = 0, 0
    list3 = []

    while i &amp;lt; len(list1) and j &amp;lt; len(list2):
        if list1[i] &amp;lt;= list2[j]:
            list3.append(list1[i])
            i += 1
        else:
            list3.append(list2[j])
            j += 1

    if i &amp;lt; len(list1): list3.extend(list1[i:])

    if j &amp;lt; len(list2): list3.extend(list2[j:])

    return list3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We want to be able to merge to sorted list into a larger list.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=merge.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;bottom-up-mergesort-1&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;We start with a list of arbitrary lenght $n$.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Observe that &lt;em&gt;all&lt;/em&gt; sublist of length 1 is already sorted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 4, 8, 16, &amp;hellip;
until the whole list is sorted.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bottom-up-mergesort-2&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bottom-up-mergesort-3&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=mergesort.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort-4&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A hierarchy of subproblems&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Small subproblems: sublist of length 1&lt;/p&gt;

&lt;p&gt;Larger subproblems: sublist of length 2, 4, &amp;hellip;&lt;/p&gt;

&lt;p&gt;The largest subproblem: the whole list&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Why is it called &lt;em&gt;bottom-up&lt;/em&gt;?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The procedure, &lt;code&gt;mergesort()&lt;/code&gt;, recognizes the smallest subproblems &lt;em&gt;first&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;divide&lt;/strong&gt; stage starts at the bottom of the hierarchy.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;conquer&lt;/strong&gt; stage &lt;em&gt;always&lt;/em&gt; starts with the bottom of the hierarchy.&lt;/p&gt;

&lt;h1 id=&#34;analysis-correctness&#34;&gt;Analysis: correctness&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop-invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At the end of each loop,&lt;/p&gt;

&lt;p&gt;for all $L[i\Delta \dots (i+1)\Delta]$ is sorted for all $i$,
where $\Delta$ is the sortedness at the end of the iteration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Overall correctness&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The loop terminates when $\Delta$ exceeds the length of the list, so the
entire list is sorted by the loop invariance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Guaranteed termination&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration strictly increases the sortedness $\Delta$ (by doubling it).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;analysis-performance&#34;&gt;Analysis: performance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How many iterations if there are $n$ elements in the list?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration grows the &lt;em&gt;sortedness&lt;/em&gt; by a factor of 2 up to $n$.
So, we need $\log_2(n)$ iterations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How many instructions does each iteration take?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration has four steps.  Each step requires no more than a linear scan
of the list.
We can guarantee that number of instructions do not exceed: $k\cdot n$ for some
constant $k$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Putting it together:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mergesort()&lt;/code&gt; requires no more than $k\cdot n\log(n)$ number of instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;top-down-mergesort-1&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Revisit the hierarchy of subproblems of sorting a list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can specify the &lt;em&gt;Divide-and-conquer&lt;/em&gt; top-down:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Divide sorting of $L$ to the first sublist $L[0 \dots \frac{n}{2}]$
and the second sublist $L[\frac{n}{2} \dots n]$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the sub-lists are not easy enough, then break down again.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Recursion&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;correctness&#34;&gt;Correctness:&lt;/h2&gt;

&lt;p&gt;Induction on depth of recursion.&lt;/p&gt;

&lt;p&gt;Base case: depth = 0&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If there is no recursion, than the list $L$ is such that $|L|\leq 1$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Inductive case: depth = $k$, and assume that all mergesort at level $&amp;lt; k$ are
correct.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Let $L_1$ and $L_2$ be the two sublists.  The invocations &lt;code&gt;mergesort($L_i$)&lt;/code&gt;
use $&amp;lt; k$ recursions, and thus, are &lt;em&gt;correct&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since $L_1$ and $L_2$ are properly sorted, and that &lt;code&gt;merge()&lt;/code&gt; is correct,
we conclude that &lt;code&gt;mergesort(L)&lt;/code&gt; is correct.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis-1&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Let $n = |L|$.  How much time does it take to complete top-down
&lt;code&gt;mergesort($L$)&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Let $T(n)$ = time of &lt;code&gt;mergesort($L$)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray*}
T(n) &amp;amp;\simeq&amp;amp; T(n/2) + T(n/2) + n \\
  &amp;amp;=&amp;amp; 2 T(n/2) + n
\end{eqnarray*}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will develop an array of techniques to solve &lt;em&gt;recurrence equations&lt;/em&gt; to
analyze recursive algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Spoiler Alert:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$ T(n) = n\log(n) + n $$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bottom-up mergesort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Top-down mergesort&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;MERGESORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/optimal-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/optimal-sorting/</guid>
      <description>

&lt;h1 id=&#34;optimal-comparison-based-sorting-br-v-s-br-numerical-sorting&#34;&gt;Optimal Comparison Based Sorting &lt;br&gt; v.s. &lt;br&gt;  Numerical Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Assumption&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elements in the array are &lt;em&gt;black boxes&lt;/em&gt;, and only comparison can be made between two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;The decision-tree model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a sorting algorithm $A$, we record &lt;em&gt;all&lt;/em&gt; possible comparison operations executed in $A$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; A comparison operation: $(i,j)$ where $i, j$ are the &lt;em&gt;original&lt;/em&gt; index of the elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The leaf records the final ordering of the original index.&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-1&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How many comparison operations did $A$ take as illustrated in the diagram?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the worst case number of comparision operations?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-2&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What type of tree is the deicion tree?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Binary tree&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How many leaf nodes are there for $n$ elements?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All possible permutations of $[1, 2, 3, \dots n] = n!$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the height of the tree if there are $n!$ leaf nodes?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\log_2(n!) \approx c\cdot n\log(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Any comparision based sorting algorithm will necessarily take at least $c n\log(n)$ number of comparison operations in the &lt;em&gt;worst&lt;/em&gt; case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Optimal sorting&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a comparison based sorting algorithm always makes at most $c n\log(n)$ number of comparisons, then it&amp;rsquo;s called &lt;em&gt;optimal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting-1&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Algorithm&lt;/th&gt;
&lt;th&gt;Optimal?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Insertion sort&lt;/td&gt;
&lt;td&gt;No, $n^2$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Mergesort&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Quicksort&lt;/td&gt;
&lt;td&gt;No, $n^2$ in the worst case&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sorting-integers&#34;&gt;Sorting Integers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If an array contains (bounded) integers, we can beat optimal comparison based sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Elements are not blackboxes.  We can look at individual digits of an bounded integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;Assumptions:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The elements are integers.&lt;/li&gt;
&lt;li&gt;The elements are all in the range of $[0, k-1]$ for some $k \geq 0$.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Amazing fact:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;With $n$ elements, we can do it with only $2\cdot(n+k)$ number of instructions,
compare to $n\log(n)$ in the case of optimal comparison sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort-1&#34;&gt;Counting sort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def empty_array(size, init=None):
    return [init for i in range(size)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; allocate an empty array with an optional initial value.&lt;/p&gt;

&lt;h1 id=&#34;counting-sort-2&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def COUNTING_SORT(A):
    n = len(A)
    k = max(A) + 1
    B = empty_array(size=n)
    C = empty_array(size=k, init=0)

    for a in A:
        C[a] = C[a] + 1

    for i in range(1,k):
        C[i] = C[i] + C[i-1]

    for a in reversed(A):
        B[C[a]-1] = a
        C[a] = C[a] - 1

    return B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;We compute the frequency of each distinct value in &lt;code&gt;A&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The frequence is then turned into cummulative frequency.  Namely:
&lt;code&gt;$C[x] = |\{y\in A: y\leq x\}|$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;With $C$, we can quickly deduce which each element should be positioned.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;counting-sort-3&#34;&gt;Counting Sort&lt;/h1&gt;

&lt;p&gt;Question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is &lt;code&gt;COUNTING_SORT&lt;/code&gt; stable?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Answer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s crucial to place $x$ into &lt;code&gt;B&lt;/code&gt; from &lt;code&gt;reverse(A)&lt;/code&gt; instead of &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The best comparison sorting algorithms are in the order of $n\log(n)$.&lt;/li&gt;
&lt;li&gt;The best integer comparison algorithms can achieve the efficiency in the order of $n$.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COUNTING_SORT&lt;/code&gt; requires too much memory in practice to be applied to arrays with large integer values.  However, it will be instrumental later (as part of radix sort).&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;The measure of algorithmic efficiency will be made much more rigorous in the next section of this course.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/quicksort/</guid>
      <description>

&lt;h1 id=&#34;quicksort&#34;&gt;Quicksort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;quicksort-1&#34;&gt;Quicksort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a list $L$, we divide the sorting problem into two sub-problems.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Sort the elements in $L$ smaller than $x$: $L_1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sort the elements in $L$ larger than $x$: $L_2$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\mathrm{sorted}(L) = \mathrm{sorted}(L_1) \oplus \{x\} \oplus \mathrm{sorted}(L_2)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;partition&#34;&gt;Partition&lt;/h1&gt;

&lt;p&gt;Given a list &lt;code&gt;$L$&lt;/code&gt; and an element $x$ in $L$, &lt;em&gt;partitioning&lt;/em&gt; $L[p \dots r]$ by the &lt;em&gt;pivot&lt;/em&gt;
element $x$ does the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rearrange the elements in $L[p\dots r]$ so that there exists a position $q$
such that &lt;em&gt;after&lt;/em&gt; rearrangment:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$L[q] = x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [p, q-1],\ L[i] \leq x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [q+1, r],\ L[i] \geq x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-1-simple-but-takes-more-memory&#34;&gt;Version 0.1: simple, but takes more memory&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement &lt;code&gt;partition(L, p, r)&lt;/code&gt; with the minimal effort:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pick $x = L[r]$&lt;/li&gt;
&lt;li&gt;Filter the list for smaller elements: &lt;code&gt;$L_1 = \{y\in L[p\dots r-1]: y\leq x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Filter the list for larger elements: &lt;code&gt;$L_2 = \{y\in L[p\dots r-1]: y &amp;gt; x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reconstruct: &lt;code&gt;$L[p \dots r] = L_1 \oplus \{x\} \oplus L_2$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def partition(L, p, r):
    x = L[r]
    L1 = [y for y in L[p:r] if y &amp;lt;= x]
    L2 = [y for y in L[p:r] if y &amp;gt; x]
    L[p:r+1] = L1 + [x] + L2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-2-more-involved-but-takes-no-additional-memory&#34;&gt;Version 0.2: more involved, but takes no additional memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It only involves element swapping, so it requires &lt;em&gt;zero&lt;/em&gt; additional memory.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;But its correctness is much less obvious.&lt;/p&gt;

&lt;h1 id=&#34;analysis-of-partition&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bookkeeping is the key:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;$p$ and $r$ are the boundaries of the sublist to be partitioned.&lt;/li&gt;
&lt;li&gt;$r$ also holds the value of the pivot element.&lt;/li&gt;
&lt;li&gt;Elements in $[p\dots j]$ are processed.&lt;/li&gt;
&lt;li&gt;$i$ is a marker of the boundary between smaller and larger elements.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;analysis-of-partition-1&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;After each iteration, $L[p, j]$ is properly partitioned:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$L[p, i] \leq x$&lt;/li&gt;
&lt;li&gt;$L[i+1, j] &amp;gt; x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;quicksort-2&#34;&gt;Quicksort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def quicksort(L, p, r):
    if p &amp;lt; r:
        k = partition(L, p, r)
        quicksort(L, p, k-1)
        quicksort(L, k+1, r)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will only give a terse outline of the analysis.  The full version is deferred to later lectures.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-1&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;Let there be $n$ elements in the array.&lt;/p&gt;

&lt;p&gt;Key obsevation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;partition(L, p, r)&lt;/code&gt; takes $(r - p)$ iterations.  Each iteration has a fixed number of instructions.  So, $T_\mathrm{partition} = c_1 (r-p) \leq c\cdot n$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At each &lt;em&gt;invocation&lt;/em&gt; of &lt;code&gt;quicksort(L, p, k-1)&lt;/code&gt; and &lt;code&gt;quicksort(L, k+1, r)&lt;/code&gt;, we need to determine the number of elements: $k-1-p$, and $r-k-1$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;performance-analysis-worst-case&#34;&gt;Performance Analysis: Worst-case&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The worst case for $T_\mathrm{partition} = n$&lt;/li&gt;
&lt;li&gt;The worst case for $k-1-p = n-1$&lt;/li&gt;
&lt;li&gt;The worst case for $r-k-1 = n-1$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We have enough to set-up an equation to estimate the number of instructions of &lt;code&gt;quicksort(L, a, b)&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Let $|L[a\dots b]| = n$.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n-1)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This leads to a (poor) performance characteristics of: $\approx n^2$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will show how to solve such equations (known as recurrence equations) in the next section of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-average-case&#34;&gt;Performance Analysis: average case&lt;/h1&gt;

&lt;p&gt;Quicksort as the name suggests is actually quite quick (most of the time&amp;hellip;)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting &lt;code&gt;k = partition(L, p, q)&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The pivot value should be somewhere in the middle of the subarray.
Namely: $k\approx p+q/2$, and so $k-1-p \approx n/2$, and $q-k-1\approx n/2$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting the recurrence equation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n/2)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;This leads to a satisfying performance characteristics of: $\approx n\log(n)$&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Partition: a simple version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partition: a zero-memory version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quicksort: a recursive sorting algorithm&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;QUICKSORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/functional-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/functional-computation/</guid>
      <description>

&lt;h1 id=&#34;lambda-calculus-symbolic-computation&#34;&gt;$\lambda$-Calculus: symbolic computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lambda-calculus&#34;&gt;$\lambda$-Calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Proposed by Alonzo Church in ~1930.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;intented to formalize mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Syntactic expressions that represent &lt;em&gt;functions&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;designed to represent the entire foundation of mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rules of rewriting the syntactic expression&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;rewrite rules represent mathematical reasoning.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;expressions&#34;&gt;Expressions&lt;/h1&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Literals: 1, 2, 3, &amp;ldquo;Hello world&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Variables: $x, y, z, \dots$&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Functions&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$+ : (x,y)\mapsto x+y$&lt;/li&gt;
&lt;li&gt;$\mathrm{inc} : x\mapsto x+1$&lt;/li&gt;
&lt;li&gt;$\dots$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Always returns &lt;em&gt;one&lt;/em&gt; value.&lt;/li&gt;
&lt;li&gt;Takes a fixed number of inputs: arity of the function
&lt;span style=color:red&gt;*&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;value-as-function&#34;&gt;Value as function&lt;/h1&gt;

&lt;p&gt;A value is a zero-arity function.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;function-as-value&#34;&gt;Function as value&lt;/h1&gt;

&lt;p&gt;We want to extend the idea of &lt;em&gt;things&lt;/em&gt; to include functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;This is a central idea in functional programming&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;value-equiv-function-everything&#34;&gt;Value $\equiv$ Function = Everything&lt;/h2&gt;

&lt;h1 id=&#34;syntax-for-expressions-value-function&#34;&gt;Syntax for expressions (value / function)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$x, y, z, \dots$ are expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Abstraction:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $x$ is a variable, and $e$ is an expression, then
$\lambda x. e$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $e_1$ is a function with arity 1,
&lt;code&gt;$e_2$&lt;/code&gt; is an expression, then
$e_1 e_2$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We assume that all functions are with arity 1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not a restriction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;the-weird-syntax-of-lambda-calculus&#34;&gt;The &lt;em&gt;weird&lt;/em&gt; syntax of $\lambda$ calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\lambda x.e$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a function taking &lt;em&gt;one&lt;/em&gt; input, represented by the variable $x$.
It returns &lt;em&gt;one&lt;/em&gt; value, which is evaluated as the expression $e$.
The expression $e$ usually makes uses of $x$, but not necessarily.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is passing $e_2$ as an argument to the expression $e_1$.  Recall that
everything is a function.  So $e_1$ is a function with &lt;em&gt;one&lt;/em&gt; argument.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2 e_3 = ((e_1 e_2) e_3)$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This shows that $e_1$ takes one argument ($e_2$), and returns an
expression which is yet again a function which takes $e_3$ as an input.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;defining-things&#34;&gt;Defining things&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identity function&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\lambda x.x$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions with multiple arity&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose we have a function $f(x,y,z) = e$ where the expression
involves all three input variables $x, y, z$.&lt;/p&gt;

&lt;p&gt;We can use the following expression to build $f$:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$\lambda x.(\lambda y.(\lambda z. e))$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;This is a big deal.&lt;/strong&gt; &lt;br&gt;
&lt;strong&gt;Functions as values in action here.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:220px&gt;&lt;/div&gt;

&lt;p&gt;We can write it conveniently as $\lambda xyz.e$&lt;/p&gt;

&lt;h1 id=&#34;computing-with-lambda-calculus&#34;&gt;Computing with $\lambda$-Calculus&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We rely on string-rewriting to evaluate
LC expressions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;substitution-of-variables-in-function-applications&#34;&gt;Substitution of variables in function applications&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Notation&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$e[x/e&amp;rsquo;]$ is the expression obtained by substituting all occurances of $x$ in
the expression $e$ with the expression $e&amp;rsquo;$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Substition&lt;/strong&gt; as a way to evaluate function application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$(\lambda x. e) e&amp;rsquo; \implies e[x/e&amp;rsquo;]$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
&amp;amp;&amp;amp; (\lambda x.x x) (\lambda y. y) \\
&amp;amp;\implies&amp;amp; (x x)[x/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)(\lambda y.y) \\
&amp;amp;\implies&amp;amp; y[y/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We can easily get into trouble.&lt;/p&gt;

&lt;p&gt;Substitution cannot be used freely.&lt;/p&gt;

&lt;h1 id=&#34;free-bound-variables&#34;&gt;Free &amp;amp; Bound Variables&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Variables in a function abstraction expression can be &lt;em&gt;free&lt;/em&gt; or &lt;em&gt;bound&lt;/em&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a variable represents the input parameter in a function expression, then
it&amp;rsquo;s considered &lt;em&gt;bound&lt;/em&gt;.  Otherwise, it&amp;rsquo;s &lt;em&gt;free&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;$\mathbf{FV}(e)$ are the free variables of $e$&lt;/li&gt;
&lt;li&gt;$\mathbf{BV}(e)$ are the bound variables&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;variable-capturing&#34;&gt;Variable Capturing&lt;/h1&gt;

&lt;p&gt;Consider an expression:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;There are multiple occurrences of $x$, so let&amp;rsquo;s label them so we can refer to
the individual occurrences.&lt;/p&gt;

&lt;p&gt;$$\lambda x_1. (\lambda x_2.x_3)$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Which input variable does $x_3$ refer to?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is called capturing.&lt;/p&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;There is a rewrite rule that allows us to rename the parameter variables without
changing the meaning of the expression.&lt;/p&gt;

&lt;p&gt;$$ \lambda x. x \equiv \lambda y.y \equiv \lambda \mathsf{hello}.\mathsf{hello} $$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Renaming&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose that $x$ is a free variable of $e$, and $y$ does not appear in $e$ at
all.&lt;/p&gt;

&lt;p&gt;Then $\lambda x.e \implies \lambda y.e[x/y]$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing-1&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;Back to:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;First we consider the sub expression $\lambda x.x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using renaming, we can rewrite it to $\lambda y.y$.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then we get:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$\lambda x. (\lambda x.x) \implies \lambda x.\lambda y. y$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt;
Generally, we only apply &lt;strong&gt;substitution&lt;/strong&gt; to evaluate function applications
if there is &lt;em&gt;no&lt;/em&gt; variable capturing; and this can be achieved by &lt;strong&gt;renaming&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;how-to-perform-computation-using-lc&#34;&gt;How to perform computation using LC?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Natural numbers&lt;/li&gt;
&lt;li&gt;Arithmetics&lt;/li&gt;
&lt;li&gt;Loop and conditional branching&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;All can be done using LC&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Express the algorithm in terms of natural numbers, arithmetics,
 loops and conditional branches.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Encode the algorithm in LC.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Apply syntax rewriting until no more rewriting is possible.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;a-glance-of-lc-in-action&#34;&gt;A glance of LC in action&lt;/h1&gt;

&lt;p&gt;A bit of notation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\lambda x.\lambda y. \lambda z. e$ is written as as $\lambda xyz. e$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Now we can encode numbers:&lt;/p&gt;

&lt;p&gt;$0 \equiv \lambda sx. x$ (takes two inputs, but only keep the second one.)&lt;/p&gt;

&lt;p&gt;$1 \equiv \lambda sx. sx$&lt;/p&gt;

&lt;p&gt;$2 \equiv \lambda sx. ssx$&lt;/p&gt;

&lt;p&gt;$\vdots$&lt;/p&gt;

&lt;h1 id=&#34;arithmetics&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;Consider the simplest arithmetics: increment by 1.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def succ(n):
    return n + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$S \equiv \lambda n. \lambda yx.y(nyx)$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let&amp;rsquo;s try this out.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
S 0 &amp;amp;=&amp;amp; (\lambda n. \lambda yx.ynyx)0 \\
    &amp;amp;=&amp;amp; (\lambda yx.ynyx)[n/0] \\
    &amp;amp;=&amp;amp; \lambda yx.y(0yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y((\lambda sz.z)yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y(x) \\
    &amp;amp;=&amp;amp; 1
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;arithmetics-1&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(n1, n2):
    return n1 + n2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Observe:&lt;/p&gt;

&lt;p&gt;$2 S 3 = 5$ (work it out, it&amp;rsquo;s quite incredible.)&lt;/p&gt;

&lt;p&gt;So, we have:&lt;/p&gt;

&lt;p&gt;$$+ \equiv \lambda mn. mSn$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Can you guess the LC expression for multiplication?&lt;/p&gt;

&lt;h1 id=&#34;recursion&#34;&gt;Recursion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LC does not require assigning aliases to functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Technically, there is just &lt;strong&gt;ONE&lt;/strong&gt; expression for the entire algorthm.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why it&amp;rsquo;s hard to do recursion without aliases?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def factorial(n):
    if n &amp;lt;= 1:
        return n
    else:
        return n * factorial(n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Is it even possible?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s called the &lt;strong&gt;Y&lt;/strong&gt;-combinator.&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} \equiv (\lambda y.(\lambda x.y(xx))(\lambda x.y(xx)))$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;y-combinator&#34;&gt;Y-combinator&lt;/h1&gt;

&lt;p&gt;$$ \mathbf{Y} f = f (\mathbf{Y} f) $$&lt;/p&gt;

&lt;p&gt;So,&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} f x \implies f (\mathbf{Y} f) x \implies f f \dots f x $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; $\mathbf{Y} f$ is a &lt;em&gt;fixed point&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;using-y-combinator-to-implement-factorial&#34;&gt;Using Y-combinator to implement factorial&lt;/h1&gt;

&lt;p&gt;Consider a function $F$ as:&lt;/p&gt;

&lt;p&gt;$$\lambda fx. (\mathrm{ifzero}\ x)\ 1\ (*\ x\ (f\ (\mathrm{dec}\ x)))$$&lt;/p&gt;

&lt;p&gt;If we apply the Y-combinator to $F$, we get:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = F (\mathbf{Y} F) n $$&lt;/p&gt;

&lt;p&gt;You can check the following:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = (\mathrm{ifzero}\ n)\ 1\ (*\ n\ ((\mathbf{Y} F)\ (\mathrm{dec}\ n))) $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is really quite amazing.  We have achieved Turing-completeness via recursion.  The amazing part is that we don&amp;rsquo;t need variables to refer to any values.  So $F$ is just for convenience and readability.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LC is purely symbolic.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It carries out computation by very simple string rewrites:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Function application&lt;/li&gt;
&lt;li&gt;Variable renaming&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It solves problem by:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Encode the problem as a single (huge) string of LC expression.&lt;/li&gt;
&lt;li&gt;Using the rules to rewrite the string to a &lt;em&gt;normal&lt;/em&gt; form.&lt;/li&gt;
&lt;li&gt;The resulting LC expression is the answer.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No variables are needed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/old/intro-to-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/old/intro-to-languages/</guid>
      <description>

&lt;h1 id=&#34;computation-in-practice&#34;&gt;Computation in practice&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Languages based on stateful computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages based on functional computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid languages&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;stateful-computation&#34;&gt;Stateful computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Languages&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Javascript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Task&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Quicksort&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;X = [6, 3, 4, 8, 1, 4]

def quicksort(X, i, j):
  if i &amp;lt; j:
    p = partition(X, i, j)
    quicksort(X, i, p-1)
    quicksort(X, p+1, j)

def partition(X, i, j):
  pivot = X[j]
  m = i
  for n in range(i, j):
    if X[n] &amp;lt;= pivot:
      X[m], X[n] = X[n], X[m]
      m += 1
  X[m], X[j] = X[j], X[m]
  return m

def QuickSort(X):
  return quicksort(X, 0, len(X)-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;breakdown-of-python&#34;&gt;Breakdown of python&lt;/h1&gt;

&lt;div pdf=&#34;qsort-py.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;python-v-s-javascript&#34;&gt;Python v.s. Javascript&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.py&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:600px;overflow:auto&gt;
&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.js&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/stateful-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/stateful-computation/</guid>
      <description>

&lt;h1 id=&#34;computation-the-turing-machine&#34;&gt;Computation &amp;amp; the Turing Machine&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;computation&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;david-hilbert.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hilbert&amp;rsquo;s Ten&amp;rsquo;s problem, 1900&lt;/li&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-1&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;kurt-godel.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Gdel&amp;rsquo;s incompleteness theorem&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-2&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alan-turing.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Turing machine&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-3&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alonzo-church.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;$\lambda$-calculus&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-4&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;john-von-neumann.jpg&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;von Neumann computing model&lt;/li&gt;
&lt;li&gt;EDVAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;turing-machine&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A completely mechanical device (1928)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;envisioned by Alan Turing as an intuitive formalism to
describe the non-existing phenomenon of machine driven
reasoning, now known as &lt;em&gt;computation&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Realized into an actual design (1945)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;John von Neumann designed an electronic version to simulate
the mechanical definition of a TM in a document known as &lt;em&gt;First Draft of a
Report on the EDVAC&lt;/em&gt;, 1945.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Turing-complete&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TM is the most powerful computing model we know.
Up to now, we don&amp;rsquo;t know any other computing models more powerful than
a TM.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;turing-machine-1&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;div pdf=&#34;turing-machine.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;computational-power-of-tm&#34;&gt;Computational power of TM&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Church-Turing Thesis&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a procedure (algorithm) can be executed by &lt;em&gt;any&lt;/em&gt; computer, then it can be
executed by a Turing Machine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Turing Complete&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a mechanism is equivalent to TM, then it&amp;rsquo;s called &lt;em&gt;Turing Complete&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;simulation-of-a-function&#34;&gt;Simulation of a function&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Computable functions&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A function $f$ is computable if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Its input can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its output can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its evaluation can always be carried out by a TM.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Any computable function can be implemented by a TM.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any TM is some computable function.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Why is a TM always a function (over binary strings)?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;universal-tm&#34;&gt;Universal TM&lt;/h1&gt;

&lt;p&gt;Consider a TM: $M$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s a function &lt;code&gt;$M:2^*\to 2^*$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s mechanical description can be encoded as a binary string.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Function &lt;em&gt;eval&lt;/em&gt; takes two inputs - a TM and an input, and it computes the
output.&lt;/p&gt;

&lt;p&gt;$$\mathrm{eval} :\mathrm{TM} \times 2^* \to 2^*$$&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s input can be encoded as binary strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can be carried out by a procedure.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By Church-Turing thesis, &lt;strong&gt;eval&lt;/strong&gt; is computable, so there is a TM for it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Definition&lt;/em&gt; &lt;strong&gt;Universal TM&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The TM $\mathbf{U}$ that computes &lt;strong&gt;eval&lt;/strong&gt; is called &lt;em&gt;universal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;universal-tm-1&#34;&gt;Universal TM&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The TM $\mathbf{U}$ initializes the tape with the binary encoding of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a TM, $M$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;an input, $x$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It outputs $\mathbf{eval}(M, x)$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Modern Computer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$M$ is the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$x$ is the input to the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\mathbf{U}$ is the general purpose computer&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tm-programming&#34;&gt;TM-Programming&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We just need a single TM, namely $\mathbf{U}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The universal programming language is the encoding of $M$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Turing Machine is a mechanically realizable device.&lt;/li&gt;
&lt;li&gt;TM is as powerful (but a lot slower) as any modern computers.&lt;/li&gt;
&lt;li&gt;There is a very special TM that is called the &lt;em&gt;Universal TM&lt;/em&gt;.  It can be
&lt;em&gt;programmed&lt;/em&gt;!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/kenpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/kenpu/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ken Pu&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Associate Professor &lt;br&gt;
&lt;a href=&#34;http://www.science.uoit.ca/undergraduate/programs-and-information-for-prospective-students/computing-science/&#34;&gt;Computer Science&lt;/a&gt; /
&lt;a href=&#34;http://science.uoit.ca&#34;&gt;Faculty of Science, UOIT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Contact&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Email: &lt;code&gt;ken.pu@uoit.ca&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Address:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Faculty of Science, 2000 Simcoe Street North, Oshawa ON, L1H 7K3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Office and telephone:
&lt;a href=&#34;https://ssbp.mycampus.ca/prod/www_directory.directory_uoit.p_ShowPeople?first_name_in=ken&amp;amp;last_name_in=pu&amp;amp;button_text_in=Search&#34;&gt;See here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms</title>
      <link>http://db.science.uoit.ca/courses/algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/</guid>
      <description>&lt;div class=&#34;jumbotron&#34;&gt;
	&lt;h1&gt;Design &amp; Analysis of Algorithms&lt;/h1&gt;
&lt;/div&gt;

&lt;div class=row&gt;
	&lt;div class=col-md-3&gt;
		&lt;img src=&#34;textbook.jpg&#34; width=100%&gt;&lt;/img&gt;
		&lt;figcaption&gt; Introduction to Algorithms, Third Edition, &lt;i&gt;Coremen, Leiserson, Rivest and Stein&lt;/i&gt; &lt;/figcaption&gt;
	    &lt;p style=margin-top:10px;font-style:italic;font-size:90%&gt;
			This course is about problem solving and computation via algorithms.
			We will cover a number of known algorithms (sorting, hashing, search,
			indexing) and their applications.  We will discuss methods for analyzing
			existing algorithms and designing new algorithms.
			Finally, the students will be introduced to &lt;i&gt;complexity classes&lt;/i&gt;, in
			particular the class of &lt;i&gt;NP-completeness&lt;/i&gt;.
		&lt;/p&gt;
	&lt;/div&gt;
	&lt;div class=col-md-9&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Sorting&lt;/h1&gt;
				&lt;p&gt; Chapter 2.1, 2.3, 6, 7, 8&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;insert-sort&#34;&gt;Insertion sort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;merge-sort&#34;&gt;Mergesort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;quicksort&#34;&gt;Quicksort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;optimal-sorting&#34;&gt;
							Comparision based sorting versus numeric sorting
						&lt;/a&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;sorting-numbers&#34;&gt;Sorting integers&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Analysis of Complexity&lt;/h1&gt;
				&lt;p&gt; Chapter 3, 4, 5&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;big-o&#34;&gt;Asymptotic notations&lt;/a&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;recurrence-equation&#34;&gt;Recurrence equations&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;!--
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;&#34;&gt;Probabilistic analysis of randomized algorithms&lt;/a&gt;
						&lt;span style=&#34;float:right&#34; class=&#34;label label-warning&#34;&gt;DRAFT&lt;/span&gt;
                    &lt;/li&gt;
                    --&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Data structures&lt;/h1&gt;
				&lt;p&gt;Chapter 11&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
                    &lt;!--
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Elementary data structures&lt;/a&gt;&lt;/li&gt;
                    --&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;hash-table&#34;&gt;Hash tables&lt;/a&gt;
                    &lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
        &lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Graphs&lt;/h1&gt;
				&lt;p&gt;Chapter 22&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;graph-algorithms&#34;&gt;Graph Algorithms&lt;/a&gt;
                    &lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;mst&#34;&gt;Spanning trees&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Shortest path algorithms&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Maxflow&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Optimization&lt;/h1&gt;
				&lt;p&gt;Chapter 15, 16&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Dynamic programming&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Greedy algorithms&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Huffman codes&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Complexity &amp; Tractability&lt;/h1&gt;
				&lt;p&gt;Chapter 34&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Decision problems&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;P, NP and reduction&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;NP-complete and other complexity classes&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Computability&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

	&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt; a[href=&#34;&#34;] {color: #888;} &lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Asymptotic notation</title>
      <link>http://db.science.uoit.ca/courses/algorithms/big-o/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/big-o/</guid>
      <description>

&lt;h1 id=&#34;complexity-classes&#34;&gt;Complexity classes&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Asymptotic notations and complexity classes&lt;/li&gt;
&lt;li&gt;Intuition&lt;/li&gt;
&lt;li&gt;Properties&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;asymptotic-notation&#34;&gt;Asymptotic notation&lt;/h1&gt;

&lt;p&gt;We will develop a way to measure the efficiency of algorithms which is &lt;em&gt;invariant&lt;/em&gt; to the non-essential issues such as the speed of computer hardware and the effiency of the programming language used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The measurement functions is only sensitive to the &lt;em&gt;growth&lt;/em&gt; of the time it takes for an algorithm to complete with respect to the size of the input.&lt;/p&gt;

&lt;h1 id=&#34;measure&#34;&gt;Measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The size of the input is an integer $n$&lt;/li&gt;
&lt;li&gt;We use functions over integers to measure the efficiency of an algorithm.&lt;/li&gt;
&lt;li&gt;$f(n)$ is the &lt;strong&gt;time&lt;/strong&gt; it takes to process input of size $n$ in the &lt;em&gt;worst case&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;$f$ is monotonic: if $m \leq n$, then $f(m)\leq f(n)$.&lt;/li&gt;
&lt;li&gt;$f$ is strictly positive: $f(n) &amp;gt; 0$ for all $n$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;using-functions-as-measurement-of-algorithmic-complexity&#34;&gt;Using functions as measurement of algorithmic complexity&lt;/h1&gt;

&lt;p&gt;We want to use functions to measure the inherit &lt;em&gt;complexity&lt;/em&gt; of &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is not very straight-forward.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We don&amp;rsquo;t care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Runtime environment&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU speed&lt;/li&gt;
&lt;li&gt;Start-up time of the program&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implementation issues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Speed of the language&lt;/li&gt;
&lt;li&gt;Number of statements used&lt;/li&gt;
&lt;li&gt;Overhead in memory data structure&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We do care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inherit complexity of the algorithm&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;capturing-the-essentials&#34;&gt;Capturing the essentials&lt;/h1&gt;

&lt;p&gt;Suppose that we have an algorithm $P$.  Let&amp;rsquo;s use some function $f(n)$ to represent the time, in the &lt;em&gt;worst case&lt;/em&gt;, that $P$ takes to process an input of size $n$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at the effects of various environmental factors on the measure $f(n)$.&lt;/p&gt;

&lt;h1 id=&#34;effects-on-the-measure&#34;&gt;Effects on the measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$P$ is reimplemented using C (from Python), so it runs 20 times faster now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = \frac{1}{20} f(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$P$ runs inside a &lt;em&gt;docker&lt;/em&gt; image, so it takes an additional 300 ms to start.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = f(n) + 300\mathrm{ms}$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we don&amp;rsquo;t want to care about these implementation and runtime factors when investigating the complexity of algorithms.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Intuition: given $f(n)$, we define family of (infinite) functions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{better\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{worse\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{equivalent\ to}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mathcal-o-notation-better-than&#34;&gt;$\mathcal{O}$-notation - better than&lt;/h1&gt;

&lt;p&gt;We want to define all function which are measure of algorithms which are better than (or same as) $g(n)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The Big-O notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\mathcal{O}(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0 &amp;lt; f(n) &amp;lt; c\cdot g(n)\}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We call $g(n)$ the asymptotic upper bound of the functions in $\mathcal{O}(g(n))$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;big-o.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;significance-of-asymptotic-analysis&#34;&gt;Significance of asymptotic analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If we have an algorithm $A$, and its precise time measurement (on a specific hardware) is given precisely as &lt;code&gt;$T(n)$&lt;/code&gt;, where $n$ is the input size in &lt;em&gt;bytes&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If &lt;code&gt;$T(n)\in\mathcal{O}(g(n))$&lt;/code&gt;, we are saying that $A$ is &lt;strong&gt;better&lt;/strong&gt; than $g(n)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Challenge&lt;/em&gt;:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Check that the variations on the way that the efficiency of $A$ is
measured also are in $\mathcal{O}(g(n))$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$T_1(n)$ is the time that $A$ runs on a slow processor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$T_2(n)$ is the time that $A$ if the input is measured in the array length.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;omega-notation-worse-than&#34;&gt;$\Omega$-notation - worse than&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The $\Omega$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\Omega(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0  &amp;lt; c\cdot g(n) &amp;lt; f(n) \}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We say that $g(n)$ is the asymptotic lower bound of the functions in $\Omega(g(n))$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;omega.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;theta-notation-same-as&#34;&gt;$\Theta$-notation - same as&lt;/h1&gt;

&lt;p&gt;*&lt;em&gt;Definition&lt;/em&gt;: The $\Theta$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\Theta(g(n)) = \mathcal{O}(g(n)) \cap \Omega(g(n))$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;More precisely,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$
\begin{eqnarray}
&amp;amp;&amp;amp; \Theta(g(n)) \\
&amp;amp;=&amp;amp; 
\{f(n): \exists n_0, c_1, c_2 &amp;gt; 0,\forall n &amp;gt; n_0,\ 0 \leq c_1\cdot g(n) \leq f(n) \leq c_2\cdot g(n)\}
\end{eqnarray}
$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;theta.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\mathcal{O}(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are better (or equivalent) to $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\Omega(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are worse (or equivalent) to $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\Theta(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are equivalent to $g(n)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;functions-we-use&#34;&gt;Functions we use:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Polynomials:&lt;/p&gt;

&lt;p&gt;$$f(n) = \sum_{i=0}^d a_i n^i$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exponentials:&lt;/p&gt;

&lt;p&gt;$$f(n) = a^n$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Logorithms&lt;/p&gt;

&lt;p&gt;$$f(n) = \log_a(n)$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Factorials&lt;/p&gt;

&lt;p&gt;$$f(n) = n!$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-exponents&#34;&gt;More about Exponents&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(a^m)^n = a^{mn}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(a^m) (a^n) = a^{m+n}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\lim_{n\to\infty} \frac{n^d}{a^n} = 0$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-logorithms&#34;&gt;More about Logorithms&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$a^{\log_a(n)} = n$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_a(mn) = \log_a(m) + \log_a(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_a(n^d) = d\cdot \log_a(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_b(a) \cdot \log_a(n) = \log_b(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$a^{\log_a (n)} = n^{\log_b(a)}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-factorial&#34;&gt;More about Factorial&lt;/h1&gt;

&lt;p&gt;Stirling&amp;rsquo;s approximation:&lt;/p&gt;

&lt;p&gt;$$ n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^n $$&lt;/p&gt;

&lt;h1 id=&#34;comparisons&#34;&gt;Comparisons&lt;/h1&gt;

&lt;p&gt;For any $a &amp;gt; 1$, $b &amp;gt; 0$ and $c &amp;gt; 1$, we have:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ 
\mathcal{O}(\log_a(n)) \subseteq \mathcal{O}(n^b) \subseteq \mathcal{O}(c^n)
$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We can show that:&lt;/p&gt;

&lt;p&gt;$$ n! \in\mathcal{O}(n^n) $$&lt;/p&gt;

&lt;p&gt;In fact:&lt;/p&gt;

&lt;p&gt;$$ \mathcal{O}(2^n) \subset \mathcal{O}(n^n) $$&lt;/p&gt;

&lt;h1 id=&#34;notation&#34;&gt;Notation&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;s convenient to treat complexity classes as &lt;em&gt;variables&lt;/em&gt; in equations.&lt;/p&gt;

&lt;p&gt;So, we use the following notations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If $f\in \mathcal{O}(g)$, we write it as equality $f=\mathcal{O}(g)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;test-your-understanding&#34;&gt;Test your understanding&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If $f = \mathcal{O}(g)$ and $g = \mathcal{O}(h)$, can you prove that $f =
\mathcal{O}(h)$?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Does it make sense intuitively?&lt;/p&gt;

&lt;p&gt;Does it work out mathematically?&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So that $n^2 + 10000= \mathcal{O}(n^3)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Basics of Scala</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/scala-basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/scala-basics/</guid>
      <description>

&lt;h1 id=&#34;basics-of-scala&#34;&gt;Basics of Scala&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;objects&#34;&gt;Objects&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;var name : String = &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
This creates a &lt;strong&gt;variable&lt;/strong&gt;, with the type &lt;code&gt;String&lt;/code&gt;, and it&amp;rsquo;s initialized to
&amp;ldquo;hello&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;name.CharAt(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
Java-style method invocation&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;______&lt;/h1&gt;

&lt;p&gt;Scala uses the same scoping and symbol bindings.&lt;/p&gt;

&lt;p&gt;There are two types of &lt;em&gt;symbols&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Variables&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bindings to &lt;code&gt;var&lt;/code&gt; can be updated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;var name:String = &amp;quot;Albert&amp;quot;
name = &amp;quot;Einstein&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Values&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bindings to &lt;code&gt;val&lt;/code&gt; is permanent.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val name : String = &amp;quot;Alert&amp;quot;
name = &amp;quot;Einstein&amp;quot;
// error: reassignment to val
//       x = &amp;quot;Einstein&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is the same as Clojure, and it&amp;rsquo;s preferred over &lt;code&gt;var&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;type-inference&#34;&gt;Type Inference&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Definition&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A statically typed language is one that requires the compiler to have complete
type information on all the symbols in the source code &lt;strong&gt;at&lt;/strong&gt; compile-time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Java &lt;strong&gt;and&lt;/strong&gt; Scala are statically typed languages.&lt;/li&gt;
&lt;li&gt;Clojure and Python are not statically typed, but typed (at runtime).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The compiler needs type information specified for &lt;em&gt;all&lt;/em&gt; the symbols.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val name : String = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;____&lt;/h1&gt;

&lt;p&gt;Scala has a feature, known as &lt;em&gt;type inference&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At compile-time, the compiler makes a best attempt to fill in the missing type
information.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val small_integer = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The compiler will see that &lt;code&gt;small_integer&lt;/code&gt; should be &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;var x = y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The compiler will use the type of &lt;code&gt;y&lt;/code&gt; to infer the type of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the interactive interpreter session, you can always inspect the type
information of existing symbols:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;:t small_integer
Int
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;procedural-programming&#34;&gt;Procedural programming&lt;/h1&gt;

&lt;h2 id=&#34;if&#34;&gt;IF&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;if (&amp;lt;cond&amp;gt;) {
  &amp;lt;expression&amp;gt;
} else if (&amp;lt;cond&amp;gt;) {
  &amp;lt;expression&amp;gt;
} else {
  &amp;lt;expression&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
The classic Java-style branching.  Scala has better pattern matching
which is preferred over if-else.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if-else&lt;/code&gt; is an expression, not a statement.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val age = 65
var senior:String = &amp;quot;&amp;quot;
if(age &amp;lt; 65) {
  senior = &amp;quot;Not senior&amp;quot;
} else {
  senior = &amp;quot;Senior&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val age = 65
val senior = if(age &amp;lt; 65) 
               &amp;quot;Not senior&amp;quot;
             else
               &amp;quot;Senior&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;_____&lt;/h1&gt;

&lt;h2 id=&#34;for&#34;&gt;FOR&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for(&amp;lt;val&amp;gt; &amp;lt;- &amp;lt;iterable&amp;gt;) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;All container data structures are iterables: arrays, lists, map, &amp;hellip;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scala has a nice way to generate iterables over integer ranges:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 to 10     // 1, 2, ... 10
1 until 10  // 1, 2, ... 9
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;for(x &amp;lt;- 1 to 10) {
  println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
Scala&amp;rsquo;s &lt;code&gt;for&lt;/code&gt; loop is much more powerful then simple iteration.  More on this
in lectures on programming with sequences.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;_____________&lt;/h1&gt;

&lt;h2 id=&#34;loops&#34;&gt;Loops&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;while(&amp;lt;cond&amp;gt;) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;do {
    ...
} while(&amp;lt;cond&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;syntax-rules&#34;&gt;Syntax rules&lt;/h1&gt;

&lt;p&gt;Suppose that an object has zero or one argument.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.method()
obj.method(arg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the parenthesis can be omitted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.method
obj.method arg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The dot can also be omitted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj method
obj method arg
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;_____&lt;/h1&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 + 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is actually a method invocation in disguise.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.+(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The equivalent syntax in method invocation.  The method name is &lt;code&gt;+&lt;/code&gt;,
the object is &lt;code&gt;1&lt;/code&gt;, and the argument is &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This type of syntax rule allows us to introduce user-defined operators to
support programming constructs such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x multiplyWith y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We assume that the object &lt;code&gt;x&lt;/code&gt; has a method called &lt;code&gt;multiplyWith&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can also invoke Java methods like operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;hello&amp;quot; charAt 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;syntax-rules-1&#34;&gt;Syntax rules&lt;/h1&gt;

&lt;p&gt;More syntax rules to come.&lt;/p&gt;

&lt;h1 id=&#34;functions&#34;&gt;Functions&lt;/h1&gt;

&lt;p&gt;Functions are in fact objects of a &lt;em&gt;function&lt;/em&gt; class.  Scala offers a succinct
syntax for defining functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;import scala.math
val area = {(count:Int, radius:Float) =&amp;gt; x * scala.math.Pi * radius * radius}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm clipboard&#34;&gt;val area : (Int, Float) =&amp;gt; Double = {
  (count, radius) =&amp;gt; {
    var total: Double = 0
    for(i &amp;lt;- 0 until count) {
        total += scala.math.Pi * radius * radius
    }
    total
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;The type of the &lt;code&gt;val&lt;/code&gt; is &lt;code&gt;(Int, Float) =&amp;gt; Double&lt;/code&gt;.  This is also known as
the &lt;em&gt;function signature&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The value is a function (instance of a class Function2).&lt;/li&gt;
&lt;li&gt;The inputs are bound to symbols &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;radius&lt;/code&gt;.
Note the binding types are inferred based on the function signature.
&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bindings&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Procedural programming&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Object method invocation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function as data&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Bucket Sort</title>
      <link>http://db.science.uoit.ca/courses/algorithms/bucket-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/bucket-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Clojure 3</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/clojure-language-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/clojure-language-3/</guid>
      <description>

&lt;h1 id=&#34;clojure-part-iii&#34;&gt;Clojure Part III&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;data-read-write-transformation&#34;&gt;Data Read &amp;amp; &lt;del&gt;Write&lt;/del&gt; &amp;amp; Transformation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;List&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vector&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(Hash-) Map&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;list&#34;&gt;List&lt;/h1&gt;

&lt;p&gt;Create&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(list ...)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Read&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(first seq)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(nth seq n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Transformation&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(cons elem seq)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(conj seq elem ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(rest seq)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;vector&#34;&gt;Vector&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Create&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[ ... ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(vector ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(vec seq)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(into v seq)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Read: Vectors are &lt;em&gt;functions&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(v n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(get v n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(nth v n)&lt;/code&gt;, &lt;code&gt;(first ...)&lt;/code&gt; still apply.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Transformation&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;conj&lt;/code&gt;, &lt;code&gt;cons&lt;/code&gt;, &lt;code&gt;rest&lt;/code&gt; still apply.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(assoc v n val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(update v n func)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(subvec v start end)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(replace map v)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;hash-map&#34;&gt;(Hash-) Map&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Create&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{ ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(hash-map ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(array-map ...)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Read: maps are functions, and keywords are functions!!&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(m key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(:keyword m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(get m key default-val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(keys m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(vals m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(contains? m key)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Transform&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(assoc m key val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(assoc-in m [path] val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(dissoc m key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(merge m1 m2 ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(merge-width f m1 m2 ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(select-keys m [keys])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(update m key func)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(update-in m [path] func)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(rename-keys m rename-map)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;sequences&#34;&gt;Sequences&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;sequences-1&#34;&gt;Sequences&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Think of it as another data structure, known as &lt;em&gt;seq&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The closest thing we have seen is &lt;em&gt;Iterable&lt;/em&gt; in Java.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Seqs gets the most amount attention in Clojure.&lt;/p&gt;

&lt;h1 id=&#34;sources-of-seqs&#34;&gt;Sources of seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(range &amp;lt;start&amp;gt; &amp;lt;end&amp;gt; &amp;lt;step&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Creates a sequence of integers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(repeat &amp;lt;n&amp;gt; &amp;lt;x&amp;gt;)
(repeat &amp;lt;x&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Creates a sequence of the same value &lt;code&gt;x&lt;/code&gt; repeately &lt;code&gt;n&lt;/code&gt; times.  If &lt;code&gt;n&lt;/code&gt;
is omitted, the sequence continuous forever.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(iterate &amp;lt;f&amp;gt; &amp;lt;x&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; A sequence with: &lt;code&gt;x&lt;/code&gt; &lt;code&gt;(f x)&lt;/code&gt;, &lt;code&gt;(f (f x))&lt;/code&gt;, &amp;hellip; &lt;em&gt;forever&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(repeatedly &amp;lt;n&amp;gt; &amp;lt;f&amp;gt;)
(repeatedly &amp;lt;f&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; A sequence with: &lt;code&gt;(f)&lt;/code&gt;, &lt;code&gt;(f)&lt;/code&gt;, &amp;hellip; $n$ times.  If $n$ is omitted, the
sequence continuous forever.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(cycle &amp;lt;collection&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Generates an infinite sequence of by repeating the collection forever.&lt;/p&gt;

&lt;h1 id=&#34;more-sources-of-seqs&#34;&gt;More sources of seqs&lt;/h1&gt;

&lt;h2 id=&#34;readers&#34;&gt;Readers:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(clojure.java.io/reader &amp;lt;filename&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-a-sequence-of-lines&#34;&gt;Creating a sequence of lines&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(line-seq &amp;lt;rdr&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Don&amp;rsquo;t forget to close the reader when you are done.  To be safe, use the macro:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(with-open [rdr (clojure.java.io/reader &amp;lt;filename&amp;gt;)]
  (let [lines (line-seq rdr)]
    ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The &lt;code&gt;with-open&lt;/code&gt; macro will create the symbol binding to the opened
reader, and close it afterwards.&lt;/p&gt;

&lt;h1 id=&#34;even-more-sources-of-seqs&#34;&gt;Even more sources of seqs&lt;/h1&gt;

&lt;h2 id=&#34;regular-expression&#34;&gt;Regular expression&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#&amp;quot;...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Clojure relies on Java&amp;rsquo;s regular expression library.  So the syntax
for regular expressions is the same as Java&amp;rsquo;s &lt;code&gt;java.util.regex&lt;/code&gt; library.  But
creating a pattern is really simple with the reader macro &lt;code&gt;#&amp;quot;...&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;sequences-of-matches&#34;&gt;Sequences of matches&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(re-seq &amp;lt;pattern&amp;gt; &amp;lt;string&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a sequence of matches of pattern in the string.  If the
pattern does &lt;strong&gt;not&lt;/strong&gt; contain groups, then each match is a string.  Otherwise,
it&amp;rsquo;s a vector containing the groups.&lt;/p&gt;

&lt;h1 id=&#34;working-with-seqs&#34;&gt;Working with seqs&lt;/h1&gt;

&lt;div style=height:150px&gt;&lt;/div&gt;

&lt;h2 id=&#34;fast-and-furious&#34;&gt;&lt;em&gt;Fast and furious&lt;/em&gt;&lt;/h2&gt;

&lt;h1 id=&#34;working-with-seqs-1&#34;&gt;Working with seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def nat (iterate inc 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Defining natural numbers.  This is an infinite sequence, so &lt;code&gt;(println nat)&lt;/code&gt; will result in a
never-ending loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def nat+ (rest nat))
; (1 2 3 4 5 ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Strictly positive numbers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(first nat)   ; 0
(first nat+)  ; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Getting the first element&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(take 10 nat)
; (0 1 2 3 4 5 6 7 8 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Takes the first 100 natural numbers.&lt;/p&gt;

&lt;h1 id=&#34;working-with-seqs-2&#34;&gt;Working with seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(interleave &amp;lt;seq1&amp;gt; &amp;lt;seq2&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Mix two sequences into one by interleaving the elements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(interpose &amp;lt;x&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Insert &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; between the elements in &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(split-at &amp;lt;index&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a vector containing &lt;em&gt;two&lt;/em&gt; seqs.  The two seqs are produced by
splitting the input &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt; at the &lt;code&gt;&amp;lt;index&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;higher-order-functions-with-seqs&#34;&gt;Higher order functions with seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(map &amp;lt;fn&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a sequence by applying &lt;code&gt;(&amp;lt;fn&amp;gt; x)&lt;/code&gt; for each &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(map &amp;lt;fn&amp;gt; &amp;lt;seq-1&amp;gt; &amp;lt;seq-2&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a sequence by applying &lt;code&gt;(&amp;lt;fn&amp;gt; xi yi)&lt;/code&gt; for each &lt;code&gt;xi&lt;/code&gt; in &lt;code&gt;&amp;lt;seq-1&amp;gt;&lt;/code&gt; and &lt;code&gt;yi&lt;/code&gt; in &lt;code&gt;&amp;lt;seq-2&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(filter &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The function &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; is a &lt;em&gt;predicate&lt;/em&gt;, namely a function that always
returns &lt;code&gt;true/false&lt;/code&gt;.  The returned seq contains elements &lt;br&gt;
&lt;code&gt;x$\in$&amp;lt;seq&amp;gt;&lt;/code&gt; that satisfies the
predicate, i.e. &lt;code&gt;(&amp;lt;pred&amp;gt; x)&lt;/code&gt; is true.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(reduce &amp;lt;f&amp;gt; &amp;lt;seq&amp;gt;)
(reduce &amp;lt;f&amp;gt; &amp;lt;x0&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Reduces a sequence (x1 x2 x3) to a single value of &lt;br&gt;
&lt;code&gt;(f (f (f x0) x1) x3)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;more-higher-order-functions-on-seqs&#34;&gt;More higher order functions on seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(take-while &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Takes elements &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt; for as long as &lt;code&gt;(&amp;lt;pred&amp;gt; x)&lt;/code&gt; is true.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(drop-while &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Drops elements &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt; for as long as &lt;code&gt;(&amp;lt;pred&amp;gt; x)&lt;/code&gt; is true.
Returns the remaining elements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(split-with &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a vector of two seqs.  The first is &lt;code&gt;(take-while ...)&lt;/code&gt; and the
second is &lt;code&gt;(drop-while ...)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;predicates-on-seqs&#34;&gt;Predicates on seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(every? &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Tests if &lt;em&gt;pred&lt;/em&gt; holds for every element of the seq.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(some &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns the first element in seq that satisfies the predicate.
It can be used to test if &lt;em&gt;pred&lt;/em&gt; holds for some element of the seq.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(not-every? &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Test that predicate is violated by some elements in seq.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(not-any? &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Test that none of the elements in seq satisfies the predicate.&lt;/p&gt;

&lt;h1 id=&#34;transformations-of-seqs&#34;&gt;Transformations of seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(sort &amp;lt;seq&amp;gt;)
(sort &amp;lt;cmp&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Sorts the seq by an optional comparator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(sort-by &amp;lt;key-fn&amp;gt; &amp;lt;seq&amp;gt;)
(sort-by &amp;lt;key-fn&amp;gt; &amp;lt;cmp&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Sorts the seq by &lt;code&gt;(&amp;lt;key-fn&amp;gt; x)&lt;/code&gt; instead of the elements &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(reverse seq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Reverses the sequence.&lt;/p&gt;

&lt;h1 id=&#34;seq-in-action&#34;&gt;Seq in action&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def nat (iterate inc 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn even? [n] (zero? (mod n 2)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;seq-in-action-1&#34;&gt;Seq in action&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def even-nat (filter even? nat))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def odd-nat (filter #(not (even? %1)) nat))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(take 4 even-nat)       ; (0 2 4 6)
(take 4 odd-nat)        ; (1 3 5 7)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(interleave odd-nat even-nat)
; =&amp;gt; (1 0 3 2 5 4 7 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;seq-in-action-2&#34;&gt;Seq in action&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn prime? [n] (not-any? (fn [i] (zero? (mod n i))) (range 2 n)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def primes (filter prime? (drop 2 nat)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(take 100 primes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Questions:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Does the gap between two adjacent primes grow?&lt;/li&gt;
&lt;li&gt;How many primes $\leq n$ are there for growing n?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;tricks-magic&#34;&gt;Tricks &amp;amp; Magic&lt;/h1&gt;

&lt;h2 id=&#34;the-trick&#34;&gt;The trick&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def letters [\a \b \c])
(def numbers [ 1  2  3   4  5  6])
(map vector letters numbers)
; =&amp;gt; ([\a 1] [\b 2] [\c 3])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-magic&#34;&gt;The magic&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def prime-gaps
  (map #(apply - (reverse %)) (map vector primes (rest primes))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tricks-magic-1&#34;&gt;Tricks &amp;amp; Magic&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn count-primes [n] (count (take-while #(&amp;lt;= % n) primes)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def prime-counts (map count-primes nat))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Theorem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The distribution of primes is $\Theta(n/\log n)$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn g [n] (if (&amp;gt; n 1) (/ (float n) (Math/log n)) 1))
(def alpha (map #(/ %1 (g %2)) prime-counts nat))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;a-preview-of-the-leverage-on-jvm&#34;&gt;A preview of the leverage on JVM&lt;/h1&gt;

&lt;p&gt;You need to include &lt;code&gt;incanter.jar&lt;/code&gt; in the CLASSPATH to run the following code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(use &#39;(incanter core charts))
(let [ds (conj-cols (take 1000 nat) (take 1000 alpha))]
  (view (xy-plot 0 1 :data ds)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;xy-plot-alpha.png&#34; style=float:right&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;more-sorcery&#34;&gt;More sorcery&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(view 
  (scatter-plot 0 1 
                :data (conj-cols 
                        (take 1000 nat) 
                        (take 1000 prime-gaps))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;scatter-plot-gaps.png&#34; style=float:right&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;in-one-fell-swoop&#34;&gt;In one fell swoop&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(use &#39;(incanter core charts))
(let [; list of natural numbers
      nat (iterate inc 0)
      ; a predicate to decide of input is prime
      prime? (fn [n] 
               (not-any? 
                 (fn [i] (zero? (mod n i))) 
                 (range 2 n)))
      ; list of primes
      primes (filter prime? nat)
      ; compute the gaps between to adjacent primes
      gaps (map 
              #(apply - (reverse %))
              (map vector primes (rest primes)))
      ; counts the number of primes less than n
      countp (fn [n] (count (take-while #(&amp;lt; % n) primes)))]
    ; plots
    (view (scatter-plot 0 1 :data (conj-cols (take 1000 nat) (take 1000 gaps))))
    (view (xy-plot 0 1 :data (conj-cols (take 1000 nat) 
                             (map #(* (Math/log %) (/ (countp %) (float %)))
                                  (take 1000 nat))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;li&gt;Data transformation&lt;/li&gt;
&lt;li&gt;Sequences&lt;/li&gt;
&lt;li&gt;Sequence (higher-order) functions&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>