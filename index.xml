<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>db@uoit</title>
    <link>http://db.science.uoit.ca/index.xml</link>
    <description>Recent content on db@uoit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://db.science.uoit.ca/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Mobile recommender</title>
      <link>http://db.science.uoit.ca/projects/mobile-recommender/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/projects/mobile-recommender/</guid>
      <description>&lt;p&gt;Your mobile phone knows more about what&amp;rsquo;s going on than you realize, and
therefore, it should be able to make better recommendations that it&amp;rsquo;s doing now.&lt;/p&gt;

&lt;p&gt;In this project, we are building a new mobile based recommender system that can
safely and privately observe its environment, deduce the situational context,
and make more sensible recommendations to the user.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pixel level visualization</title>
      <link>http://db.science.uoit.ca/projects/pixel-packing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/projects/pixel-packing/</guid>
      <description>&lt;p&gt;There are over 1.5 million IMDB movie entries, and roughly the same number of
pixels on a mobile device.  Is it possible to build an algorithm to map each
movie to a single pixel for the purpose of data visualization?&lt;/p&gt;

&lt;p&gt;We are looking into ways of discovering graph structures based on a relational
database, and then use the graph structure to generate a pixel level data
visualization of (up to) millions of relational entities.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Stream algebra for computer vision</title>
      <link>http://db.science.uoit.ca/projects/vision-pipeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/projects/vision-pipeline/</guid>
      <description>&lt;p&gt;Computer Vision algorithms are challenging to implement. The data input is a big
data stream, and the intermediate processors often require fine tuning.&lt;/p&gt;

&lt;p&gt;We are investigating the applications of streaming database technology to enable
rapid development, deployment and tuning of computer vision workflow by the
means of formal streaming algebra and structural optimization of algebraic
expressions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Practical constraint solvers</title>
      <link>http://db.science.uoit.ca/projects/constraint-db/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/projects/constraint-db/</guid>
      <description>&lt;p&gt;If computers can &lt;a href=&#34;https://en.wikipedia.org/wiki/AlphaGo&#34;&gt;play Go&lt;/a&gt; brilliantly,
why can&amp;rsquo;t we use our mobile phones to solve general puzzles?&lt;/p&gt;

&lt;p&gt;The reason is that we don&amp;rsquo;t have a great algebra (and an interface) to enable
user access to the powerful constraint solvers.  This project is to investigate
the design and feasibility of such constraint solving interfaces (either as an
application, or a special purpose programming language).&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/helala/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/helala/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Mohamed Helala&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PhD Candidate in Computer Science&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Developing the theory and system of scalable streaming systems for computer
vision applications.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/ferron/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/ferron/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Michael Ferron&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Master in Computer Science&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Working on pixel level visualization of Big Data.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/hedrick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/hedrick/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Adele Hedrick&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Master in Computer Science&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Building a mobile recommender system&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/lo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/lo/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Calvin Lo&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Honours Thesis in Bachelor of Science (Computer Science):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Personal event management using Twitter as a protocol&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/milayhov/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/milayhov/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Alex Mihaylov&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Summer research student&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Working on boolean-decision diagram based algorithms&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/pacewicz/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/pacewicz/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Dennis Pacewicz&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Honours Thesis in Bachelor of Science (Computer Science):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In-browser data processing and visualization&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/phillips/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/phillips/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Caleb Phillips&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Honours Thesis in Bachelor of Science (Computer Science):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Supporting function-variables to logical programming&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/beirami/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/beirami/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Amin Beirami&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Master in Computer Science&lt;/p&gt;

&lt;p&gt;To be decided.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/lemmon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/lemmon/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Joshua Lemmon&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Honours Thesis in Bachelor of Science (Computer Science):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Relational Learning&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/stoica/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/stoica/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Andrei Stoica&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Honours Thesis in Bachelor of Science (Computer Science):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Application of Neural Networks to Source Code Analysis&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Programming languages &amp; Concurrency</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/concurrency/</link>
      <pubDate>Tue, 22 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/concurrency/</guid>
      <description>

&lt;h1 id=&#34;programming-languages-concurrency&#34;&gt;Programming Languages &amp;amp; Concurrency&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Scaling from single-core to multi-core to multiple hundreds of cores.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;--------------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;float:right&#34;&gt;
Ken Pu &lt;br&gt;
UOIT, 2016
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;elements-of-computation&#34;&gt;Elements of Computation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU as a function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory as persistent state.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Programming languages are designed to communicate:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Types&lt;/strong&gt;: Format and interpretation of memory content.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Expressions&lt;/strong&gt;: Description of computations to be carried out.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; Today, we will examine the &lt;em&gt;expressions&lt;/em&gt; that support concurrent
programming.&lt;/p&gt;

&lt;h1 id=&#34;programming-paradigm&#34;&gt;Programming paradigm&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Imperative programming:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A programming paradigm that makes the distinction
between &lt;em&gt;statements&lt;/em&gt; and &lt;em&gt;expressions&lt;/em&gt;.  Statements modify the state of
its runtime environment, while expressions use certain existing values to
evaluate another value.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functional programming:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A programming paradigm that forbiddens modification of existing values.
All values are created once, and remain read-only.  Functions and data are
unified, known as &lt;em&gt;functions as data&lt;/em&gt;.  State of the runtime is modeled
not by data (in the sense of imperative programming), but rather one or
more functions.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Modern languages are designed with features supporting both paradigms.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; But what about &lt;em&gt;Object-oriented&lt;/em&gt; programming paradigm?&lt;/p&gt;

&lt;h1 id=&#34;concurrency&#34;&gt;Concurrency&lt;/h1&gt;

&lt;p&gt;First of all, &lt;em&gt;concurrency is not parallism&lt;/em&gt;.
&lt;a href=&#34;https://talks.golang.org/2012/waza.slide#1&#34;&gt;1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s the distinction?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Concurrency is about the &lt;em&gt;programming&lt;/em&gt; constructs that allow &lt;em&gt;programmers&lt;/em&gt; to
compose multiple interdependent (but non-sequential) units of computation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallelism is about &lt;em&gt;executing&lt;/em&gt; units of computation using multiple
interdependent processors.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Parallelism&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Multi-core&lt;/li&gt;
&lt;li&gt;Cluster&lt;/li&gt;
&lt;li&gt;The Internet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Concurrency&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Code constructs (threads, goroutines, channels, futures, promises, async,
scatter-gather, &amp;hellip;)&lt;/li&gt;
&lt;li&gt;Even single-core, one-process program can be &lt;em&gt;concurrent&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;concurrency-supset-parallelism&#34;&gt;Concurrency $\supset$ Parallelism&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrency is about &lt;em&gt;programming&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concurrency is about a way to &lt;em&gt;think&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concurrent programming is to adapt to the ever increasing parallel runtime
environments.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;                    +------------------------+
                    | Concurrent Programming |
                    +-----------+------------+
                                |
      +--------------+----------+-----+------------------+
      |              |                |                  |
      |              |                |                  |
+----------+    +----------+   +-------------+   +-----------------+
| IPHONE   |    | ANDROID  |   | Desktop     |   | Cluster         |
| 2 cores  |    | 4 cores  |   | 16-32 cores |   | ~500-1000 cores |
+----------+    +----------+   +-------------+   +-----------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;concurrent-programming&#34;&gt;Concurrent programming&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrent programming is not an extention of imperative programming.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java&amp;rsquo;s threading model is fundamentally prohibitive from a programmer&amp;rsquo;s
perspective.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-composition&#34;&gt;Computation &amp;amp; Composition&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Composition&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(x)
let z = h(y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let z = h(g(f(...)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;No concurrency.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Independent computation&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(...)
let z = h(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can evaluate &lt;code&gt;f, g&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; on separate processors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;spawn { x = f(...) }
spawn { y = g(...) }
spawn { z = h(...) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;_________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Partial composition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x = f(...)
let y = g(...)
let z = h(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can evaluate &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; on separate processors, and use the results to
evaluate &lt;code&gt;h&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x = result of spawn { f(...) }
y = result of spawn { g(...) }

wait-for-all(x, y) as (x, y) {
    z = h(x, y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;____________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Partial composition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(...)
let z = x or y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x = result of spawn { f(...) }
y = result of spawn { g(...) }

wait-for-any(x, y) as (u) {
    z = u
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Transaction&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions may &lt;em&gt;fail&lt;/em&gt; to complete, and result in error.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Transaction:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;snapshot()
h(g(f(...)))

if error:
  reverse back to snapshot()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;transaction {
    f()
    g()
    h()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;_______________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Data exchange&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Long running functions that require data from one another mutually
recursively.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;F() {
  get x from G
  send x&#39; back to G
  ...
}

G() {
  send x to F
  get x&#39; from F
  ...
}

spawn F()
spawn G()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We can have multi-way data exchange among multiple long running
functions.&lt;/p&gt;

&lt;h1 id=&#34;let-s-get-practical&#34;&gt;Let&amp;rsquo;s get &lt;em&gt;practical&lt;/em&gt; âœŒ&lt;/h1&gt;

&lt;p&gt;Multicore&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1) Go&lt;/p&gt;

&lt;p&gt;2) Clojure&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Hundreds of cores&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;3) RabbitMQ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;go-independent-computation&#34;&gt;Go: independent computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func is_prime(n int64) bool {
    for(i := 2; i &amp;lt; n; i++) {
        if n % i == 0 {
            return false
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compute the 1000th prime number.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func is_perfect(n int64) bool {
    var total int64 = 0
    for i := int64(1); i &amp;lt; n; i++ {
        if n % i == 0 {
            total += i
        }
    }
    return total == n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compute the 4th perfect number.&lt;/p&gt;

&lt;h1 id=&#34;toc_14&#34;&gt;__________________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func nth_prime(nth int) int64 {
    found := 0
    var n int64
    for n = 2; found &amp;lt; nth; i++ {
        if is_prime(n) {
            found += 1
        }
    }

    if found == nth {
        prime_1000 = n
    }
}

ans1 := nth_prime(1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do some refactoring so we can reuse the code for the 4th perfect number.&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;______________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func look_for(predicate func(int64) bool, nth int) {
    found := 0
    var n int64
    for n = 2; found &amp;lt; nth; i++ {
        if predicate(n) {
            found += 1
        }
    }
    if found == nth {
        return n
    } else {
        return 0
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;__________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var prime_1000 int
var perfect_4 int

go func() {
    prime_1000 = look_for(is_prime, 1000)
}()

go func() {
    perfect_4 = look_for(is_perfect, 4)
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-independent-computation&#34;&gt;Clojure: Independent computation&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn prime? [n]
  (every? #(not (zero? (mod n %1))) (range 2 n)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn perfect? [n]
  (let [factors (filter #(zero? (mod n %)) (range 1 n))]
    (= n (reduce + 0 factors))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn look-for [pred n]
  (nth (filter pred (iterate inc 2)) n))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_18&#34;&gt;_______________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def prime-1000 (future (look-for prime? 1000)))

(def perfect-4  (future (look-for perfect? 4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
&lt;code&gt;(future ...)&lt;/code&gt; evaluates the expression in the background.  When it&amp;rsquo;s complete,
the result is saved in the &lt;em&gt;reference&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;partial-composition&#34;&gt;Partial composition&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Problem to solve&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;Find the sum of the 1000-th prime and the 4th perfect number.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Solutions&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Goroutine &amp;amp; channels&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clojure futures and deref of futures&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;goroutine-and-channels&#34;&gt;Goroutine and channels&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;We have already seen goroutines:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;go f(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Channels are native type in Go.  You can send &lt;em&gt;anything&lt;/em&gt; over a channel.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var ch = make(chan int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Create a bi-directional channel for exchanging integers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var i int = &amp;lt;- ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Read an integer from the channel.  If nothing is in the channel, this
will block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;ch &amp;lt;- 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Writes an integer into the channel.&lt;/p&gt;

&lt;h1 id=&#34;toc_21&#34;&gt;______________________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm nu&#34;&gt;func computation() int64 {
    var ch chan int64 = make(chan int64)

    go func() {
        p := look_for(is_prime, 1000)
        ch &amp;lt;- p
    }()

    go func() {
        q := look_for(is_perfect, 4)
        ch &amp;lt;- q
    }()

    result := (&amp;lt;-ch) + (&amp;lt;-ch)
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Line 14. blocks until both prime/perfect numbers are computed.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-solution&#34;&gt;Clojure&amp;rsquo;s solution&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def prime-1000 (future (look-for prime? 1000)))
(def perfect-4  (future (look-for perfect? 4)))
(println (+ (deref prime-1000) (deref perfect-4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
&lt;code&gt;deref&lt;/code&gt; blocks until the result of the &lt;code&gt;future&lt;/code&gt;s are available, and returns the
result.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Here is a more functional style:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(let [a (future (look-for prime? 1000))
      b (future (look-for perfect? 4))
      result (+ @a @b)]
  (println result))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;partial-composition-1&#34;&gt;Partial composition&lt;/h1&gt;

&lt;p&gt;Now, let&amp;rsquo;s consider a different problem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute either the 1000th prime, or the 4th perfect number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The strategy is to concurrently evaluate both computations, and as soon as one
is done, return it.&lt;/p&gt;

&lt;h1 id=&#34;go-s-channel-selection&#34;&gt;Go&amp;rsquo;s channel selection&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;select {
case v1 = &amp;lt;- ch1:
    ...
case v2 = &amp;lt;- ch2:
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
This tries to read from &lt;code&gt;ch1&lt;/code&gt; or &lt;code&gt;ch2&lt;/code&gt;, and it guarantees to read only at most one of
them.  If both channels are empty, then &lt;code&gt;default&lt;/code&gt; case is evaluated.&lt;/p&gt;

&lt;h1 id=&#34;go-s-solution-using-select&#34;&gt;Go&amp;rsquo;s solution using &lt;code&gt;select&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func async_look_for(cond func(int64) bool, nth int) chan int64 {
    ch := make(chan int64)
    go func() {
        ch&amp;lt;- look_for(cond, nth)
    }()
    return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; Pretty cool.  Instead of returning the result, we wrap the result in a
channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func computation() int64 {
    result1 := async_look_for(is_prime, 1000)
    result2 := async_look_for(is_perfect, 4)

    var answer int64
    select {
    case answer = &amp;lt;-result1:
    case answer = &amp;lt;-result2:
    }
    return answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; The &lt;code&gt;select { ... }&lt;/code&gt; will block until the first prime/perfect number
is computed.&lt;/p&gt;

&lt;h1 id=&#34;go-s-solution-using-pure-channel-operations&#34;&gt;Go&amp;rsquo;s solution using pure channel operations&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func async_look_for(cond func(int64) bool, nth int, results chan int64) {
    ch := make(chan int64)
    go func() {
        results&amp;lt;- look_for(cond, nth)
    }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func computation() {
    results = chan int64

    async_look_for(is_prime, 1000, results)
    async_look_for(is_perfect, 4, results)

    answer := &amp;lt;-results
    close(results)
    return answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We pass a channel into &lt;code&gt;async_look_for&lt;/code&gt; to collect their results of
computation.  As soon as one result appears in the channel, we are done.&lt;/p&gt;

&lt;h1 id=&#34;conclusion-for-go&#34;&gt;Conclusion for Go:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Channels + Goroutines = Really powerful and universal solution&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is called the &lt;em&gt;Communicating Sequential Processes&lt;/em&gt; (CSP)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;clojure-s-csp&#34;&gt;Clojure&amp;rsquo;s CSP&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;(require &#39;[clojure.core.async :as async :refer :all])&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(go ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Starts a go-routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(chan)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Constructs a bi-directional channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(&amp;lt;! ch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Read one value from the channel.  It blocks in the go-routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(&amp;gt;! ch x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Writes one value into the channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(close! ch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Closes the channel.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-solution-using-alt&#34;&gt;Clojure&amp;rsquo;s solution - using alt!&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [[val ch] (alt! [ch1 ch2 ...])]
    ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;alt!&lt;/code&gt; blocks until one of the channels receives some value.
Returns the value and the channel it comes from.&lt;/p&gt;

&lt;p&gt;There are two version:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alt!&lt;/code&gt; is used in a go-routine.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt!!&lt;/code&gt; is used in the context of an actual thread.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_30&#34;&gt;___________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn async-look-for [pred n]
  (let [ch (chan)]
    (go (&amp;gt;! ch (look-for pred n)))
    ch))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn computation []
  (let [ch1 (async-look-for prime? 1000)
        ch2 (async-look-for perfect? 4)]
    (let [ans ch] (alt!! [ch1 ch2])
      ans)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-s-solution-using-pure-channel-operations&#34;&gt;Clojure&amp;rsquo;s solution - using pure channel operations&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn async-look-for [pred n results]
  (go (&amp;gt;! results (look-for pred n))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn computation []
  (let [ch (chan)]
    (future
      (do (async-look-for prime? 1000 ch)
          (async-look-for perfect? 4 ch)))
    (let [ans (&amp;lt;!! ch)]
      (close! ch)
      ans)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Clojure already had a rich set of concurrency constructs (2007-2015).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CSP is so successful as a model to express concurrency compositions that
Clojure added support for CSP, and it is the preferred way.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;scaling-to-multiple-machines&#34;&gt;Scaling to multiple machines&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s revisit CSP:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Go routines&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Channels&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We just need to implement go-routines and channels over the network.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;go-routines = processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;channels = message queues&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;introducing-rabbitmq&#34;&gt;Introducing RabbitMQ&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;rabbitmq.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Provides queueing service as a standalone server, or a server cluster.&lt;/p&gt;

&lt;h1 id=&#34;message-queues-are-channels-between-machines&#34;&gt;Message queues are channels between machines&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;rmq-example.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;discovering-primes&#34;&gt;Discovering primes&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn feed []
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;input-queue&amp;quot;]
    (doseq [i (iterate inc 0)]
      (publish ch queue i))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Places all numbers on the queue called &lt;em&gt;input-queue&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_37&#34;&gt;___________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def output
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;output-queue&amp;quot;]
    {:ch ch
     :queue queue}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Declare the queue that will gather the answers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn task []
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;input-queue&amp;quot;]
    (subscribe ch queue 
            (fn [i] (when (__prime__? i)
                      (publish output i))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Get a job, &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Performs the computation &lt;code&gt;(prime? i)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If we get a prime, send it to the output queue.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt; (defn worker []
  (dotimes [i 32] (future (task))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; start 32 concurrent sessions to do the tasks assuming we have 32 cores.&lt;/p&gt;

&lt;h1 id=&#34;toc_38&#34;&gt;_____________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## Start the job feeder
nohup clojure feed.clj &amp;amp;

## start the remote workers
for m in $machines
do
    ssh $m nohup clojure worker.clj
done

## Subscribe to output queue, and save to database
nohup clojure result-to-db.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;$machine&lt;/code&gt; may have 100 AWS instances = $32\times 100 = 3,200$ cores.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>