<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Courses on db@uoit</title>
    <link>http://db.science.uoit.ca/courses/index.xml</link>
    <description>Recent content in Courses on db@uoit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://db.science.uoit.ca/courses/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Programming languages &amp; Concurrency</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/concurrency/</link>
      <pubDate>Tue, 22 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/concurrency/</guid>
      <description>

&lt;h1 id=&#34;programming-languages-concurrency&#34;&gt;Programming Languages &amp;amp; Concurrency&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Scaling from single-core to multi-core to multiple hundreds of cores.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;--------------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;float:right&#34;&gt;
Ken Pu &lt;br&gt;
UOIT, 2016
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;elements-of-computation&#34;&gt;Elements of Computation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU as a function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory as persistent state.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Programming languages are designed to communicate:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Types&lt;/strong&gt;: Format and interpretation of memory content.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Expressions&lt;/strong&gt;: Description of computations to be carried out.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; Today, we will examine the &lt;em&gt;expressions&lt;/em&gt; that support concurrent
programming.&lt;/p&gt;

&lt;h1 id=&#34;programming-paradigm&#34;&gt;Programming paradigm&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Imperative programming:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A programming paradigm that makes the distinction
between &lt;em&gt;statements&lt;/em&gt; and &lt;em&gt;expressions&lt;/em&gt;.  Statements modify the state of
its runtime environment, while expressions use certain existing values to
evaluate another value.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functional programming:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A programming paradigm that forbiddens modification of existing values.
All values are created once, and remain read-only.  Functions and data are
unified, known as &lt;em&gt;functions as data&lt;/em&gt;.  State of the runtime is modeled
not by data (in the sense of imperative programming), but rather one or
more functions.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Modern languages are designed with features supporting both paradigms.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; But what about &lt;em&gt;Object-oriented&lt;/em&gt; programming paradigm?&lt;/p&gt;

&lt;h1 id=&#34;concurrency&#34;&gt;Concurrency&lt;/h1&gt;

&lt;p&gt;First of all, &lt;em&gt;concurrency is not parallism&lt;/em&gt;.
&lt;a href=&#34;https://talks.golang.org/2012/waza.slide#1&#34;&gt;1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s the distinction?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Concurrency is about the &lt;em&gt;programming&lt;/em&gt; constructs that allow &lt;em&gt;programmers&lt;/em&gt; to
compose multiple interdependent (but non-sequential) units of computation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallelism is about &lt;em&gt;executing&lt;/em&gt; units of computation using multiple
interdependent processors.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Parallelism&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Multi-core&lt;/li&gt;
&lt;li&gt;Cluster&lt;/li&gt;
&lt;li&gt;The Internet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Concurrency&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Code constructs (threads, goroutines, channels, futures, promises, async,
scatter-gather, &amp;hellip;)&lt;/li&gt;
&lt;li&gt;Even single-core, one-process program can be &lt;em&gt;concurrent&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;concurrency-supset-parallelism&#34;&gt;Concurrency $\supset$ Parallelism&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrency is about &lt;em&gt;programming&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concurrency is about a way to &lt;em&gt;think&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concurrent programming is to adapt to the ever increasing parallel runtime
environments.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;                    +------------------------+
                    | Concurrent Programming |
                    +-----------+------------+
                                |
      +--------------+----------+-----+------------------+
      |              |                |                  |
      |              |                |                  |
+----------+    +----------+   +-------------+   +-----------------+
| IPHONE   |    | ANDROID  |   | Desktop     |   | Cluster         |
| 2 cores  |    | 4 cores  |   | 16-32 cores |   | ~500-1000 cores |
+----------+    +----------+   +-------------+   +-----------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;concurrent-programming&#34;&gt;Concurrent programming&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrent programming is not an extention of imperative programming.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java&amp;rsquo;s threading model is fundamentally prohibitive from a programmer&amp;rsquo;s
perspective.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-composition&#34;&gt;Computation &amp;amp; Composition&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Composition&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(x)
let z = h(y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let z = h(g(f(...)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;No concurrency.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Independent computation&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(...)
let z = h(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can evaluate &lt;code&gt;f, g&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; on separate processors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;spawn { x = f(...) }
spawn { y = g(...) }
spawn { z = h(...) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;_________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Partial composition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x = f(...)
let y = g(...)
let z = h(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can evaluate &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; on separate processors, and use the results to
evaluate &lt;code&gt;h&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x = result of spawn { f(...) }
y = result of spawn { g(...) }

wait-for-all(x, y) as (x, y) {
    z = h(x, y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;____________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Partial composition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(...)
let z = x or y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x = result of spawn { f(...) }
y = result of spawn { g(...) }

wait-for-any(x, y) as (u) {
    z = u
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Transaction&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions may &lt;em&gt;fail&lt;/em&gt; to complete, and result in error.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Transaction:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;snapshot()
h(g(f(...)))

if error:
  reverse back to snapshot()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;transaction {
    f()
    g()
    h()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;_______________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Data exchange&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Long running functions that require data from one another mutually
recursively.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;F() {
  get x from G
  send x&#39; back to G
  ...
}

G() {
  send x to F
  get x&#39; from F
  ...
}

spawn F()
spawn G()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We can have multi-way data exchange among multiple long running
functions.&lt;/p&gt;

&lt;h1 id=&#34;let-s-get-practical&#34;&gt;Let&amp;rsquo;s get &lt;em&gt;practical&lt;/em&gt; ✌&lt;/h1&gt;

&lt;p&gt;Multicore&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1) Go&lt;/p&gt;

&lt;p&gt;2) Clojure&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Hundreds of cores&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;3) RabbitMQ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;go-independent-computation&#34;&gt;Go: independent computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func is_prime(n int64) bool {
    for(i := 2; i &amp;lt; n; i++) {
        if n % i == 0 {
            return false
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compute the 1000th prime number.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func is_perfect(n int64) bool {
    var total int64 = 0
    for i := int64(1); i &amp;lt; n; i++ {
        if n % i == 0 {
            total += i
        }
    }
    return total == n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compute the 4th perfect number.&lt;/p&gt;

&lt;h1 id=&#34;toc_14&#34;&gt;__________________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func nth_prime(nth int) int64 {
    found := 0
    var n int64
    for n = 2; found &amp;lt; nth; i++ {
        if is_prime(n) {
            found += 1
        }
    }

    if found == nth {
        prime_1000 = n
    }
}

ans1 := nth_prime(1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do some refactoring so we can reuse the code for the 4th perfect number.&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;______________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func look_for(predicate func(int64) bool, nth int) {
    found := 0
    var n int64
    for n = 2; found &amp;lt; nth; i++ {
        if predicate(n) {
            found += 1
        }
    }
    if found == nth {
        return n
    } else {
        return 0
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;__________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var prime_1000 int
var perfect_4 int

go func() {
    prime_1000 = look_for(is_prime, 1000)
}()

go func() {
    perfect_4 = look_for(is_perfect, 4)
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-independent-computation&#34;&gt;Clojure: Independent computation&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn prime? [n]
  (every? #(not (zero? (mod n %1))) (range 2 n)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn perfect? [n]
  (let [factors (filter #(zero? (mod n %)) (range 1 n))]
    (= n (reduce + 0 factors))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn look-for [pred n]
  (nth (filter pred (iterate inc 2)) n))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_18&#34;&gt;_______________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def prime-1000 (future (look-for prime? 1000)))

(def perfect-4  (future (look-for perfect? 4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
&lt;code&gt;(future ...)&lt;/code&gt; evaluates the expression in the background.  When it&amp;rsquo;s complete,
the result is saved in the &lt;em&gt;reference&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;partial-composition&#34;&gt;Partial composition&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Problem to solve&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;Find the sum of the 1000-th prime and the 4th perfect number.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Solutions&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Goroutine &amp;amp; channels&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clojure futures and deref of futures&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;goroutine-and-channels&#34;&gt;Goroutine and channels&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;We have already seen goroutines:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;go f(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Channels are native type in Go.  You can send &lt;em&gt;anything&lt;/em&gt; over a channel.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var ch = make(chan int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Create a bi-directional channel for exchanging integers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var i int = &amp;lt;- ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Read an integer from the channel.  If nothing is in the channel, this
will block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;ch &amp;lt;- 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Writes an integer into the channel.&lt;/p&gt;

&lt;h1 id=&#34;toc_21&#34;&gt;______________________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm nu&#34;&gt;func computation() int64 {
    var ch chan int64 = make(chan int64)

    go func() {
        p := look_for(is_prime, 1000)
        ch &amp;lt;- p
    }()

    go func() {
        q := look_for(is_perfect, 4)
        ch &amp;lt;- q
    }()

    result := (&amp;lt;-ch) + (&amp;lt;-ch)
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Line 14. blocks until both prime/perfect numbers are computed.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-solution&#34;&gt;Clojure&amp;rsquo;s solution&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def prime-1000 (future (look-for prime? 1000)))
(def perfect-4  (future (look-for perfect? 4)))
(println (+ (deref prime-1000) (deref perfect-4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
&lt;code&gt;deref&lt;/code&gt; blocks until the result of the &lt;code&gt;future&lt;/code&gt;s are available, and returns the
result.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Here is a more functional style:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(let [a (future (look-for prime? 1000))
      b (future (look-for perfect? 4))
      result (+ @a @b)]
  (println result))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;partial-composition-1&#34;&gt;Partial composition&lt;/h1&gt;

&lt;p&gt;Now, let&amp;rsquo;s consider a different problem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute either the 1000th prime, or the 4th perfect number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The strategy is to concurrently evaluate both computations, and as soon as one
is done, return it.&lt;/p&gt;

&lt;h1 id=&#34;go-s-channel-selection&#34;&gt;Go&amp;rsquo;s channel selection&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;select {
case v1 = &amp;lt;- ch1:
    ...
case v2 = &amp;lt;- ch2:
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
This tries to read from &lt;code&gt;ch1&lt;/code&gt; or &lt;code&gt;ch2&lt;/code&gt;, and it guarantees to read only at most one of
them.  If both channels are empty, then &lt;code&gt;default&lt;/code&gt; case is evaluated.&lt;/p&gt;

&lt;h1 id=&#34;go-s-solution-using-select&#34;&gt;Go&amp;rsquo;s solution using &lt;code&gt;select&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func async_look_for(cond func(int64) bool, nth int) chan int64 {
    ch := make(chan int64)
    go func() {
        ch&amp;lt;- look_for(cond, nth)
    }()
    return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; Pretty cool.  Instead of returning the result, we wrap the result in a
channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func computation() int64 {
    result1 := async_look_for(is_prime, 1000)
    result2 := async_look_for(is_perfect, 4)

    var answer int64
    select {
    case answer = &amp;lt;-result1:
    case answer = &amp;lt;-result2:
    }
    return answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; The &lt;code&gt;select { ... }&lt;/code&gt; will block until the first prime/perfect number
is computed.&lt;/p&gt;

&lt;h1 id=&#34;go-s-solution-using-pure-channel-operations&#34;&gt;Go&amp;rsquo;s solution using pure channel operations&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func async_look_for(cond func(int64) bool, nth int, results chan int64) {
    ch := make(chan int64)
    go func() {
        results&amp;lt;- look_for(cond, nth)
    }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func computation() {
    results = chan int64

    async_look_for(is_prime, 1000, results)
    async_look_for(is_perfect, 4, results)

    answer := &amp;lt;-results
    close(results)
    return answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We pass a channel into &lt;code&gt;async_look_for&lt;/code&gt; to collect their results of
computation.  As soon as one result appears in the channel, we are done.&lt;/p&gt;

&lt;h1 id=&#34;conclusion-for-go&#34;&gt;Conclusion for Go:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Channels + Goroutines = Really powerful and universal solution&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is called the &lt;em&gt;Communicating Sequential Processes&lt;/em&gt; (CSP)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;clojure-s-csp&#34;&gt;Clojure&amp;rsquo;s CSP&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;(require &#39;[clojure.core.async :as async :refer :all])&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(go ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Starts a go-routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(chan)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Constructs a bi-directional channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(&amp;lt;! ch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Read one value from the channel.  It blocks in the go-routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(&amp;gt;! ch x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Writes one value into the channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(close! ch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Closes the channel.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-solution-using-alt&#34;&gt;Clojure&amp;rsquo;s solution - using alt!&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [[val ch] (alt! [ch1 ch2 ...])]
    ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;alt!&lt;/code&gt; blocks until one of the channels receives some value.
Returns the value and the channel it comes from.&lt;/p&gt;

&lt;p&gt;There are two version:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alt!&lt;/code&gt; is used in a go-routine.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt!!&lt;/code&gt; is used in the context of an actual thread.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_30&#34;&gt;___________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn async-look-for [pred n]
  (let [ch (chan)]
    (go (&amp;gt;! ch (look-for pred n)))
    ch))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn computation []
  (let [ch1 (async-look-for prime? 1000)
        ch2 (async-look-for perfect? 4)]
    (let [ans ch] (alt!! [ch1 ch2])
      ans)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-s-solution-using-pure-channel-operations&#34;&gt;Clojure&amp;rsquo;s solution - using pure channel operations&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn async-look-for [pred n results]
  (go (&amp;gt;! results (look-for pred n))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn computation []
  (let [ch (chan)]
    (future
      (do (async-look-for prime? 1000 ch)
          (async-look-for perfect? 4 ch)))
    (let [ans (&amp;lt;!! ch)]
      (close! ch)
      ans)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Clojure already had a rich set of concurrency constructs (2007-2015).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CSP is so successful as a model to express concurrency compositions that
Clojure added support for CSP, and it is the preferred way.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;scaling-to-multiple-machines&#34;&gt;Scaling to multiple machines&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s revisit CSP:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Go routines&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Channels&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We just need to implement go-routines and channels over the network.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;go-routines = processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;channels = message queues&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;introducing-rabbitmq&#34;&gt;Introducing RabbitMQ&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;rabbitmq.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Provides queueing service as a standalone server, or a server cluster.&lt;/p&gt;

&lt;h1 id=&#34;message-queues-are-channels-between-machines&#34;&gt;Message queues are channels between machines&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;rmq-example.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;discovering-primes&#34;&gt;Discovering primes&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn feed []
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;input-queue&amp;quot;]
    (doseq [i (iterate inc 0)]
      (publish ch queue i))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Places all numbers on the queue called &lt;em&gt;input-queue&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_37&#34;&gt;___________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def output
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;output-queue&amp;quot;]
    {:ch ch
     :queue queue}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Declare the queue that will gather the answers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn task []
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;input-queue&amp;quot;]
    (subscribe ch queue 
            (fn [i] (when (__prime__? i)
                      (publish output i))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Get a job, &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Performs the computation &lt;code&gt;(prime? i)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If we get a prime, send it to the output queue.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt; (defn worker []
  (dotimes [i 32] (future (task))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; start 32 concurrent sessions to do the tasks assuming we have 32 cores.&lt;/p&gt;

&lt;h1 id=&#34;toc_38&#34;&gt;_____________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## Start the job feeder
nohup clojure feed.clj &amp;amp;

## start the remote workers
for m in $machines
do
    ssh $m nohup clojure worker.clj
done

## Subscribe to output queue, and save to database
nohup clojure result-to-db.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;$machine&lt;/code&gt; may have 100 AWS instances = $32\times 100 = 3,200$ cores.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/insert-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/insert-sort/</guid>
      <description>

&lt;h1 id=&#34;basic-programming&#34;&gt;Basic programming&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We use &lt;em&gt;Python&lt;/em&gt; for this course.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Basic Python will do for the most part of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you are not used to Python (anymore), you are only &lt;em&gt;one&lt;/em&gt; day away
of catching up.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codecademy.com/learn/python&#34;&gt;https://www.codecademy.com/learn/python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;programming-this-course&#34;&gt;Programming &amp;amp; This Course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t need much programming for this course because we absolutely will be
focused on the &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But &amp;hellip;&lt;/p&gt;

&lt;p&gt;The reality is that &lt;em&gt;programming&lt;/em&gt; is absolutely essential.&lt;/p&gt;

&lt;h1 id=&#34;basic-programming-for-this-course&#34;&gt;Basic programming for this course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [1, 2, 3]

print &amp;quot;The middle number is %d&amp;quot; % x[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need arrays as a fundamental data structure.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student:
    name = &amp;quot;Unknown&amp;quot;
    age = 18

    def __init__(self, name):
        self.name = name

jack = Student(&amp;quot;Jack&amp;quot;)

print &amp;quot;%s: %s&amp;quot; % (jack.name, jack.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need objects.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;i = 0
while i &amp;lt; 10:
  print i
  i += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(10):
  print i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Various loops are needed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ==================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def reverse_string(s):
    reversed_s = &amp;quot;&amp;quot;
    for c in s:
      reversed_s += c
    return reversed_s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need functions, mostly to better organize the implementation of an algorithm.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ============&lt;/p&gt;

&lt;p&gt;We may need to rely on external Python libraries for data generation and visualization of algorithmic actions.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;random-graph.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import networkx as nx
import matplotlib.pyplot as plot

G = nx.erdos_renyi_graph(100, 0.015)
nx.draw(G)
plot.save(&amp;quot;random-graph.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-sorting-problem&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 9:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Input:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An array of elements: $x$
where the elements are to be compared by a &lt;em&gt;comparator&lt;/em&gt; function:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$f(x_1, x_2) \in \left[
\begin{array}{cc}
-1 &amp;amp; x_1 &amp;lt; x_2 \\
0 &amp;amp; x_1 = x_2 \\
1 &amp;amp; x_1 &amp;gt; x_2
\end{array}\right.$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Output:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A permutation $y$ of the array of $x$, such that&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\forall i,j\in[0, \mathrm{length}(y)],\quad i\leq j \implies y[i] \leq y[j]$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This is called &lt;em&gt;comparison based sorting&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The comparison function can be arbitrary, and it defines the ordering.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-sorting-problem-1&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Permutation $\pi : [0, n] \to [0, n]$ such that &lt;code&gt;$i\not= j\implies \pi(i)\not=\pi(j)$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a sorting problem $(x, f)$, there can be multiple non-unique permutations that sorts $x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [3, 2, 2, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;insertion-sort&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a highly &lt;em&gt;inefficient&lt;/em&gt; sorting algorithm.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s simple enough that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It&amp;rsquo;s intuitive.&lt;/li&gt;
&lt;li&gt;It can be fully analyzed relatively easily.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;insertion-sort-the-intuition&#34;&gt;Insertion sort: the intuition&lt;/h1&gt;

&lt;p&gt;Suppose you have an array such that the &lt;em&gt;initial&lt;/em&gt; subarray is already sorted.  But the last element may be out of place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x&#34;&gt;+---+---+---+----+---+
| 2 | 4 | 5 | 10 | x |
+---+---+---+----+---+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is a procedure to rearrange such array?  Imagine that &lt;code&gt;x=7&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;insertion-sort-1&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=cards.png width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Chapter 2, Figure 2.1 of textbook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python nu&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;try-it-out&#34;&gt;Try it out&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;import random
A = [random.randint(0, 100) for i in range(10)]
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;insertion_sort(A)
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/python&#39;
    
    style=&#39;max-width:100%;width:100%;height:500px&#39;&gt;&lt;/iframe&gt;



&lt;h1 id=&#34;analysis-of-correctness&#34;&gt;Analysis of correctness&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Intuition is not to be trusted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can formally prove that an algorithm is correct.
But first, we need some machinery.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;loop-invariance&#34;&gt;Loop invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consider a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;total = 0
count = 0

for v in array:
  total += v
  count += 1

avg = total / count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Precondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; *true at the start of
the loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Postcondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true at by the end of
the loop.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Loop invariance&lt;/strong&gt;:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true
&lt;span style=color:#44f;font-size:120%&gt;right at the end&lt;/span&gt;
of each iteration of
the loop.&lt;/p&gt;

&lt;p&gt;At the &lt;em&gt;end&lt;/em&gt; of the $i$-th iteration:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;$_i$ $\not=$ &lt;code&gt;0&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_{i+1} \geq$&lt;/code&gt; &lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_i$&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-down&#34;&gt;&lt;/i&gt;:
This is not a loop-invariance because it may not be true.
Consider if $v &amp;lt; 0$ for some iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are two loops, with &lt;code&gt;while&lt;/code&gt;-loop nested in the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-1&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Inner-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If we assume that $A[0 .. j-1]$ is sorted, then
the following loop invariance holds for the &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;

&lt;p&gt;At the end of the iteration, we have $A[i\dots j]$ is sorted.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;Can we say anything about &lt;code&gt;A[j+1]&lt;/code&gt; to &lt;code&gt;A[len(A)-1]&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-2&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outer-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The subarray &lt;code&gt;A[0 .. j]&lt;/code&gt; is sorted after the $j$-th iteration of the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;: We prove by induction on $j$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Base case&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$j=0$, trivially true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Induction&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;A[0 .. j-1]&lt;/code&gt; is sorted, by the inner-loop invariance, moving key to
&lt;code&gt;A[i+1]&lt;/code&gt; makes &lt;code&gt;A[0 .. j]&lt;/code&gt; sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-3&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Theorem&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;insertion_sort&lt;/code&gt; algorithm always correctly sorts the input array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By the outer-loop invariance, by the end of the last iteration,
with $j=$&lt;code&gt;len(A)-1&lt;/code&gt;, the entire array &lt;code&gt;A[0 .. len(A)-1]&lt;/code&gt; is sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h3 id=&#34;every-statement-takes-the-same-amount-of-time&#34;&gt;Every statement takes the same amount of time.&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not exactly correct, but it is accurate enough to gauge the
performance of algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;corollary&#34;&gt;&lt;em&gt;Corollary&lt;/em&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;We measure the number of lines executed by the program before an array is
completely sorted by &lt;code&gt;insertion_sort&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;$T_\mathrm{LOC}(\mathrm{length}(A)) \Rightarrow T(n)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Best case analysis&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Average case analysis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let $n = \mathrm{length}(A)$&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The outer-loop &lt;em&gt;always&lt;/em&gt; iterates $n$ times.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The inner loop iterates &lt;em&gt;in the worst case&lt;/em&gt; $j$ times.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;$$ T(n) \leq \sum_{j=0}^n j = \frac{n(n-1)}{2}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;insert_sort&lt;/code&gt; is a pretty inefficient algorithm.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;45 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4950&lt;/td&gt;
&lt;td&gt;5 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;499500&lt;/td&gt;
&lt;td&gt;0.5 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;499999500000&lt;/td&gt;
&lt;td&gt;5.9 days&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A more efficient algorithm (to be discussed later):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;23 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;460&lt;/td&gt;
&lt;td&gt;0.46 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;6907&lt;/td&gt;
&lt;td&gt;6.9 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;13815510&lt;/td&gt;
&lt;td&gt;13.8 $s$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;INSERTION sort&lt;/li&gt;
&lt;li&gt;Analysis of correctness by loop-invariance&lt;/li&gt;
&lt;li&gt;Performance analysis by counting lines executed&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Text: 2.1, 2.2,&lt;/p&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is INSERTION sort a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/merge-sort/</guid>
      <description>

&lt;h1 id=&#34;mergesort&#34;&gt;Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Divide and conquer, when and when not&amp;hellip;&lt;/li&gt;
&lt;li&gt;Bottom-up&lt;/li&gt;
&lt;li&gt;Top-down&lt;/li&gt;
&lt;li&gt;Correctness&lt;/li&gt;
&lt;li&gt;Complexity analysis&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;divide-and-conquer&#34;&gt;Divide and conquer&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a way to instruct &amp;ldquo;simple&amp;rdquo; solver to solve a complex problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;Minion.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;office-messy-desk.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;divide-and-conquer-and-combine&#34;&gt;Divide and conquer (and combine)&lt;/h1&gt;

&lt;p&gt;Divide:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a problem $P$, the division of a problem is a procedure
that produces a collection of &lt;em&gt;smaller&lt;/em&gt; problems &lt;code&gt;$\mathbf{Q} = \{Q_1, Q_2, \dots\}$&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each sub-problem &lt;code&gt;$Q_i\in\mathbf{Q}$&lt;/code&gt; (hopefully) is easier to solve.
Let &lt;code&gt;$S_i = \mathrm{solve}(Q_i)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hopefully, the solutions of subproblems, ${S_i}$, are not useless toward the
solution of $P$.&lt;/p&gt;

&lt;p&gt;We need a procedure to combine:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\mathrm{solve}(P) = \mathrm{combine}(S_1, S_2, S_3, \dots)$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;example-cleaning-a-mess&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;Minion.jpg&#34; style=&#34;float:left;width:80px;margin:0 20px 0px 0&#34;&gt;&lt;/img&gt;
Consider how you can instruct a minion to clean a messy office.  The minion
is overwhelmed by the mess of the entire office.  Divide and conquer is a great
way to solve the cleaning problem.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are some assumptions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The minion can clean up a very small section of an office - like a drawer, or
a book shelf.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If every section of an office is organized, we deem the whole office
organized.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;example-cleaning-a-mess-1&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide(Office) = &lt;code&gt;{Bookshelf, Desk, Floor, Cabinet, Drawer, $\dots$}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conquer: the minion can clean up each section&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine: Nothing needs to be done&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Divide &amp;amp; Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A list of numbers can be divided into smaller lists.
If a list is so small, we can sort it trivially.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How small does a list need to be for us to know how to sort it?&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-1&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we have two lists that are already sorted, can we figure out how to combine
them in a sorted way?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;+---+---+---+---+
| 1 | 5 | 6 | 8 |          \
+---+---+---+---+          |
                           |
                           +------&amp;gt;  combined sorted list
                           |
+---+---+---+---+----+     |
| 3 | 4 | 5 | 8 | 10 |     /
+---+---+---+---+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-2&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 10:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def merge(list1, list2):
    i, j = 0, 0
    list3 = []

    while i &amp;lt; len(list1) and j &amp;lt; len(list2):
        if list1[i] &amp;lt;= list2[j]:
            list3.append(list1[i])
            i += 1
        else:
            list3.append(list2[j])
            j += 1

    if i &amp;lt; len(list1): list3.extend(list1[i:])

    if j &amp;lt; len(list2): list3.extend(list2[j:])

    return list3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We want to be able to merge to sorted list into a larger list.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=merge.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;bottom-up-mergesort-1&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;We start with a list of arbitrary lenght $n$.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Observe that &lt;em&gt;all&lt;/em&gt; sublist of length 1 is already sorted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 4, 8, 16, &amp;hellip;
until the whole list is sorted.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bottom-up-mergesort-2&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bottom-up-mergesort-3&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=mergesort.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort-4&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A hierarchy of subproblems&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Small subproblems: sublist of length 1&lt;/p&gt;

&lt;p&gt;Larger subproblems: sublist of length 2, 4, &amp;hellip;&lt;/p&gt;

&lt;p&gt;The largest subproblem: the whole list&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Why is it called &lt;em&gt;bottom-up&lt;/em&gt;?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The procedure, &lt;code&gt;mergesort()&lt;/code&gt;, recognizes the smallest subproblems &lt;em&gt;first&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;divide&lt;/strong&gt; stage starts at the bottom of the hierarchy.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;conquer&lt;/strong&gt; stage &lt;em&gt;always&lt;/em&gt; starts with the bottom of the hierarchy.&lt;/p&gt;

&lt;h1 id=&#34;analysis-correctness&#34;&gt;Analysis: correctness&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop-invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At the end of each loop,&lt;/p&gt;

&lt;p&gt;for all $L[i\Delta \dots (i+1)\Delta]$ is sorted for all $i$,
where $\Delta$ is the sortedness at the end of the iteration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Overall correctness&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The loop terminates when $\Delta$ exceeds the length of the list, so the
entire list is sorted by the loop invariance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Guaranteed termination&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration strictly increases the sortedness $\Delta$ (by doubling it).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;analysis-performance&#34;&gt;Analysis: performance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How many iterations if there are $n$ elements in the list?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration grows the &lt;em&gt;sortedness&lt;/em&gt; by a factor of 2 up to $n$.
So, we need $\log_2(n)$ iterations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How many instructions does each iteration take?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration has four steps.  Each step requires no more than a linear scan
of the list.
We can guarantee that number of instructions do not exceed: $k\cdot n$ for some
constant $k$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Putting it together:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mergesort()&lt;/code&gt; requires no more than $k\cdot n\log(n)$ number of instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;top-down-mergesort-1&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Revisit the hierarchy of subproblems of sorting a list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can specify the &lt;em&gt;Divide-and-conquer&lt;/em&gt; top-down:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Divide sorting of $L$ to the first sublist $L[0 \dots \frac{n}{2}]$
and the second sublist $L[\frac{n}{2} \dots n]$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the sub-lists are not easy enough, then break down again.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Recursion&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;correctness&#34;&gt;Correctness:&lt;/h2&gt;

&lt;p&gt;Induction on depth of recursion.&lt;/p&gt;

&lt;p&gt;Base case: depth = 0&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If there is no recursion, than the list $L$ is such that $|L|\leq 1$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Inductive case: depth = $k$, and assume that all mergesort at level $&amp;lt; k$ are
correct.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Let $L_1$ and $L_2$ be the two sublists.  The invocations &lt;code&gt;mergesort($L_i$)&lt;/code&gt;
use $&amp;lt; k$ recursions, and thus, are &lt;em&gt;correct&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since $L_1$ and $L_2$ are properly sorted, and that &lt;code&gt;merge()&lt;/code&gt; is correct,
we conclude that &lt;code&gt;mergesort(L)&lt;/code&gt; is correct.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis-1&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Let $n = |L|$.  How much time does it take to complete top-down
&lt;code&gt;mergesort($L$)&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Let $T(n)$ = time of &lt;code&gt;mergesort($L$)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray*}
T(n) &amp;amp;\simeq&amp;amp; T(n/2) + T(n/2) + n \\
  &amp;amp;=&amp;amp; 2 T(n/2) + n
\end{eqnarray*}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will develop an array of techniques to solve &lt;em&gt;recurrence equations&lt;/em&gt; to
analyze recursive algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Spoiler Alert:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$ T(n) = n\log(n) + n $$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bottom-up mergesort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Top-down mergesort&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;MERGESORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/optimal-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/optimal-sorting/</guid>
      <description>

&lt;h1 id=&#34;optimal-comparison-based-sorting-br-v-s-br-numerical-sorting&#34;&gt;Optimal Comparison Based Sorting &lt;br&gt; v.s. &lt;br&gt;  Numerical Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Assumption&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elements in the array are &lt;em&gt;black boxes&lt;/em&gt;, and only comparison can be made between two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;The decision-tree model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a sorting algorithm $A$, we record &lt;em&gt;all&lt;/em&gt; possible comparison operations executed in $A$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; A comparison operation: $(i,j)$ where $i, j$ are the &lt;em&gt;original&lt;/em&gt; index of the elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The leaf records the final ordering of the original index.&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-1&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How many comparison operations did $A$ take as illustrated in the diagram?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the worst case number of comparision operations?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-2&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What type of tree is the deicion tree?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Binary tree&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How many leaf nodes are there for $n$ elements?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All possible permutations of $[1, 2, 3, \dots n] = n!$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the height of the tree if there are $n!$ leaf nodes?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\log_2(n!) \approx c\cdot n\log(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Any comparision based sorting algorithm will necessarily take at least $c n\log(n)$ number of comparison operations in the &lt;em&gt;worst&lt;/em&gt; case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Optimal sorting&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a comparison based sorting algorithm always makes at most $c n\log(n)$ number of comparisons, then it&amp;rsquo;s called &lt;em&gt;optimal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting-1&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Algorithm&lt;/th&gt;
&lt;th&gt;Optimal?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Insertion sort&lt;/td&gt;
&lt;td&gt;No, $n^2$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Mergesort&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Quicksort&lt;/td&gt;
&lt;td&gt;No, $n^2$ in the worst case&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sorting-integers&#34;&gt;Sorting Integers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If an array contains (bounded) integers, we can beat optimal comparison based sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Elements are not blackboxes.  We can look at individual digits of an bounded integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;Assumptions:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The elements are integers.&lt;/li&gt;
&lt;li&gt;The elements are all in the range of $[0, k-1]$ for some $k \geq 0$.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Amazing fact:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;With $n$ elements, we can do it with only $2\cdot(n+k)$ number of instructions,
compare to $n\log(n)$ in the case of optimal comparison sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort-1&#34;&gt;Counting sort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def empty_array(size, init=None):
    return [init for i in range(size)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; allocate an empty array with an optional initial value.&lt;/p&gt;

&lt;h1 id=&#34;counting-sort-2&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def COUNTING_SORT(A):
    n = len(A)
    k = max(A) + 1
    B = empty_array(size=n)
    C = empty_array(size=k, init=0)

    for a in A:
        C[a] = C[a] + 1

    for i in range(1,k):
        C[i] = C[i] + C[i-1]

    for a in reversed(A):
        B[C[a]-1] = a
        C[a] = C[a] - 1

    return B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;We compute the frequency of each distinct value in &lt;code&gt;A&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The frequence is then turned into cummulative frequency.  Namely:
&lt;code&gt;$C[x] = |\{y\in A: y\leq x\}|$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;With $C$, we can quickly deduce which each element should be positioned.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;counting-sort-3&#34;&gt;Counting Sort&lt;/h1&gt;

&lt;p&gt;Question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is &lt;code&gt;COUNTING_SORT&lt;/code&gt; stable?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Answer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s crucial to place $x$ into &lt;code&gt;B&lt;/code&gt; from &lt;code&gt;reverse(A)&lt;/code&gt; instead of &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The best comparison sorting algorithms are in the order of $n\log(n)$.&lt;/li&gt;
&lt;li&gt;The best integer comparison algorithms can achieve the efficiency in the order of $n$.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COUNTING_SORT&lt;/code&gt; requires too much memory in practice to be applied to arrays with large integer values.  However, it will be instrumental later (as part of radix sort).&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;The measure of algorithmic efficiency will be made much more rigorous in the next section of this course.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/quicksort/</guid>
      <description>

&lt;h1 id=&#34;quicksort&#34;&gt;Quicksort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;quicksort-1&#34;&gt;Quicksort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a list $L$, we divide the sorting problem into two sub-problems.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Sort the elements in $L$ smaller than $x$: $L_1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sort the elements in $L$ larger than $x$: $L_2$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\mathrm{sorted}(L) = \mathrm{sorted}(L_1) \oplus \{x\} \oplus \mathrm{sorted}(L_2)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;partition&#34;&gt;Partition&lt;/h1&gt;

&lt;p&gt;Given a list &lt;code&gt;$L$&lt;/code&gt; and an element $x$ in $L$, &lt;em&gt;partitioning&lt;/em&gt; $L[p \dots r]$ by the &lt;em&gt;pivot&lt;/em&gt;
element $x$ does the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rearrange the elements in $L[p\dots r]$ so that there exists a position $q$
such that &lt;em&gt;after&lt;/em&gt; rearrangment:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$L[q] = x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [p, q-1],\ L[i] \leq x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [q+1, r],\ L[i] \geq x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-1-simple-but-takes-more-memory&#34;&gt;Version 0.1: simple, but takes more memory&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement &lt;code&gt;partition(L, p, r)&lt;/code&gt; with the minimal effort:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pick $x = L[r]$&lt;/li&gt;
&lt;li&gt;Filter the list for smaller elements: &lt;code&gt;$L_1 = \{y\in L[p\dots r-1]: y\leq x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Filter the list for larger elements: &lt;code&gt;$L_2 = \{y\in L[p\dots r-1]: y &amp;gt; x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reconstruct: &lt;code&gt;$L[p \dots r] = L_1 \oplus \{x\} \oplus L_2$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def partition(L, p, r):
    x = L[r]
    L1 = [y for y in L[p:r] if y &amp;lt;= x]
    L2 = [y for y in L[p:r] if y &amp;gt; x]
    L[p:r+1] = L1 + [x] + L2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-2-more-involved-but-takes-no-additional-memory&#34;&gt;Version 0.2: more involved, but takes no additional memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It only involves element swapping, so it requires &lt;em&gt;zero&lt;/em&gt; additional memory.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;But its correctness is much less obvious.&lt;/p&gt;

&lt;h1 id=&#34;analysis-of-partition&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bookkeeping is the key:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;$p$ and $r$ are the boundaries of the sublist to be partitioned.&lt;/li&gt;
&lt;li&gt;$r$ also holds the value of the pivot element.&lt;/li&gt;
&lt;li&gt;Elements in $[p\dots j]$ are processed.&lt;/li&gt;
&lt;li&gt;$i$ is a marker of the boundary between smaller and larger elements.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;analysis-of-partition-1&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;After each iteration, $L[p, j]$ is properly partitioned:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$L[p, i] \leq x$&lt;/li&gt;
&lt;li&gt;$L[i+1, j] &amp;gt; x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;quicksort-2&#34;&gt;Quicksort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def quicksort(L, p, r):
    if p &amp;lt; r:
        k = partition(L, p, r)
        quicksort(L, p, k-1)
        quicksort(L, k+1, r)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will only give a terse outline of the analysis.  The full version is deferred to later lectures.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-1&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;Let there be $n$ elements in the array.&lt;/p&gt;

&lt;p&gt;Key obsevation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;partition(L, p, r)&lt;/code&gt; takes $(r - p)$ iterations.  Each iteration has a fixed number of instructions.  So, $T_\mathrm{partition} = c_1 (r-p) \leq c\cdot n$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At each &lt;em&gt;invocation&lt;/em&gt; of &lt;code&gt;quicksort(L, p, k-1)&lt;/code&gt; and &lt;code&gt;quicksort(L, k+1, r)&lt;/code&gt;, we need to determine the number of elements: $k-1-p$, and $r-k-1$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;performance-analysis-worst-case&#34;&gt;Performance Analysis: Worst-case&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The worst case for $T_\mathrm{partition} = n$&lt;/li&gt;
&lt;li&gt;The worst case for $k-1-p = n-1$&lt;/li&gt;
&lt;li&gt;The worst case for $r-k-1 = n-1$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We have enough to set-up an equation to estimate the number of instructions of &lt;code&gt;quicksort(L, a, b)&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Let $|L[a\dots b]| = n$.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n-1)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This leads to a (poor) performance characteristics of: $\approx n^2$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will show how to solve such equations (known as recurrence equations) in the next section of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-average-case&#34;&gt;Performance Analysis: average case&lt;/h1&gt;

&lt;p&gt;Quicksort as the name suggests is actually quite quick (most of the time&amp;hellip;)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting &lt;code&gt;k = partition(L, p, q)&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The pivot value should be somewhere in the middle of the subarray.
Namely: $k\approx p+q/2$, and so $k-1-p \approx n/2$, and $q-k-1\approx n/2$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting the recurrence equation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n/2)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;This leads to a satisfying performance characteristics of: $\approx n\log(n)$&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Partition: a simple version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partition: a zero-memory version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quicksort: a recursive sorting algorithm&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;QUICKSORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/functional-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/functional-computation/</guid>
      <description>

&lt;h1 id=&#34;lambda-calculus-symbolic-computation&#34;&gt;$\lambda$-Calculus: symbolic computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lambda-calculus&#34;&gt;$\lambda$-Calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Proposed by Alonzo Church in ~1930.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;intented to formalize mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Syntactic expressions that represent &lt;em&gt;functions&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;designed to represent the entire foundation of mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rules of rewriting the syntactic expression&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;rewrite rules represent mathematical reasoning.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;expressions&#34;&gt;Expressions&lt;/h1&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Literals: 1, 2, 3, &amp;ldquo;Hello world&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Variables: $x, y, z, \dots$&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Functions&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$+ : (x,y)\mapsto x+y$&lt;/li&gt;
&lt;li&gt;$\mathrm{inc} : x\mapsto x+1$&lt;/li&gt;
&lt;li&gt;$\dots$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Always returns &lt;em&gt;one&lt;/em&gt; value.&lt;/li&gt;
&lt;li&gt;Takes a fixed number of inputs: arity of the function
&lt;span style=color:red&gt;*&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;value-as-function&#34;&gt;Value as function&lt;/h1&gt;

&lt;p&gt;A value is a zero-arity function.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;function-as-value&#34;&gt;Function as value&lt;/h1&gt;

&lt;p&gt;We want to extend the idea of &lt;em&gt;things&lt;/em&gt; to include functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;This is a central idea in functional programming&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;value-equiv-function-everything&#34;&gt;Value $\equiv$ Function = Everything&lt;/h2&gt;

&lt;h1 id=&#34;syntax-for-expressions-value-function&#34;&gt;Syntax for expressions (value / function)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$x, y, z, \dots$ are expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Abstraction:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $x$ is a variable, and $e$ is an expression, then
$\lambda x. e$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $e_1$ is a function with arity 1,
&lt;code&gt;$e_2$&lt;/code&gt; is an expression, then
$e_1 e_2$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We assume that all functions are with arity 1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not a restriction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;the-weird-syntax-of-lambda-calculus&#34;&gt;The &lt;em&gt;weird&lt;/em&gt; syntax of $\lambda$ calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\lambda x.e$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a function taking &lt;em&gt;one&lt;/em&gt; input, represented by the variable $x$.
It returns &lt;em&gt;one&lt;/em&gt; value, which is evaluated as the expression $e$.
The expression $e$ usually makes uses of $x$, but not necessarily.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is passing $e_2$ as an argument to the expression $e_1$.  Recall that
everything is a function.  So $e_1$ is a function with &lt;em&gt;one&lt;/em&gt; argument.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2 e_3 = ((e_1 e_2) e_3)$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This shows that $e_1$ takes one argument ($e_2$), and returns an
expression which is yet again a function which takes $e_3$ as an input.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;defining-things&#34;&gt;Defining things&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identity function&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\lambda x.x$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions with multiple arity&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose we have a function $f(x,y,z) = e$ where the expression
involves all three input variables $x, y, z$.&lt;/p&gt;

&lt;p&gt;We can use the following expression to build $f$:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$\lambda x.(\lambda y.(\lambda z. e))$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;This is a big deal.&lt;/strong&gt; &lt;br&gt;
&lt;strong&gt;Functions as values in action here.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:220px&gt;&lt;/div&gt;

&lt;p&gt;We can write it conveniently as $\lambda xyz.e$&lt;/p&gt;

&lt;h1 id=&#34;computing-with-lambda-calculus&#34;&gt;Computing with $\lambda$-Calculus&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We rely on string-rewriting to evaluate
LC expressions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;substitution-of-variables-in-function-applications&#34;&gt;Substitution of variables in function applications&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Notation&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$e[x/e&amp;rsquo;]$ is the expression obtained by substituting all occurances of $x$ in
the expression $e$ with the expression $e&amp;rsquo;$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Substition&lt;/strong&gt; as a way to evaluate function application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$(\lambda x. e) e&amp;rsquo; \implies e[x/e&amp;rsquo;]$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
&amp;amp;&amp;amp; (\lambda x.x x) (\lambda y. y) \\
&amp;amp;\implies&amp;amp; (x x)[x/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)(\lambda y.y) \\
&amp;amp;\implies&amp;amp; y[y/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We can easily get into trouble.&lt;/p&gt;

&lt;p&gt;Substitution cannot be used freely.&lt;/p&gt;

&lt;h1 id=&#34;free-bound-variables&#34;&gt;Free &amp;amp; Bound Variables&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Variables in a function abstraction expression can be &lt;em&gt;free&lt;/em&gt; or &lt;em&gt;bound&lt;/em&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a variable represents the input parameter in a function expression, then
it&amp;rsquo;s considered &lt;em&gt;bound&lt;/em&gt;.  Otherwise, it&amp;rsquo;s &lt;em&gt;free&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;$\mathbf{FV}(e)$ are the free variables of $e$&lt;/li&gt;
&lt;li&gt;$\mathbf{BV}(e)$ are the bound variables&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;variable-capturing&#34;&gt;Variable Capturing&lt;/h1&gt;

&lt;p&gt;Consider an expression:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;There are multiple occurrences of $x$, so let&amp;rsquo;s label them so we can refer to
the individual occurrences.&lt;/p&gt;

&lt;p&gt;$$\lambda x_1. (\lambda x_2.x_3)$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Which input variable does $x_3$ refer to?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is called capturing.&lt;/p&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;There is a rewrite rule that allows us to rename the parameter variables without
changing the meaning of the expression.&lt;/p&gt;

&lt;p&gt;$$ \lambda x. x \equiv \lambda y.y \equiv \lambda \mathsf{hello}.\mathsf{hello} $$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Renaming&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose that $x$ is a free variable of $e$, and $y$ does not appear in $e$ at
all.&lt;/p&gt;

&lt;p&gt;Then $\lambda x.e \implies \lambda y.e[x/y]$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing-1&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;Back to:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;First we consider the sub expression $\lambda x.x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using renaming, we can rewrite it to $\lambda y.y$.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then we get:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$\lambda x. (\lambda x.x) \implies \lambda x.\lambda y. y$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt;
Generally, we only apply &lt;strong&gt;substitution&lt;/strong&gt; to evaluate function applications
if there is &lt;em&gt;no&lt;/em&gt; variable capturing; and this can be achieved by &lt;strong&gt;renaming&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;how-to-perform-computation-using-lc&#34;&gt;How to perform computation using LC?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Natural numbers&lt;/li&gt;
&lt;li&gt;Arithmetics&lt;/li&gt;
&lt;li&gt;Loop and conditional branching&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;All can be done using LC&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Express the algorithm in terms of natural numbers, arithmetics,
 loops and conditional branches.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Encode the algorithm in LC.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Apply syntax rewriting until no more rewriting is possible.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;a-glance-of-lc-in-action&#34;&gt;A glance of LC in action&lt;/h1&gt;

&lt;p&gt;A bit of notation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\lambda x.\lambda y. \lambda z. e$ is written as as $\lambda xyz. e$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Now we can encode numbers:&lt;/p&gt;

&lt;p&gt;$0 \equiv \lambda sx. x$ (takes two inputs, but only keep the second one.)&lt;/p&gt;

&lt;p&gt;$1 \equiv \lambda sx. sx$&lt;/p&gt;

&lt;p&gt;$2 \equiv \lambda sx. ssx$&lt;/p&gt;

&lt;p&gt;$\vdots$&lt;/p&gt;

&lt;h1 id=&#34;arithmetics&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;Consider the simplest arithmetics: increment by 1.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def succ(n):
    return n + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$S \equiv \lambda n. \lambda yx.y(nyx)$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let&amp;rsquo;s try this out.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
S 0 &amp;amp;=&amp;amp; (\lambda n. \lambda yx.ynyx)0 \\
    &amp;amp;=&amp;amp; (\lambda yx.ynyx)[n/0] \\
    &amp;amp;=&amp;amp; \lambda yx.y(0yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y((\lambda sz.z)yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y(x) \\
    &amp;amp;=&amp;amp; 1
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;arithmetics-1&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(n1, n2):
    return n1 + n2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Observe:&lt;/p&gt;

&lt;p&gt;$2 S 3 = 5$ (work it out, it&amp;rsquo;s quite incredible.)&lt;/p&gt;

&lt;p&gt;So, we have:&lt;/p&gt;

&lt;p&gt;$$+ \equiv \lambda mn. mSn$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Can you guess the LC expression for multiplication?&lt;/p&gt;

&lt;h1 id=&#34;recursion&#34;&gt;Recursion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LC does not require assigning aliases to functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Technically, there is just &lt;strong&gt;ONE&lt;/strong&gt; expression for the entire algorthm.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why it&amp;rsquo;s hard to do recursion without aliases?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def factorial(n):
    if n &amp;lt;= 1:
        return n
    else:
        return n * factorial(n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Is it even possible?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s called the &lt;strong&gt;Y&lt;/strong&gt;-combinator.&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} \equiv (\lambda y.(\lambda x.y(xx))(\lambda x.y(xx)))$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;y-combinator&#34;&gt;Y-combinator&lt;/h1&gt;

&lt;p&gt;$$ \mathbf{Y} f = f (\mathbf{Y} f) $$&lt;/p&gt;

&lt;p&gt;So,&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} f x \implies f (\mathbf{Y} f) x \implies f f \dots f x $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; $\mathbf{Y} f$ is a &lt;em&gt;fixed point&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;using-y-combinator-to-implement-factorial&#34;&gt;Using Y-combinator to implement factorial&lt;/h1&gt;

&lt;p&gt;Consider a function $F$ as:&lt;/p&gt;

&lt;p&gt;$$\lambda fx. (\mathrm{ifzero}\ x)\ 1\ (*\ x\ (f\ (\mathrm{dec}\ x)))$$&lt;/p&gt;

&lt;p&gt;If we apply the Y-combinator to $F$, we get:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = F (\mathbf{Y} F) n $$&lt;/p&gt;

&lt;p&gt;You can check the following:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = (\mathrm{ifzero}\ n)\ 1\ (*\ n\ ((\mathbf{Y} F)\ (\mathrm{dec}\ n))) $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is really quite amazing.  We have achieved Turing-completeness via recursion.  The amazing part is that we don&amp;rsquo;t need variables to refer to any values.  So $F$ is just for convenience and readability.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LC is purely symbolic.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It carries out computation by very simple string rewrites:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Function application&lt;/li&gt;
&lt;li&gt;Variable renaming&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It solves problem by:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Encode the problem as a single (huge) string of LC expression.&lt;/li&gt;
&lt;li&gt;Using the rules to rewrite the string to a &lt;em&gt;normal&lt;/em&gt; form.&lt;/li&gt;
&lt;li&gt;The resulting LC expression is the answer.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No variables are needed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/old/intro-to-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/old/intro-to-languages/</guid>
      <description>

&lt;h1 id=&#34;computation-in-practice&#34;&gt;Computation in practice&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Languages based on stateful computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages based on functional computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid languages&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;stateful-computation&#34;&gt;Stateful computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Languages&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Javascript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Task&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Quicksort&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;X = [6, 3, 4, 8, 1, 4]

def quicksort(X, i, j):
  if i &amp;lt; j:
    p = partition(X, i, j)
    quicksort(X, i, p-1)
    quicksort(X, p+1, j)

def partition(X, i, j):
  pivot = X[j]
  m = i
  for n in range(i, j):
    if X[n] &amp;lt;= pivot:
      X[m], X[n] = X[n], X[m]
      m += 1
  X[m], X[j] = X[j], X[m]
  return m

def QuickSort(X):
  return quicksort(X, 0, len(X)-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;breakdown-of-python&#34;&gt;Breakdown of python&lt;/h1&gt;

&lt;div pdf=&#34;qsort-py.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;python-v-s-javascript&#34;&gt;Python v.s. Javascript&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.py&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:600px;overflow:auto&gt;
&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.js&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/stateful-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/stateful-computation/</guid>
      <description>

&lt;h1 id=&#34;computation-the-turing-machine&#34;&gt;Computation &amp;amp; the Turing Machine&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;computation&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;david-hilbert.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hilbert&amp;rsquo;s Ten&amp;rsquo;s problem, 1900&lt;/li&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-1&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;kurt-godel.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Gödel&amp;rsquo;s incompleteness theorem&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-2&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alan-turing.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Turing machine&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-3&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alonzo-church.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;$\lambda$-calculus&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-4&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;john-von-neumann.jpg&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;von Neumann computing model&lt;/li&gt;
&lt;li&gt;EDVAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;turing-machine&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A completely mechanical device (1928)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;envisioned by Alan Turing as an intuitive formalism to
describe the non-existing phenomenon of machine driven
reasoning, now known as &lt;em&gt;computation&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Realized into an actual design (1945)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;John von Neumann designed an electronic version to simulate
the mechanical definition of a TM in a document known as &lt;em&gt;First Draft of a
Report on the EDVAC&lt;/em&gt;, 1945.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Turing-complete&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TM is the most powerful computing model we know.
Up to now, we don&amp;rsquo;t know any other computing models more powerful than
a TM.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;turing-machine-1&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;div pdf=&#34;turing-machine.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;computational-power-of-tm&#34;&gt;Computational power of TM&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Church-Turing Thesis&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a procedure (algorithm) can be executed by &lt;em&gt;any&lt;/em&gt; computer, then it can be
executed by a Turing Machine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Turing Complete&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a mechanism is equivalent to TM, then it&amp;rsquo;s called &lt;em&gt;Turing Complete&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;simulation-of-a-function&#34;&gt;Simulation of a function&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Computable functions&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A function $f$ is computable if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Its input can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its output can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its evaluation can always be carried out by a TM.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Any computable function can be implemented by a TM.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any TM is some computable function.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Why is a TM always a function (over binary strings)?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;universal-tm&#34;&gt;Universal TM&lt;/h1&gt;

&lt;p&gt;Consider a TM: $M$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s a function &lt;code&gt;$M:2^*\to 2^*$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s mechanical description can be encoded as a binary string.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Function &lt;em&gt;eval&lt;/em&gt; takes two inputs - a TM and an input, and it computes the
output.&lt;/p&gt;

&lt;p&gt;$$\mathrm{eval} :\mathrm{TM} \times 2^* \to 2^*$$&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s input can be encoded as binary strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can be carried out by a procedure.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By Church-Turing thesis, &lt;strong&gt;eval&lt;/strong&gt; is computable, so there is a TM for it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Definition&lt;/em&gt; &lt;strong&gt;Universal TM&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The TM $\mathbf{U}$ that computes &lt;strong&gt;eval&lt;/strong&gt; is called &lt;em&gt;universal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;universal-tm-1&#34;&gt;Universal TM&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The TM $\mathbf{U}$ initializes the tape with the binary encoding of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a TM, $M$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;an input, $x$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It outputs $\mathbf{eval}(M, x)$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Modern Computer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$M$ is the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$x$ is the input to the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\mathbf{U}$ is the general purpose computer&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tm-programming&#34;&gt;TM-Programming&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We just need a single TM, namely $\mathbf{U}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The universal programming language is the encoding of $M$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Turing Machine is a mechanically realizable device.&lt;/li&gt;
&lt;li&gt;TM is as powerful (but a lot slower) as any modern computers.&lt;/li&gt;
&lt;li&gt;There is a very special TM that is called the &lt;em&gt;Universal TM&lt;/em&gt;.  It can be
&lt;em&gt;programmed&lt;/em&gt;!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms</title>
      <link>http://db.science.uoit.ca/courses/algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/</guid>
      <description>&lt;div class=&#34;jumbotron&#34;&gt;
	&lt;h1&gt;Design &amp; Analysis of Algorithms&lt;/h1&gt;
&lt;/div&gt;

&lt;div class=row&gt;
	&lt;div class=col-md-3&gt;
		&lt;img src=&#34;textbook.jpg&#34; width=100%&gt;&lt;/img&gt;
		&lt;figcaption&gt; Introduction to Algorithms, Third Edition, &lt;i&gt;Coremen, Leiserson, Rivest and Stein&lt;/i&gt; &lt;/figcaption&gt;
	    &lt;p style=margin-top:10px;font-style:italic;font-size:90%&gt;
			This course is about problem solving and computation via algorithms.
			We will cover a number of known algorithms (sorting, hashing, search,
			indexing) and their applications.  We will discuss methods for analyzing
			existing algorithms and designing new algorithms.
			Finally, the students will be introduced to &lt;i&gt;complexity classes&lt;/i&gt;, in
			particular the class of &lt;i&gt;NP-completeness&lt;/i&gt;.
		&lt;/p&gt;
	&lt;/div&gt;
	&lt;div class=col-md-9&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Sorting&lt;/h1&gt;
				&lt;p&gt; Chapter 2.1, 2.3, 6, 7, 8&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;insert-sort&#34;&gt;Insertion sort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;merge-sort&#34;&gt;Mergesort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;quicksort&#34;&gt;Quicksort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;optimal-sorting&#34;&gt;
							Comparision based sorting versus numeric sorting
						&lt;/a&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;sorting-numbers&#34;&gt;Sorting integers&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Analysis of Complexity&lt;/h1&gt;
				&lt;p&gt; Chapter 3, 4, 5&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;big-o&#34;&gt;Asymptotic notations&lt;/a&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;recurrence-equation&#34;&gt;Recurrence equations&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;!--
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;&#34;&gt;Probabilistic analysis of randomized algorithms&lt;/a&gt;
						&lt;span style=&#34;float:right&#34; class=&#34;label label-warning&#34;&gt;DRAFT&lt;/span&gt;
                    &lt;/li&gt;
                    --&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Data structures&lt;/h1&gt;
				&lt;p&gt;Chapter 11&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
                    &lt;!--
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Elementary data structures&lt;/a&gt;&lt;/li&gt;
                    --&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;hash-table&#34;&gt;Hash tables&lt;/a&gt;
                    &lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
        &lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Graphs&lt;/h1&gt;
				&lt;p&gt;Chapter 22&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;graph-algorithms&#34;&gt;Graph Algorithms&lt;/a&gt;
                    &lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;mst&#34;&gt;Spanning trees&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;shortest-path&#34;&gt;Shortest path algorithms&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Optimization&lt;/h1&gt;
				&lt;p&gt;Chapter 15, 16&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;dynamic-programming&#34;&gt;Dynamic programming&lt;/a&gt;&lt;/li&gt;
                    &lt;li class=list-group-item&gt;
                        &lt;a href=&#34;greedy-algorithms&#34;&gt;Greedy algorithms&lt;/a&gt;
                    &lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Complexity &amp; Tractability&lt;/h1&gt;
				&lt;p&gt;Chapter 34&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
                    &lt;li class=list-group-item&gt;
                        &lt;a href=&#34;np-complete&#34;&gt;Decision problems &amp; NP-completeness&lt;/a&gt;
                    &lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

	&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt; a[href=&#34;&#34;] {color: #888;} &lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Asymptotic notation</title>
      <link>http://db.science.uoit.ca/courses/algorithms/big-o/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/big-o/</guid>
      <description>

&lt;h1 id=&#34;complexity-classes&#34;&gt;Complexity classes&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Asymptotic notations and complexity classes&lt;/li&gt;
&lt;li&gt;Intuition&lt;/li&gt;
&lt;li&gt;Properties&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;asymptotic-notation&#34;&gt;Asymptotic notation&lt;/h1&gt;

&lt;p&gt;We will develop a way to measure the efficiency of algorithms which is &lt;em&gt;invariant&lt;/em&gt; to the non-essential issues such as the speed of computer hardware and the effiency of the programming language used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The measurement functions is only sensitive to the &lt;em&gt;growth&lt;/em&gt; of the time it takes for an algorithm to complete with respect to the size of the input.&lt;/p&gt;

&lt;h1 id=&#34;measure&#34;&gt;Measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The size of the input is an integer $n$&lt;/li&gt;
&lt;li&gt;We use functions over integers to measure the efficiency of an algorithm.&lt;/li&gt;
&lt;li&gt;$f(n)$ is the &lt;strong&gt;time&lt;/strong&gt; it takes to process input of size $n$ in the &lt;em&gt;worst case&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;$f$ is monotonic: if $m \leq n$, then $f(m)\leq f(n)$.&lt;/li&gt;
&lt;li&gt;$f$ is strictly positive: $f(n) &amp;gt; 0$ for all $n$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;using-functions-as-measurement-of-algorithmic-complexity&#34;&gt;Using functions as measurement of algorithmic complexity&lt;/h1&gt;

&lt;p&gt;We want to use functions to measure the inherit &lt;em&gt;complexity&lt;/em&gt; of &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is not very straight-forward.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We don&amp;rsquo;t care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Runtime environment&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU speed&lt;/li&gt;
&lt;li&gt;Start-up time of the program&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implementation issues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Speed of the language&lt;/li&gt;
&lt;li&gt;Number of statements used&lt;/li&gt;
&lt;li&gt;Overhead in memory data structure&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We do care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inherit complexity of the algorithm&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;capturing-the-essentials&#34;&gt;Capturing the essentials&lt;/h1&gt;

&lt;p&gt;Suppose that we have an algorithm $P$.  Let&amp;rsquo;s use some function $f(n)$ to represent the time, in the &lt;em&gt;worst case&lt;/em&gt;, that $P$ takes to process an input of size $n$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at the effects of various environmental factors on the measure $f(n)$.&lt;/p&gt;

&lt;h1 id=&#34;effects-on-the-measure&#34;&gt;Effects on the measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$P$ is reimplemented using C (from Python), so it runs 20 times faster now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = \frac{1}{20} f(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$P$ runs inside a &lt;em&gt;docker&lt;/em&gt; image, so it takes an additional 300 ms to start.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = f(n) + 300\mathrm{ms}$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we don&amp;rsquo;t want to care about these implementation and runtime factors when investigating the complexity of algorithms.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Intuition: given $f(n)$, we define family of (infinite) functions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{better\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{worse\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{equivalent\ to}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mathcal-o-notation-better-than&#34;&gt;$\mathcal{O}$-notation - better than&lt;/h1&gt;

&lt;p&gt;We want to define all function which are measure of algorithms which are better than (or same as) $g(n)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The Big-O notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\mathcal{O}(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0 &amp;lt; f(n) &amp;lt; c\cdot g(n)\}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We call $g(n)$ the asymptotic upper bound of the functions in $\mathcal{O}(g(n))$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;big-o.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;significance-of-asymptotic-analysis&#34;&gt;Significance of asymptotic analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If we have an algorithm $A$, and its precise time measurement (on a specific hardware) is given precisely as &lt;code&gt;$T(n)$&lt;/code&gt;, where $n$ is the input size in &lt;em&gt;bytes&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If &lt;code&gt;$T(n)\in\mathcal{O}(g(n))$&lt;/code&gt;, we are saying that $A$ is &lt;strong&gt;better&lt;/strong&gt; than $g(n)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Challenge&lt;/em&gt;:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Check that the variations on the way that the efficiency of $A$ is
measured also are in $\mathcal{O}(g(n))$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$T_1(n)$ is the time that $A$ runs on a slow processor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$T_2(n)$ is the time that $A$ if the input is measured in the array length.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;omega-notation-worse-than&#34;&gt;$\Omega$-notation - worse than&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The $\Omega$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\Omega(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0  &amp;lt; c\cdot g(n) &amp;lt; f(n) \}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We say that $g(n)$ is the asymptotic lower bound of the functions in $\Omega(g(n))$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;omega.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;theta-notation-same-as&#34;&gt;$\Theta$-notation - same as&lt;/h1&gt;

&lt;p&gt;*&lt;em&gt;Definition&lt;/em&gt;: The $\Theta$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\Theta(g(n)) = \mathcal{O}(g(n)) \cap \Omega(g(n))$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;More precisely,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$
\begin{eqnarray}
&amp;amp;&amp;amp; \Theta(g(n)) \\
&amp;amp;=&amp;amp; 
\{f(n): \exists n_0, c_1, c_2 &amp;gt; 0,\forall n &amp;gt; n_0,\ 0 \leq c_1\cdot g(n) \leq f(n) \leq c_2\cdot g(n)\}
\end{eqnarray}
$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;theta.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\mathcal{O}(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are better (or equivalent) to $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\Omega(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are worse (or equivalent) to $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\Theta(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are equivalent to $g(n)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;functions-we-use&#34;&gt;Functions we use:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Polynomials:&lt;/p&gt;

&lt;p&gt;$$f(n) = \sum_{i=0}^d a_i n^i$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exponentials:&lt;/p&gt;

&lt;p&gt;$$f(n) = a^n$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Logorithms&lt;/p&gt;

&lt;p&gt;$$f(n) = \log_a(n)$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Factorials&lt;/p&gt;

&lt;p&gt;$$f(n) = n!$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-exponents&#34;&gt;More about Exponents&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(a^m)^n = a^{mn}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(a^m) (a^n) = a^{m+n}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\lim_{n\to\infty} \frac{n^d}{a^n} = 0$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-logorithms&#34;&gt;More about Logorithms&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$a^{\log_a(n)} = n$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_a(mn) = \log_a(m) + \log_a(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_a(n^d) = d\cdot \log_a(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_b(a) \cdot \log_a(n) = \log_b(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$a^{\log_a (n)} = n^{\log_b(a)}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-factorial&#34;&gt;More about Factorial&lt;/h1&gt;

&lt;p&gt;Stirling&amp;rsquo;s approximation:&lt;/p&gt;

&lt;p&gt;$$ n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^n $$&lt;/p&gt;

&lt;h1 id=&#34;comparisons&#34;&gt;Comparisons&lt;/h1&gt;

&lt;p&gt;For any $a &amp;gt; 1$, $b &amp;gt; 0$ and $c &amp;gt; 1$, we have:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ 
\mathcal{O}(\log_a(n)) \subseteq \mathcal{O}(n^b) \subseteq \mathcal{O}(c^n)
$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We can show that:&lt;/p&gt;

&lt;p&gt;$$ n! \in\mathcal{O}(n^n) $$&lt;/p&gt;

&lt;p&gt;In fact:&lt;/p&gt;

&lt;p&gt;$$ \mathcal{O}(2^n) \subset \mathcal{O}(n^n) $$&lt;/p&gt;

&lt;h1 id=&#34;notation&#34;&gt;Notation&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;s convenient to treat complexity classes as &lt;em&gt;variables&lt;/em&gt; in equations.&lt;/p&gt;

&lt;p&gt;So, we use the following notations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If $f\in \mathcal{O}(g)$, we write it as equality $f=\mathcal{O}(g)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;test-your-understanding&#34;&gt;Test your understanding&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If $f = \mathcal{O}(g)$ and $g = \mathcal{O}(h)$, can you prove that $f =
\mathcal{O}(h)$?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Does it make sense intuitively?&lt;/p&gt;

&lt;p&gt;Does it work out mathematically?&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So that $n^2 + 10000= \mathcal{O}(n^3)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Basics of Scala</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/scala-basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/scala-basics/</guid>
      <description>

&lt;h1 id=&#34;basics-of-scala&#34;&gt;Basics of Scala&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;objects&#34;&gt;Objects&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;var name : String = &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
This creates a &lt;strong&gt;variable&lt;/strong&gt;, with the type &lt;code&gt;String&lt;/code&gt;, and it&amp;rsquo;s initialized to
&amp;ldquo;hello&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;name.CharAt(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
Java-style method invocation&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;______&lt;/h1&gt;

&lt;p&gt;Scala uses the same scoping and symbol bindings.&lt;/p&gt;

&lt;p&gt;There are two types of &lt;em&gt;symbols&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Variables&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bindings to &lt;code&gt;var&lt;/code&gt; can be updated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;var name:String = &amp;quot;Albert&amp;quot;
name = &amp;quot;Einstein&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Values&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bindings to &lt;code&gt;val&lt;/code&gt; is permanent.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val name : String = &amp;quot;Alert&amp;quot;
name = &amp;quot;Einstein&amp;quot;
// error: reassignment to val
//       x = &amp;quot;Einstein&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is the same as Clojure, and it&amp;rsquo;s preferred over &lt;code&gt;var&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;type-inference&#34;&gt;Type Inference&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Definition&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A statically typed language is one that requires the compiler to have complete
type information on all the symbols in the source code &lt;strong&gt;at&lt;/strong&gt; compile-time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Java &lt;strong&gt;and&lt;/strong&gt; Scala are statically typed languages.&lt;/li&gt;
&lt;li&gt;Clojure and Python are not statically typed, but typed (at runtime).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The compiler needs type information specified for &lt;em&gt;all&lt;/em&gt; the symbols.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val name : String = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;____&lt;/h1&gt;

&lt;p&gt;Scala has a feature, known as &lt;em&gt;type inference&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At compile-time, the compiler makes a best attempt to fill in the missing type
information.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val small_integer = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The compiler will see that &lt;code&gt;small_integer&lt;/code&gt; should be &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;var x = y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The compiler will use the type of &lt;code&gt;y&lt;/code&gt; to infer the type of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the interactive interpreter session, you can always inspect the type
information of existing symbols:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;:t small_integer
Int
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;procedural-programming&#34;&gt;Procedural programming&lt;/h1&gt;

&lt;h2 id=&#34;if&#34;&gt;IF&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;if (&amp;lt;cond&amp;gt;) {
  &amp;lt;expression&amp;gt;
} else if (&amp;lt;cond&amp;gt;) {
  &amp;lt;expression&amp;gt;
} else {
  &amp;lt;expression&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
The classic Java-style branching.  Scala has better pattern matching
which is preferred over if-else.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if-else&lt;/code&gt; is an expression, not a statement.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val age = 65
var senior:String = &amp;quot;&amp;quot;
if(age &amp;lt; 65) {
  senior = &amp;quot;Not senior&amp;quot;
} else {
  senior = &amp;quot;Senior&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val age = 65
val senior = if(age &amp;lt; 65) 
               &amp;quot;Not senior&amp;quot;
             else
               &amp;quot;Senior&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;_____&lt;/h1&gt;

&lt;h2 id=&#34;for&#34;&gt;FOR&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for(&amp;lt;val&amp;gt; &amp;lt;- &amp;lt;iterable&amp;gt;) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;All container data structures are iterables: arrays, lists, map, &amp;hellip;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scala has a nice way to generate iterables over integer ranges:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 to 10     // 1, 2, ... 10
1 until 10  // 1, 2, ... 9
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;for(x &amp;lt;- 1 to 10) {
  println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
Scala&amp;rsquo;s &lt;code&gt;for&lt;/code&gt; loop is much more powerful then simple iteration.  More on this
in lectures on programming with sequences.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;_____________&lt;/h1&gt;

&lt;h2 id=&#34;loops&#34;&gt;Loops&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;while(&amp;lt;cond&amp;gt;) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;do {
    ...
} while(&amp;lt;cond&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;syntax-rules&#34;&gt;Syntax rules&lt;/h1&gt;

&lt;p&gt;Suppose that an object has zero or one argument.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.method()
obj.method(arg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the parenthesis can be omitted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.method
obj.method arg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The dot can also be omitted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj method
obj method arg
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;_____&lt;/h1&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 + 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is actually a method invocation in disguise.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.+(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The equivalent syntax in method invocation.  The method name is &lt;code&gt;+&lt;/code&gt;,
the object is &lt;code&gt;1&lt;/code&gt;, and the argument is &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This type of syntax rule allows us to introduce user-defined operators to
support programming constructs such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x multiplyWith y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We assume that the object &lt;code&gt;x&lt;/code&gt; has a method called &lt;code&gt;multiplyWith&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can also invoke Java methods like operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;hello&amp;quot; charAt 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;syntax-rules-1&#34;&gt;Syntax rules&lt;/h1&gt;

&lt;p&gt;More syntax rules to come.&lt;/p&gt;

&lt;h1 id=&#34;functions&#34;&gt;Functions&lt;/h1&gt;

&lt;p&gt;Functions are in fact objects of a &lt;em&gt;function&lt;/em&gt; class.  Scala offers a succinct
syntax for defining functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;import scala.math
val area = {(count:Int, radius:Float) =&amp;gt; x * scala.math.Pi * radius * radius}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm clipboard&#34;&gt;val area : (Int, Float) =&amp;gt; Double = {
  (count, radius) =&amp;gt; {
    var total: Double = 0
    for(i &amp;lt;- 0 until count) {
        total += scala.math.Pi * radius * radius
    }
    total
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;The type of the &lt;code&gt;val&lt;/code&gt; is &lt;code&gt;(Int, Float) =&amp;gt; Double&lt;/code&gt;.  This is also known as
the &lt;em&gt;function signature&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The value is a function (instance of a class Function2).&lt;/li&gt;
&lt;li&gt;The inputs are bound to symbols &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;radius&lt;/code&gt;.
Note the binding types are inferred based on the function signature.
&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bindings&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Procedural programming&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Object method invocation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function as data&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Bucket Sort</title>
      <link>http://db.science.uoit.ca/courses/algorithms/bucket-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/bucket-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Clojure 3</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/clojure-language-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/clojure-language-3/</guid>
      <description>

&lt;h1 id=&#34;clojure-part-iii&#34;&gt;Clojure Part III&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;data-read-write-transformation&#34;&gt;Data Read &amp;amp; &lt;del&gt;Write&lt;/del&gt; &amp;amp; Transformation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;List&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Vector&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(Hash-) Map&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Set&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;list&#34;&gt;List&lt;/h1&gt;

&lt;p&gt;Create&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(list ...)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Read&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(first seq)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(nth seq n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Transformation&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(cons elem seq)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(conj seq elem ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(rest seq)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;vector&#34;&gt;Vector&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Create&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[ ... ]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(vector ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(vec seq)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(into v seq)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Read: Vectors are &lt;em&gt;functions&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(v n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(get v n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(nth v n)&lt;/code&gt;, &lt;code&gt;(first ...)&lt;/code&gt; still apply.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Transformation&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;conj&lt;/code&gt;, &lt;code&gt;cons&lt;/code&gt;, &lt;code&gt;rest&lt;/code&gt; still apply.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(assoc v n val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(update v n func)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(subvec v start end)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(replace map v)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;hash-map&#34;&gt;(Hash-) Map&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Create&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{ ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(hash-map ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(array-map ...)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Read: maps are functions, and keywords are functions!!&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(m key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(:keyword m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(get m key default-val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(keys m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(vals m)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(contains? m key)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Transform&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(assoc m key val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(assoc-in m [path] val)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(dissoc m key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(merge m1 m2 ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(merge-width f m1 m2 ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(select-keys m [keys])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(update m key func)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(update-in m [path] func)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(rename-keys m rename-map)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;sequences&#34;&gt;Sequences&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;sequences-1&#34;&gt;Sequences&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Think of it as another data structure, known as &lt;em&gt;seq&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The closest thing we have seen is &lt;em&gt;Iterable&lt;/em&gt; in Java.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Seqs gets the most amount attention in Clojure.&lt;/p&gt;

&lt;h1 id=&#34;sources-of-seqs&#34;&gt;Sources of seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(range &amp;lt;start&amp;gt; &amp;lt;end&amp;gt; &amp;lt;step&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Creates a sequence of integers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(repeat &amp;lt;n&amp;gt; &amp;lt;x&amp;gt;)
(repeat &amp;lt;x&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Creates a sequence of the same value &lt;code&gt;x&lt;/code&gt; repeately &lt;code&gt;n&lt;/code&gt; times.  If &lt;code&gt;n&lt;/code&gt;
is omitted, the sequence continuous forever.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(iterate &amp;lt;f&amp;gt; &amp;lt;x&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; A sequence with: &lt;code&gt;x&lt;/code&gt; &lt;code&gt;(f x)&lt;/code&gt;, &lt;code&gt;(f (f x))&lt;/code&gt;, &amp;hellip; &lt;em&gt;forever&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(repeatedly &amp;lt;n&amp;gt; &amp;lt;f&amp;gt;)
(repeatedly &amp;lt;f&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; A sequence with: &lt;code&gt;(f)&lt;/code&gt;, &lt;code&gt;(f)&lt;/code&gt;, &amp;hellip; $n$ times.  If $n$ is omitted, the
sequence continuous forever.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(cycle &amp;lt;collection&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Generates an infinite sequence of by repeating the collection forever.&lt;/p&gt;

&lt;h1 id=&#34;more-sources-of-seqs&#34;&gt;More sources of seqs&lt;/h1&gt;

&lt;h2 id=&#34;readers&#34;&gt;Readers:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(clojure.java.io/reader &amp;lt;filename&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;creating-a-sequence-of-lines&#34;&gt;Creating a sequence of lines&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(line-seq &amp;lt;rdr&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;Don&amp;rsquo;t forget to close the reader when you are done.  To be safe, use the macro:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(with-open [rdr (clojure.java.io/reader &amp;lt;filename&amp;gt;)]
  (let [lines (line-seq rdr)]
    ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The &lt;code&gt;with-open&lt;/code&gt; macro will create the symbol binding to the opened
reader, and close it afterwards.&lt;/p&gt;

&lt;h1 id=&#34;even-more-sources-of-seqs&#34;&gt;Even more sources of seqs&lt;/h1&gt;

&lt;h2 id=&#34;regular-expression&#34;&gt;Regular expression&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#&amp;quot;...&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Clojure relies on Java&amp;rsquo;s regular expression library.  So the syntax
for regular expressions is the same as Java&amp;rsquo;s &lt;code&gt;java.util.regex&lt;/code&gt; library.  But
creating a pattern is really simple with the reader macro &lt;code&gt;#&amp;quot;...&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;sequences-of-matches&#34;&gt;Sequences of matches&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(re-seq &amp;lt;pattern&amp;gt; &amp;lt;string&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a sequence of matches of pattern in the string.  If the
pattern does &lt;strong&gt;not&lt;/strong&gt; contain groups, then each match is a string.  Otherwise,
it&amp;rsquo;s a vector containing the groups.&lt;/p&gt;

&lt;h1 id=&#34;working-with-seqs&#34;&gt;Working with seqs&lt;/h1&gt;

&lt;div style=height:150px&gt;&lt;/div&gt;

&lt;h2 id=&#34;fast-and-furious&#34;&gt;&lt;em&gt;Fast and furious&lt;/em&gt;&lt;/h2&gt;

&lt;h1 id=&#34;working-with-seqs-1&#34;&gt;Working with seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def nat (iterate inc 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Defining natural numbers.  This is an infinite sequence, so &lt;code&gt;(println nat)&lt;/code&gt; will result in a
never-ending loop.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def nat+ (rest nat))
; (1 2 3 4 5 ... ∞)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Strictly positive numbers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(first nat)   ; 0
(first nat+)  ; 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Getting the first element&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(take 10 nat)
; (0 1 2 3 4 5 6 7 8 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Takes the first 100 natural numbers.&lt;/p&gt;

&lt;h1 id=&#34;working-with-seqs-2&#34;&gt;Working with seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(interleave &amp;lt;seq1&amp;gt; &amp;lt;seq2&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Mix two sequences into one by interleaving the elements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(interpose &amp;lt;x&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Insert &lt;code&gt;&amp;lt;x&amp;gt;&lt;/code&gt; between the elements in &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(split-at &amp;lt;index&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a vector containing &lt;em&gt;two&lt;/em&gt; seqs.  The two seqs are produced by
splitting the input &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt; at the &lt;code&gt;&amp;lt;index&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;higher-order-functions-with-seqs&#34;&gt;Higher order functions with seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(map &amp;lt;fn&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a sequence by applying &lt;code&gt;(&amp;lt;fn&amp;gt; x)&lt;/code&gt; for each &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(map &amp;lt;fn&amp;gt; &amp;lt;seq-1&amp;gt; &amp;lt;seq-2&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a sequence by applying &lt;code&gt;(&amp;lt;fn&amp;gt; xi yi)&lt;/code&gt; for each &lt;code&gt;xi&lt;/code&gt; in &lt;code&gt;&amp;lt;seq-1&amp;gt;&lt;/code&gt; and &lt;code&gt;yi&lt;/code&gt; in &lt;code&gt;&amp;lt;seq-2&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(filter &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The function &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; is a &lt;em&gt;predicate&lt;/em&gt;, namely a function that always
returns &lt;code&gt;true/false&lt;/code&gt;.  The returned seq contains elements &lt;br&gt;
&lt;code&gt;x$\in$&amp;lt;seq&amp;gt;&lt;/code&gt; that satisfies the
predicate, i.e. &lt;code&gt;(&amp;lt;pred&amp;gt; x)&lt;/code&gt; is true.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(reduce &amp;lt;f&amp;gt; &amp;lt;seq&amp;gt;)
(reduce &amp;lt;f&amp;gt; &amp;lt;x0&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Reduces a sequence (x1 x2 x3) to a single value of &lt;br&gt;
&lt;code&gt;(f (f (f x0) x1) x3)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;more-higher-order-functions-on-seqs&#34;&gt;More higher order functions on seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(take-while &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Takes elements &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt; for as long as &lt;code&gt;(&amp;lt;pred&amp;gt; x)&lt;/code&gt; is true.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(drop-while &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Drops elements &lt;code&gt;x&lt;/code&gt; from &lt;code&gt;&amp;lt;seq&amp;gt;&lt;/code&gt; for as long as &lt;code&gt;(&amp;lt;pred&amp;gt; x)&lt;/code&gt; is true.
Returns the remaining elements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(split-with &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a vector of two seqs.  The first is &lt;code&gt;(take-while ...)&lt;/code&gt; and the
second is &lt;code&gt;(drop-while ...)&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;predicates-on-seqs&#34;&gt;Predicates on seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(every? &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Tests if &lt;em&gt;pred&lt;/em&gt; holds for every element of the seq.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(some &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns the first element in seq that satisfies the predicate.
It can be used to test if &lt;em&gt;pred&lt;/em&gt; holds for some element of the seq.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(not-every? &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Test that predicate is violated by some elements in seq.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(not-any? &amp;lt;pred&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Test that none of the elements in seq satisfies the predicate.&lt;/p&gt;

&lt;h1 id=&#34;transformations-of-seqs&#34;&gt;Transformations of seqs&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(sort &amp;lt;seq&amp;gt;)
(sort &amp;lt;cmp&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Sorts the seq by an optional comparator.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(sort-by &amp;lt;key-fn&amp;gt; &amp;lt;seq&amp;gt;)
(sort-by &amp;lt;key-fn&amp;gt; &amp;lt;cmp&amp;gt; &amp;lt;seq&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Sorts the seq by &lt;code&gt;(&amp;lt;key-fn&amp;gt; x)&lt;/code&gt; instead of the elements &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(reverse seq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Reverses the sequence.&lt;/p&gt;

&lt;h1 id=&#34;seq-in-action&#34;&gt;Seq in action&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def nat (iterate inc 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn even? [n] (zero? (mod n 2)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;seq-in-action-1&#34;&gt;Seq in action&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def even-nat (filter even? nat))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def odd-nat (filter #(not (even? %1)) nat))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(take 4 even-nat)       ; (0 2 4 6)
(take 4 odd-nat)        ; (1 3 5 7)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(interleave odd-nat even-nat)
; =&amp;gt; (1 0 3 2 5 4 7 6)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;seq-in-action-2&#34;&gt;Seq in action&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn prime? [n] (not-any? (fn [i] (zero? (mod n i))) (range 2 n)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def primes (filter prime? (drop 2 nat)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(take 100 primes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Questions:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Does the gap between two adjacent primes grow?&lt;/li&gt;
&lt;li&gt;How many primes $\leq n$ are there for growing n?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;tricks-magic&#34;&gt;Tricks &amp;amp; Magic&lt;/h1&gt;

&lt;h2 id=&#34;the-trick&#34;&gt;The trick&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def letters [\a \b \c])
(def numbers [ 1  2  3   4  5  6])
(map vector letters numbers)
; =&amp;gt; ([\a 1] [\b 2] [\c 3])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-magic&#34;&gt;The magic&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def prime-gaps
  (map #(apply - (reverse %)) (map vector primes (rest primes))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;tricks-magic-1&#34;&gt;Tricks &amp;amp; Magic&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn count-primes [n] (count (take-while #(&amp;lt;= % n) primes)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(def prime-counts (map count-primes nat))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Theorem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The distribution of primes is $\Theta(n/\log n)$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn g [n] (if (&amp;gt; n 1) (/ (float n) (Math/log n)) 1))
(def alpha (map #(/ %1 (g %2)) prime-counts nat))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;a-preview-of-the-leverage-on-jvm&#34;&gt;A preview of the leverage on JVM&lt;/h1&gt;

&lt;p&gt;You need to include &lt;code&gt;incanter.jar&lt;/code&gt; in the CLASSPATH to run the following code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(use &#39;(incanter core charts))
(let [ds (conj-cols (take 1000 nat) (take 1000 alpha))]
  (view (xy-plot 0 1 :data ds)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;xy-plot-alpha.png&#34; style=float:right&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;more-sorcery&#34;&gt;More sorcery&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(view 
  (scatter-plot 0 1 
                :data (conj-cols 
                        (take 1000 nat) 
                        (take 1000 prime-gaps))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;scatter-plot-gaps.png&#34; style=float:right&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;in-one-fell-swoop&#34;&gt;In one fell swoop&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(use &#39;(incanter core charts))
(let [; list of natural numbers
      nat (iterate inc 0)
      ; a predicate to decide of input is prime
      prime? (fn [n] 
               (not-any? 
                 (fn [i] (zero? (mod n i))) 
                 (range 2 n)))
      ; list of primes
      primes (filter prime? nat)
      ; compute the gaps between to adjacent primes
      gaps (map 
              #(apply - (reverse %))
              (map vector primes (rest primes)))
      ; counts the number of primes less than n
      countp (fn [n] (count (take-while #(&amp;lt; % n) primes)))]
    ; plots
    (view (scatter-plot 0 1 :data (conj-cols (take 1000 nat) (take 1000 gaps))))
    (view (xy-plot 0 1 :data (conj-cols (take 1000 nat) 
                             (map #(* (Math/log %) (/ (countp %) (float %)))
                                  (take 1000 nat))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data&lt;/li&gt;
&lt;li&gt;Data transformation&lt;/li&gt;
&lt;li&gt;Sequences&lt;/li&gt;
&lt;li&gt;Sequence (higher-order) functions&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Clojure 4</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/clojure-language-4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/clojure-language-4/</guid>
      <description>

&lt;h1 id=&#34;turing-complete-efficient-programming-in-clojure&#34;&gt;Turing Complete &amp;amp; Efficient Programming in Clojure&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Function and recursion&lt;/li&gt;
&lt;li&gt;Tail-recursion with &lt;code&gt;recur&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loop&lt;/code&gt; and &lt;code&gt;recur&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Infinite sequences with lazy-evaluation&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;turing-complete&#34;&gt;Turing-complete&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Q:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given an input seq of elements, how do we compute
the cummulative aggregates of each distinct element
seen in the input seq.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;???&lt;/p&gt;

&lt;p&gt;Maybe we can look for a built-in seq function to do this&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;height:300px&#34;&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;We need to be able to implement general purpose functions to match the power and
flexibility of Java / Python / &amp;hellip;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;looking-back-at-procedural-programming&#34;&gt;Looking back at procedural programming&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def count_seq(input_seq):
    counts = dict()
    
    for elem in input_seq:
        if elem in counts:
            counts[elem] += 1
        else:
            counts[elem] = 1

    return counts
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;rewriting-python-with-recursion&#34;&gt;Rewriting Python with recursion&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def count_seq(input_seq):
    if len(input_seq) == 0:
        return {}
    else:
        first = input_seq[0]
        rest  = input_seq[1:]
        return increment(first, count_seq(rest))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; A recursive formulation&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def increment(key, counts):
    if key in counts:
        counts[key] += 1
    else:
        counts[key] = 1
    return counts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Increments the count of a key in &lt;code&gt;counts&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-recursion-version-1&#34;&gt;Clojure&amp;rsquo;s recursion (version 1)&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(defn inc-or-1 [n] (if (nil? n) 1 (inc n)))

(defn count-seq [xs]
  (if (empty? xs)
    {}
    (let [head (first xs)
          tail (rest xs)]
      (update (count-seq tail) head inc-or-1))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Make sure you understand this code.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;What is the time complexity?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Linear time.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the space complexity?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Linear space (why?) and it uses the precious stack.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;stack-overflow&#34;&gt;Stack Overflow&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(count-seq (repeat 1000 :a))
; {:a 1000}

(count-seq (repeat 100000 :a))
; StackOverflowError   clojure.core/first--4339
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Can you understand why the stack is being filled up necessarily?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def repeat(n, x): 
    return [x for i in range(n)]

count_seq(repeat(100, &amp;quot;a&amp;quot;))
# {&amp;quot;a&amp;quot;: 100}

count_seq(repeat(1000, &amp;quot;a&amp;quot;))
# RuntimeError: maximum recursion depth exceeded
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Python has a more expensive function call, so it cannot hold as many
on its preallocated stack.  The reason is that Python doesn&amp;rsquo;t encourage the
usage of recursion as a scalable programming pattern.&lt;/p&gt;

&lt;h1 id=&#34;tail-recursion&#34;&gt;Tail recursion&lt;/h1&gt;

&lt;p&gt;Definition: &lt;em&gt;tail recursion&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A function &lt;code&gt;f&lt;/code&gt; uses &lt;em&gt;tail recursion&lt;/em&gt; if its recursive call is &lt;em&gt;always&lt;/em&gt; the last
step in the function.  Namely, the function must necessarily call itself as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(...):
    ...
    ...
    return f(...)
    ...
    ...
    return f(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we say that &lt;code&gt;f&lt;/code&gt; is tail-recursive.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;revisit-count-seq-in-python&#34;&gt;Revisit &lt;code&gt;count_seq&lt;/code&gt; in Python&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def count_seq(input_seq):
    if len(input_seq) == 0:
        return {}
    else:
        first = input_seq[0]
        rest  = input_seq[1:]
        return increment(first, count_seq(rest))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is &lt;em&gt;not&lt;/em&gt; tail-recursion.  Why not?&lt;/p&gt;

&lt;h1 id=&#34;tail-recursion-version-for-python&#34;&gt;Tail recursion version for Python.&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def count_seq(seq, cnt):
    if len(seq) == 0:
        return cnt
    else:
        head = seq[0]
        tail = seq[1:]
        return count_seq(tail, increment(cnt, head))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is tail-recursive.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Good news:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tail recursion does not require taking up space on the stack.&lt;/p&gt;

&lt;p&gt;&lt;span style=color:red&gt; Why? &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bad news:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Python doesn&amp;rsquo;t know about tail recursion.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;tail-recursion-in-clojure&#34;&gt;Tail recursion in Clojure&lt;/h1&gt;

&lt;p&gt;Clojure gives programmer a special way for a function to call itself if it is
tail-recursive.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn f [&amp;lt;args&amp;gt;]
  ...  (recur &amp;lt;args&amp;gt;) ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn count-seq [xs cnt]
  (if (empty? xs) 
    cnt 
    (let [head (first xs) 
          tail (rest xs)]
      (recur tail (update cnt head inc-or-1))))) 

(count-seq (repeat 1000000 :b) {})
; {:b 1000000}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s tail-recursive.&lt;/p&gt;

&lt;h1 id=&#34;more-on-clojure-style&#34;&gt;More on Clojure-style&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We prefer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;(count-seq &amp;lt;seq&amp;gt;)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But we had to do:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;(count-seq &amp;lt;seq&amp;gt; {})&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The solution is to use the multi-arity feature:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn count-seq
  ([xs] (count-seq xs {}))
  ([xs cnt] 
    (if (empty? xs)
      cnt
      (recur (rest xs)
             (update cnt 
                     (first xs) inc-or-1)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-s-general-purpose-loop&#34;&gt;Clojure&amp;rsquo;s general purpose loop&lt;/h1&gt;

&lt;p&gt;We may want to define a recursion-based computation in an expression.
It&amp;rsquo;s &lt;em&gt;okay&lt;/em&gt; to define a function each time we need recursion.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn count-seq [input-seq]
  (let [f (fn [xs cnt]
            (if (empty? xs)
              cnt
              (recur (rest xs)
                     (update cnt (first xs) inc-or-1))))]
    (f input-seq {})))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But we can do even better.&lt;/p&gt;

&lt;p&gt;We can have a &lt;strong&gt;loop-expression&lt;/strong&gt; that is a recursive construct that allows us
to specify:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The parameter symbols and their initial values.&lt;/li&gt;
&lt;li&gt;The body to evaluate the new values for the parameters.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;clojure-s-general-purpose-loop-1&#34;&gt;Clojure&amp;rsquo;s general purpose loop&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(loop [&amp;lt;p1&amp;gt; &amp;lt;exp&amp;gt;
       &amp;lt;p2&amp;gt; &amp;lt;exp&amp;gt; ...]
  (... (recur &amp;lt;new-p1&amp;gt; &amp;lt;new-p2&amp;gt;) ...))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now, we can reimplement count-seq once more:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn count-seq [input-seq]
  (loop [xs input-seq
         cnt {}]
    (if (empty? xs)
      cnt
      (recur (rest xs) (update cnt (first xs) inc-or-1)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;count-seq-yet-again-version&#34;&gt;&lt;code&gt;count-seq&lt;/code&gt; yet again version&lt;/h1&gt;

&lt;div style=height:200px&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn increment [cnt key]
  (update cnt key inc-or-1))

(defn count-seq [input-seq]
  (reduce increment {} input-seq))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; If you have trouble understanding this, try it out with the sequence
&amp;lsquo;(:a :a :b), and work it out by hand.&lt;/p&gt;

&lt;h1 id=&#34;count-seq-the-last-version&#34;&gt;&lt;code&gt;count-seq&lt;/code&gt; the last version&lt;/h1&gt;

&lt;div style=height:100px&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn count-seq [input-seq] (frequencies input-seq))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def count-seq frequencies)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is my favourite version :-)&lt;/p&gt;

&lt;h1 id=&#34;lazy-evaluation&#34;&gt;Lazy Evaluation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Creating infinite sequences&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tractable recursion without blowing up the stack&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;infinite-sequences&#34;&gt;Infinite sequences&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def nat (iterate inc 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is an infinite sequence.  The function &lt;code&gt;iterate&lt;/code&gt; is used to
create the infinite sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def zeros (repeat 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is an infinite sequence of zeros.  The function &lt;code&gt;repeat&lt;/code&gt; creates
the infinite sequence.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What makes &lt;em&gt;infinity&lt;/em&gt; possible?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The computation of each element is performed &lt;em&gt;only&lt;/em&gt; when that element is
&lt;em&gt;required&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is called &lt;em&gt;lazy evaluation&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;infinite-sequences-1&#34;&gt;Infinite sequences&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;How do we make infinite sequences?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How do we make program with lazy evaluation?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;introducing-lazy-seq&#34;&gt;Introducing &lt;code&gt;lazy-seq&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;user=&amp;gt; (doc lazy-seq)
-------------------------
clojure.core/lazy-seq
([&amp;amp; body])
Macro
  Takes a body of expressions that returns an ISeq or nil, and yields
  a Seqable object that will invoke the body only the first time seq
  is called, and will cache the result and return it on all subsequent
  seq calls. See also - realized?
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;lazy-seq&#34;&gt;Lazy-seq&lt;/h1&gt;

&lt;p&gt;Consider ways of creating a seq consisting of values returned by &lt;code&gt;(f i)&lt;/code&gt; for
i=1, 2, 3.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;[(f 1) (f 2) (f 3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Remember that vectors are seqs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;`((f 1) (f 2) (f 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Lists are also seqs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(map f (range 100))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Say &lt;code&gt;f&lt;/code&gt; is a very expensive function to invoke:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn f [x]
  (do (println &amp;quot;zzz...&amp;quot; x)
      (Thread/sleep 1500)
      (str &amp;quot;a long sleep (&amp;quot; x &amp;quot;)&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;lazy-seq-1&#34;&gt;Lazy-seq&lt;/h1&gt;

&lt;p&gt;So what&amp;rsquo;s wrong with this code?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(take 2 (map f (range 100)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or this code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(first (map f (range 10000)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lazy seq to the rescue:&lt;/p&gt;

&lt;h1 id=&#34;lazy-seq-2&#34;&gt;Lazy-seq&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax sm&#34;&gt;user=&amp;gt; (doc lazy-seq)
-------------------------
clojure.core/lazy-seq
([&amp;amp; body])
Macro
  Takes a body of expressions that returns
  an ISeq or nil, and yields a Seqable
  object that will invoke the body only the 
  first time seq is called, and will cache 
  the result and return it on all subsequent 
  seq calls.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(lazy-seq &amp;lt;expr&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; returns a seq, but it will &lt;em&gt;not&lt;/em&gt; be called
until the first element is accessed.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;creating-a-lazy-seq-version&#34;&gt;Creating a lazy-seq version&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(cons (f 1) nil)                          ;=&amp;gt; ((f 1))
(cons (f 1) (cons (f 2) nil)              ;=&amp;gt; ((f 1) (f 2))
(cons (f 1) (cons (f 2) (cons (f 3) nil)) ;=&amp;gt; ((f 1) (f 2) (f 3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that they are not lazy.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(lazy-seq 
  (cons 
    (f 1)
    (lazy-seq
      (cons
        (f 2)
        (lazy-seq
          (cons (f 3) nil))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is a lazy sequence.&lt;/p&gt;

&lt;h1 id=&#34;creating-a-lazy-seq-version-1&#34;&gt;Creating a lazy-seq version&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s generalize.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure clipboard&#34;&gt;(defn fs [n]
  (if (zero? n)
    nil
    (lazy-seq (cons (f n) (fs (dec n))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Note that this is &lt;em&gt;not&lt;/em&gt; tail-recursive.  But it&amp;rsquo;s &lt;em&gt;okay&lt;/em&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now try out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(take 3 (fs 1000))
(first (fs 1000))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;other-forms-of-lazy-evaluation&#34;&gt;Other forms of lazy evaluation&lt;/h1&gt;

&lt;p&gt;Clojure supports other forms of lazy evaluation.  See &lt;code&gt;(doc delay)&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tail recursion with recur&lt;/li&gt;
&lt;li&gt;Loop/recur&lt;/li&gt;
&lt;li&gt;Lazy sequences&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Clojure Language</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/clojure-language-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/clojure-language-2/</guid>
      <description>

&lt;h1 id=&#34;clojure-part-ii&#34;&gt;Clojure: Part II&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;data-in-clojure&#34;&gt;Data in Clojure&lt;/h1&gt;

&lt;p&gt;$\mathbf{D}$(&lt;code&gt;clojure&lt;/code&gt;) = a sequence of (nested) &lt;em&gt;data&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(1 2 3)
(&amp;quot;abc&amp;quot; &amp;quot;def&amp;quot;)
[&amp;quot;abc&amp;quot; (&amp;quot;def&amp;quot; 1 2 3)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s explore the definitions of &lt;em&gt;data&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;data-in-clojure-1&#34;&gt;Data in Clojure&lt;/h1&gt;

&lt;p&gt;Atoms&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Numbers: 3.1415, 100, &lt;code&gt;2/3&lt;/code&gt;, 100N, 3.1415M&lt;/li&gt;
&lt;li&gt;Strings: &lt;code&gt;&amp;quot;hello world&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Characters: &lt;code&gt;\a \b \c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Symbols: &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;π&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Keywords: &lt;code&gt;:name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Nil value: &lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;lists&#34;&gt;Lists&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;( ... )
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Lists are &lt;em&gt;linked lists&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They are super efficient for prepend and append at the ends of the lists.&lt;/li&gt;
&lt;li&gt;But they are not efficient for random access.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;lists-1&#34;&gt;Lists&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Important&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Clojure, by default, interpretates lists as function invocations.&lt;/li&gt;
&lt;li&gt;A list that is &lt;em&gt;just a list&lt;/em&gt; needs to be quoted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(println &amp;quot;hello&amp;quot; &amp;quot;world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is a function invocation.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(quote (println &amp;quot;hello&amp;quot; &amp;quot;world&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is a list of three elements.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;&#39;(println &amp;quot;hello&amp;quot; &amp;quot;world&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is the preferred way of quoting a list.&lt;/p&gt;

&lt;h1 id=&#34;vectors&#34;&gt;Vectors&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;[ ... ]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vectors are &lt;em&gt;arrays&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They are efficient for random access.&lt;/li&gt;
&lt;li&gt;But they are more costly for insertion in the middle and possibly at the ends.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;hash-maps&#34;&gt;Hash-maps&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;{ &amp;lt;key&amp;gt; &amp;lt;value&amp;gt; &amp;lt;key&amp;gt; &amp;lt;value&amp;gt; ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Hash-map are &lt;em&gt;hash maps&lt;/em&gt; :)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They are efficient for key look-up, but&lt;/li&gt;
&lt;li&gt;they are potential memory intensive.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;hash-maps-1&#34;&gt;Hash-maps&lt;/h1&gt;

&lt;p&gt;Idiomatic Clojure prefers to use &lt;em&gt;keywords&lt;/em&gt; as keys.&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;It makes the code readable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Keyword lookup is also more efficient than strings.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;{:name   &amp;quot;Ken Pu&amp;quot;
 :office &amp;quot;UA4041&amp;quot;
 :role   :instructor}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sets&#34;&gt;Sets&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;#{ ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Duplicates are &lt;em&gt;not&lt;/em&gt; allowed.  Order doesn&amp;rsquo;t matter.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;(= #{3 2 1} #{1 2 3}) ; true
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;an-example&#34;&gt;An example&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;{:type &amp;quot;a relational database&amp;quot;
 :name &amp;quot;csci3055u assignments&amp;quot;
 :tuples [ {:name &amp;quot;assignment 1&amp;quot;
            :due-date (&amp;quot;October&amp;quot; 21 2016)
            :url &amp;quot;http://...&amp;quot;}

           {:name &amp;quot;assignment 2&amp;quot;
            :due-date (&amp;quot;November&amp;quot; 20 2016)
            :url &amp;quot;http://...&amp;quot;}

           {:name &amp;quot;assignment 3&amp;quot;
            :due-date (&amp;quot;December&amp;quot; 6 2016)
            :url nil}
         ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; A data value that describes a relational table.&lt;/p&gt;

&lt;h1 id=&#34;functional-programming-in-clojure&#34;&gt;Functional Programming in Clojure&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is really important.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t worry about the syntax.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Focus on the &lt;em&gt;way&lt;/em&gt; of read-only data.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;functional-programming-in-clojure-1&#34;&gt;Functional Programming in Clojure&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Data&lt;/em&gt; is (almost always) &lt;em&gt;immutable&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consider data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;{:name &amp;quot;Albert Einstein&amp;quot;
 :profession &amp;quot;Patent Clerk&amp;quot;
 :age 24
 :publication [&amp;quot;Relativity&amp;quot;
               &amp;quot;Speed of light&amp;quot;]}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How can we update the &lt;code&gt;:profession&lt;/code&gt; field, or age?&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;We cannot.&lt;/li&gt;
&lt;li&gt;Clojure only supports convenient ways for us to
to create a copy of the data with a modified &lt;code&gt;:profession&lt;/code&gt;
field.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;preview-of-what-s-to-come&#34;&gt;Preview of what&amp;rsquo;s to come&amp;hellip;&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(def person {:name &amp;quot;Albert Einstein&amp;quot;
             :profession &amp;quot;Patent Clerk&amp;quot;
             :age 24
             :publication [&amp;quot;Relativity&amp;quot;]})
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(assoc person :profession &amp;quot;Physicist&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note 5&#34;&gt;!&lt;/a&gt;
This does not change the person (as it cannot be changed - &lt;strong&gt;ever&lt;/strong&gt;).
Instead, &lt;code&gt;(assoc ...)&lt;/code&gt; creates a new clone with the delta change of setting
&lt;code&gt;:profession&lt;/code&gt; being &lt;code&gt;Physicist&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(update person :age inc)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note 5&#34;&gt;!&lt;/a&gt;
This makes a copy of &lt;code&gt;person&lt;/code&gt;, with the change of incremental &lt;code&gt;:age&lt;/code&gt; by &lt;strong&gt;one&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;functional-programming&#34;&gt;Functional programming&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Don&amp;rsquo;t worry about &amp;ldquo;waste&amp;rdquo; of memory (for now).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If you need to change data,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Make a copy of the data, but with the change applied.&lt;/p&gt;

&lt;p&gt;No procedures, only functions.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functional programming has many benefits&amp;hellip;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;programs-in-clojure&#34;&gt;Programs in Clojure&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;function-invocations&#34;&gt;Function invocations&lt;/h1&gt;

&lt;p&gt;General form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;( &amp;lt;fn&amp;gt; &amp;lt;arg&amp;gt; ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(list 1 2 3)
; (1 2 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;list&lt;/code&gt; constructs a list consisting of its arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(vector 1 2 3)
; [1 2 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;vector&lt;/code&gt; is like &lt;code&gt;list&lt;/code&gt;, but returns a vector.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(range 10)
; (0 1 2 3 4 5 6 7 8 9)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Returns a list of a sequence of number.&lt;/p&gt;

&lt;h1 id=&#34;function-invocation-aka-function-application&#34;&gt;Function invocation - aka function application&lt;/h1&gt;

&lt;p&gt;We are going to meet our first &lt;em&gt;higher order&lt;/em&gt; function: &lt;code&gt;apply&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(apply &amp;lt;func&amp;gt; &amp;lt;arg-list&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(&amp;lt;func&amp;gt; &amp;lt;arg&amp;gt; &amp;lt;arg&amp;gt; ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;function-declaration&#34;&gt;Function declaration&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn f [args...] body)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Binding a function to a symbol as in the global scope.&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(fn [args ...] body)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Creating an anonymous function.&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;#( ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Creating an anonymous function.  In the local scope, the input arguments are bound to the symbols &lt;code&gt;%1&lt;/code&gt;, &lt;code&gt;%2&lt;/code&gt;, etc.  If there is only one argument, then it&amp;rsquo;s bound to &lt;code&gt;%&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;function-declaration-1&#34;&gt;Function declaration&lt;/h1&gt;

&lt;p&gt;Recommended way:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn add [x y]
  (+ x y))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More indirect, but still quite readable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def add
  (fn [x y] (+ x y)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not recommended for this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(def add #(+ %1 %2))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Irresponsible show-off of deep knowledge of Clojure syntax can quickly turn into unreadable spaghetti code.&lt;/p&gt;

&lt;h1 id=&#34;more-on-function-declarations-variadic-arguments&#34;&gt;More on function declarations: variadic arguments&lt;/h1&gt;

&lt;p&gt;A function can have multiple versions:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn f
  ([arg] body)
  ([arg arg] body)
  ([arg arg arg] body))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A function can also have non-deterministic number of arguments, and bind all the arguments in an array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn f [arg arg &amp;amp; args] body)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; In the scope of &lt;code&gt;body&lt;/code&gt;, the symbol &lt;code&gt;args&lt;/code&gt; is bound to a list consisting of the third, fourth, fifth arguments, and so on.&lt;/p&gt;

&lt;h1 id=&#34;branching&#34;&gt;Branching&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(if &amp;lt;cond&amp;gt; &amp;lt;expr&amp;gt; &amp;lt;expr&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn larger [x y]
  (if (&amp;lt; x y) y x))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn largest [&amp;amp; xs]
  (if (= (count xs) 1)
    (first xs)
    (larger (first xs) (apply largest (rest xs)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;branching-case-by-case&#34;&gt;Branching: case by case&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(cond
  &amp;lt;cond&amp;gt; &amp;lt;expr&amp;gt;
  &amp;lt;cond&amp;gt; &amp;lt;expr&amp;gt;
  ...
  :else &amp;lt;expr&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn compare [x y]
  (cond
    (&amp;lt; x y) -1
    (&amp;gt; x y) 1
    :else   0))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;do-block&#34;&gt;DO block&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(do expr
    expr
    ...
    expr)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;Evaluates every expression in the &lt;code&gt;(do ...)&lt;/code&gt; form.  The &lt;code&gt;(do ...)&lt;/code&gt; form
evaluates to the last expression.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def x (do (println &amp;quot;Hello there.&amp;quot;)
           (+ 1 2 3)))
; 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;iteration-a-first-look&#34;&gt;Iteration: a first look&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(for [i expr] body)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;expr&lt;/code&gt; must evaluate to a sequence of elements.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; is the symbol that exists in the scope of &lt;code&gt;body&lt;/code&gt;.  It is bound to elements in &lt;code&gt;expr&lt;/code&gt; during each iteration.&lt;/li&gt;
&lt;li&gt;At each iteration &lt;code&gt;body&lt;/code&gt; is evaluated.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;(for ...)&lt;/code&gt; is an expression.  It is evaluated to a &lt;em&gt;lazy&lt;/em&gt; sequence, consisting of elements of each evaluation of &lt;code&gt;body&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;for-loop&#34;&gt;For-loop&lt;/h1&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(for [i (range 10)]
  (str &amp;quot;Hi, this is the &amp;quot; i &amp;quot;th iteration.&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;for-loop-super-charged&#34;&gt;For-loop super charged&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(for [sym seq-expr :when cond :while cond] body)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;:when cond&lt;/code&gt; causes the &lt;code&gt;for&lt;/code&gt; iteration to evaluate &lt;code&gt;body&lt;/code&gt; only when the
condition is true.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;:while cond&lt;/code&gt; causes the &lt;code&gt;for&lt;/code&gt; iteration to terminate when the conditon
becomes false.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm clipboard&#34;&gt;(for [x (range 100)
      y (range 100)
      :when (= (+ x y) 42)]
  (println x y))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;more-iterations&#34;&gt;More iterations:&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(doseq [i expr] body)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;It is very similar to &lt;code&gt;(for [i expr] body)&lt;/code&gt;, but it&amp;rsquo;s non-functional.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(doseq ...)&lt;/code&gt; iterates over &lt;code&gt;expr&lt;/code&gt;, and evaluates &lt;code&gt;body&lt;/code&gt; for each iteration.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; But the result of each evaluation is &lt;strong&gt;THROWN AWAY&lt;/strong&gt;&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;more-iterations-1&#34;&gt;More iterations&lt;/h1&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(dotimes [i n] body)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is equivalent to:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(doseq [i (range n)] body)
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Data in Clojure&lt;/li&gt;
&lt;li&gt;Functions&lt;/li&gt;
&lt;li&gt;Branch&lt;/li&gt;
&lt;li&gt;Iteration&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Things to come:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Data structural transformations&lt;/li&gt;
&lt;li&gt;Sequences and lazy evaluation&lt;/li&gt;
&lt;li&gt;Looping through recursion&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>