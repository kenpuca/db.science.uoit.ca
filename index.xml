<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>db@uoit</title>
    <link>http://db.science.uoit.ca/index.xml</link>
    <description>Recent content on db@uoit</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Nov 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://db.science.uoit.ca/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Programming languages &amp; Concurrency</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/concurrency/</link>
      <pubDate>Tue, 22 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/concurrency/</guid>
      <description>

&lt;h1 id=&#34;programming-languages-concurrency&#34;&gt;Programming Languages &amp;amp; Concurrency&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Scaling from single-core to multi-core to multiple hundreds of cores.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;--------------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;float:right&#34;&gt;
Ken Pu &lt;br&gt;
UOIT, 2016
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;elements-of-computation&#34;&gt;Elements of Computation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU as a function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory as persistent state.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Programming languages are designed to communicate:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Types&lt;/strong&gt;: Format and interpretation of memory content.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Expressions&lt;/strong&gt;: Description of computations to be carried out.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; Today, we will examine the &lt;em&gt;expressions&lt;/em&gt; that support concurrent
programming.&lt;/p&gt;

&lt;h1 id=&#34;programming-paradigm&#34;&gt;Programming paradigm&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Imperative programming:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A programming paradigm that makes the distinction
between &lt;em&gt;statements&lt;/em&gt; and &lt;em&gt;expressions&lt;/em&gt;.  Statements modify the state of
its runtime environment, while expressions use certain existing values to
evaluate another value.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functional programming:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A programming paradigm that forbiddens modification of existing values.
All values are created once, and remain read-only.  Functions and data are
unified, known as &lt;em&gt;functions as data&lt;/em&gt;.  State of the runtime is modeled
not by data (in the sense of imperative programming), but rather one or
more functions.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Modern languages are designed with features supporting both paradigms.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; But what about &lt;em&gt;Object-oriented&lt;/em&gt; programming paradigm?&lt;/p&gt;

&lt;h1 id=&#34;concurrency&#34;&gt;Concurrency&lt;/h1&gt;

&lt;p&gt;First of all, &lt;em&gt;concurrency is not parallism&lt;/em&gt;.
&lt;a href=&#34;https://talks.golang.org/2012/waza.slide#1&#34;&gt;1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s the distinction?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Concurrency is about the &lt;em&gt;programming&lt;/em&gt; constructs that allow &lt;em&gt;programmers&lt;/em&gt; to
compose multiple interdependent (but non-sequential) units of computation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallelism is about &lt;em&gt;executing&lt;/em&gt; units of computation using multiple
interdependent processors.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Parallelism&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Multi-core&lt;/li&gt;
&lt;li&gt;Cluster&lt;/li&gt;
&lt;li&gt;The Internet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Concurrency&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Code constructs (threads, goroutines, channels, futures, promises, async,
scatter-gather, &amp;hellip;)&lt;/li&gt;
&lt;li&gt;Even single-core, one-process program can be &lt;em&gt;concurrent&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;concurrency-supset-parallelism&#34;&gt;Concurrency $\supset$ Parallelism&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrency is about &lt;em&gt;programming&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concurrency is about a way to &lt;em&gt;think&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concurrent programming is to adapt to the ever increasing parallel runtime
environments.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;                    +------------------------+
                    | Concurrent Programming |
                    +-----------+------------+
                                |
      +--------------+----------+-----+------------------+
      |              |                |                  |
      |              |                |                  |
+----------+    +----------+   +-------------+   +-----------------+
| IPHONE   |    | ANDROID  |   | Desktop     |   | Cluster         |
| 2 cores  |    | 4 cores  |   | 16-32 cores |   | ~500-1000 cores |
+----------+    +----------+   +-------------+   +-----------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;concurrent-programming&#34;&gt;Concurrent programming&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrent programming is not an extention of imperative programming.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java&amp;rsquo;s threading model is fundamentally prohibitive from a programmer&amp;rsquo;s
perspective.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-composition&#34;&gt;Computation &amp;amp; Composition&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Composition&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(x)
let z = h(y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let z = h(g(f(...)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;No concurrency.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Independent computation&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(...)
let z = h(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can evaluate &lt;code&gt;f, g&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; on separate processors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;spawn { x = f(...) }
spawn { y = g(...) }
spawn { z = h(...) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;_________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Partial composition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x = f(...)
let y = g(...)
let z = h(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can evaluate &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; on separate processors, and use the results to
evaluate &lt;code&gt;h&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x = result of spawn { f(...) }
y = result of spawn { g(...) }

wait-for-all(x, y) as (x, y) {
    z = h(x, y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;____________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Partial composition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(...)
let z = x or y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x = result of spawn { f(...) }
y = result of spawn { g(...) }

wait-for-any(x, y) as (u) {
    z = u
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Transaction&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions may &lt;em&gt;fail&lt;/em&gt; to complete, and result in error.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Transaction:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;snapshot()
h(g(f(...)))

if error:
  reverse back to snapshot()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;transaction {
    f()
    g()
    h()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;_______________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Data exchange&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Long running functions that require data from one another mutually
recursively.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;F() {
  get x from G
  send x&#39; back to G
  ...
}

G() {
  send x to F
  get x&#39; from F
  ...
}

spawn F()
spawn G()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We can have multi-way data exchange among multiple long running
functions.&lt;/p&gt;

&lt;h1 id=&#34;let-s-get-practical&#34;&gt;Let&amp;rsquo;s get &lt;em&gt;practical&lt;/em&gt; ✌&lt;/h1&gt;

&lt;p&gt;Multicore&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1) Go&lt;/p&gt;

&lt;p&gt;2) Clojure&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Hundreds of cores&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;3) RabbitMQ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;go-independent-computation&#34;&gt;Go: independent computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func is_prime(n int64) bool {
    for(i := 2; i &amp;lt; n; i++) {
        if n % i == 0 {
            return false
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compute the 1000th prime number.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func is_perfect(n int64) bool {
    var total int64 = 0
    for i := int64(1); i &amp;lt; n; i++ {
        if n % i == 0 {
            total += i
        }
    }
    return total == n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compute the 4th perfect number.&lt;/p&gt;

&lt;h1 id=&#34;toc_14&#34;&gt;__________________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func nth_prime(nth int) int64 {
    found := 0
    var n int64
    for n = 2; found &amp;lt; nth; i++ {
        if is_prime(n) {
            found += 1
        }
    }

    if found == nth {
        prime_1000 = n
    }
}

ans1 := nth_prime(1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do some refactoring so we can reuse the code for the 4th perfect number.&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;______________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func look_for(predicate func(int64) bool, nth int) {
    found := 0
    var n int64
    for n = 2; found &amp;lt; nth; i++ {
        if predicate(n) {
            found += 1
        }
    }
    if found == nth {
        return n
    } else {
        return 0
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;__________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var prime_1000 int
var perfect_4 int

go func() {
    prime_1000 = look_for(is_prime, 1000)
}()

go func() {
    perfect_4 = look_for(is_perfect, 4)
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-independent-computation&#34;&gt;Clojure: Independent computation&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn prime? [n]
  (every? #(not (zero? (mod n %1))) (range 2 n)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn perfect? [n]
  (let [factors (filter #(zero? (mod n %)) (range 1 n))]
    (= n (reduce + 0 factors))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn look-for [pred n]
  (nth (filter pred (iterate inc 2)) n))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_18&#34;&gt;_______________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def prime-1000 (future (look-for prime? 1000)))

(def perfect-4  (future (look-for perfect? 4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
&lt;code&gt;(future ...)&lt;/code&gt; evaluates the expression in the background.  When it&amp;rsquo;s complete,
the result is saved in the &lt;em&gt;reference&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;partial-composition&#34;&gt;Partial composition&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Problem to solve&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;Find the sum of the 1000-th prime and the 4th perfect number.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Solutions&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Goroutine &amp;amp; channels&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clojure futures and deref of futures&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;goroutine-and-channels&#34;&gt;Goroutine and channels&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;We have already seen goroutines:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;go f(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Channels are native type in Go.  You can send &lt;em&gt;anything&lt;/em&gt; over a channel.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var ch = make(chan int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Create a bi-directional channel for exchanging integers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var i int = &amp;lt;- ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Read an integer from the channel.  If nothing is in the channel, this
will block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;ch &amp;lt;- 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Writes an integer into the channel.&lt;/p&gt;

&lt;h1 id=&#34;toc_21&#34;&gt;______________________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm nu&#34;&gt;func computation() int64 {
    var ch chan int64 = make(chan int64)

    go func() {
        p := look_for(is_prime, 1000)
        ch &amp;lt;- p
    }()

    go func() {
        q := look_for(is_perfect, 4)
        ch &amp;lt;- q
    }()

    result := (&amp;lt;-ch) + (&amp;lt;-ch)
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Line 14. blocks until both prime/perfect numbers are computed.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-solution&#34;&gt;Clojure&amp;rsquo;s solution&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def prime-1000 (future (look-for prime? 1000)))
(def perfect-4  (future (look-for perfect? 4)))
(println (+ (deref prime-1000) (deref perfect-4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
&lt;code&gt;deref&lt;/code&gt; blocks until the result of the &lt;code&gt;future&lt;/code&gt;s are available, and returns the
result.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Here is a more functional style:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(let [a (future (look-for prime? 1000))
      b (future (look-for perfect? 4))
      result (+ @a @b)]
  (println result))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;partial-composition-1&#34;&gt;Partial composition&lt;/h1&gt;

&lt;p&gt;Now, let&amp;rsquo;s consider a different problem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute either the 1000th prime, or the 4th perfect number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The strategy is to concurrently evaluate both computations, and as soon as one
is done, return it.&lt;/p&gt;

&lt;h1 id=&#34;go-s-channel-selection&#34;&gt;Go&amp;rsquo;s channel selection&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;select {
case v1 = &amp;lt;- ch1:
    ...
case v2 = &amp;lt;- ch2:
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
This tries to read from &lt;code&gt;ch1&lt;/code&gt; or &lt;code&gt;ch2&lt;/code&gt;, and it guarantees to read only at most one of
them.  If both channels are empty, then &lt;code&gt;default&lt;/code&gt; case is evaluated.&lt;/p&gt;

&lt;h1 id=&#34;go-s-solution-using-select&#34;&gt;Go&amp;rsquo;s solution using &lt;code&gt;select&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func async_look_for(cond func(int64) bool, nth int) chan int64 {
    ch := make(chan int64)
    go func() {
        ch&amp;lt;- look_for(cond, nth)
    }()
    return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; Pretty cool.  Instead of returning the result, we wrap the result in a
channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func computation() int64 {
    result1 := async_look_for(is_prime, 1000)
    result2 := async_look_for(is_perfect, 4)

    var answer int64
    select {
    case answer = &amp;lt;-result1:
    case answer = &amp;lt;-result2:
    }
    return answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; The &lt;code&gt;select { ... }&lt;/code&gt; will block until the first prime/perfect number
is computed.&lt;/p&gt;

&lt;h1 id=&#34;go-s-solution-using-pure-channel-operations&#34;&gt;Go&amp;rsquo;s solution using pure channel operations&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func async_look_for(cond func(int64) bool, nth int, results chan int64) {
    ch := make(chan int64)
    go func() {
        results&amp;lt;- look_for(cond, nth)
    }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func computation() {
    results = chan int64

    async_look_for(is_prime, 1000, results)
    async_look_for(is_perfect, 4, results)

    answer := &amp;lt;-results
    close(results)
    return answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We pass a channel into &lt;code&gt;async_look_for&lt;/code&gt; to collect their results of
computation.  As soon as one result appears in the channel, we are done.&lt;/p&gt;

&lt;h1 id=&#34;conclusion-for-go&#34;&gt;Conclusion for Go:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Channels + Goroutines = Really powerful and universal solution&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is called the &lt;em&gt;Communicating Sequential Processes&lt;/em&gt; (CSP)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;clojure-s-csp&#34;&gt;Clojure&amp;rsquo;s CSP&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;(require &#39;[clojure.core.async :as async :refer :all])&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(go ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Starts a go-routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(chan)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Constructs a bi-directional channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(&amp;lt;! ch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Read one value from the channel.  It blocks in the go-routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(&amp;gt;! ch x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Writes one value into the channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(close! ch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Closes the channel.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-solution-using-alt&#34;&gt;Clojure&amp;rsquo;s solution - using alt!&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [[val ch] (alt! [ch1 ch2 ...])]
    ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;alt!&lt;/code&gt; blocks until one of the channels receives some value.
Returns the value and the channel it comes from.&lt;/p&gt;

&lt;p&gt;There are two version:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alt!&lt;/code&gt; is used in a go-routine.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt!!&lt;/code&gt; is used in the context of an actual thread.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_30&#34;&gt;___________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn async-look-for [pred n]
  (let [ch (chan)]
    (go (&amp;gt;! ch (look-for pred n)))
    ch))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn computation []
  (let [ch1 (async-look-for prime? 1000)
        ch2 (async-look-for perfect? 4)]
    (let [ans ch] (alt!! [ch1 ch2])
      ans)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-s-solution-using-pure-channel-operations&#34;&gt;Clojure&amp;rsquo;s solution - using pure channel operations&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn async-look-for [pred n results]
  (go (&amp;gt;! results (look-for pred n))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn computation []
  (let [ch (chan)]
    (future
      (do (async-look-for prime? 1000 ch)
          (async-look-for perfect? 4 ch)))
    (let [ans (&amp;lt;!! ch)]
      (close! ch)
      ans)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Clojure already had a rich set of concurrency constructs (2007-2015).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CSP is so successful as a model to express concurrency compositions that
Clojure added support for CSP, and it is the preferred way.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;scaling-to-multiple-machines&#34;&gt;Scaling to multiple machines&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s revisit CSP:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Go routines&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Channels&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We just need to implement go-routines and channels over the network.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;go-routines = processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;channels = message queues&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;introducing-rabbitmq&#34;&gt;Introducing RabbitMQ&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;rabbitmq.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Provides queueing service as a standalone server, or a server cluster.&lt;/p&gt;

&lt;h1 id=&#34;message-queues-are-channels-between-machines&#34;&gt;Message queues are channels between machines&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;rmq-example.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;discovering-primes&#34;&gt;Discovering primes&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn feed []
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;input-queue&amp;quot;]
    (doseq [i (iterate inc 0)]
      (publish ch queue i))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Places all numbers on the queue called &lt;em&gt;input-queue&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_37&#34;&gt;___________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def output
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;output-queue&amp;quot;]
    {:ch ch
     :queue queue}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Declare the queue that will gather the answers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn task []
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;input-queue&amp;quot;]
    (subscribe ch queue 
            (fn [i] (when (__prime__? i)
                      (publish output i))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Get a job, &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Performs the computation &lt;code&gt;(prime? i)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If we get a prime, send it to the output queue.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt; (defn worker []
  (dotimes [i 32] (future (task))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; start 32 concurrent sessions to do the tasks assuming we have 32 cores.&lt;/p&gt;

&lt;h1 id=&#34;toc_38&#34;&gt;_____________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## Start the job feeder
nohup clojure feed.clj &amp;amp;

## start the remote workers
for m in $machines
do
    ssh $m nohup clojure worker.clj
done

## Subscribe to output queue, and save to database
nohup clojure result-to-db.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;$machine&lt;/code&gt; may have 100 AWS instances = $32\times 100 = 3,200$ cores.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Programming languages &amp; Concurrency</title>
      <link>http://db.science.uoit.ca/writings/concurrency/</link>
      <pubDate>Tue, 22 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/writings/concurrency/</guid>
      <description>

&lt;h1 id=&#34;programming-languages-concurrency&#34;&gt;Programming Languages &amp;amp; Concurrency&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Scaling from single-core to multi-core to multiple hundreds of cores.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;--------------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=&#34;float:right&#34;&gt;
Ken Pu &lt;br&gt;
UOIT, 2016
&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;elements-of-computation&#34;&gt;Elements of Computation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CPU as a function.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Memory as persistent state.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Programming languages are designed to communicate:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Types&lt;/strong&gt;: Format and interpretation of memory content.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Expressions&lt;/strong&gt;: Description of computations to be carried out.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; Today, we will examine the &lt;em&gt;expressions&lt;/em&gt; that support concurrent
programming.&lt;/p&gt;

&lt;h1 id=&#34;programming-paradigm&#34;&gt;Programming paradigm&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Imperative programming:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A programming paradigm that makes the distinction
between &lt;em&gt;statements&lt;/em&gt; and &lt;em&gt;expressions&lt;/em&gt;.  Statements modify the state of
its runtime environment, while expressions use certain existing values to
evaluate another value.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Functional programming:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A programming paradigm that forbiddens modification of existing values.
All values are created once, and remain read-only.  Functions and data are
unified, known as &lt;em&gt;functions as data&lt;/em&gt;.  State of the runtime is modeled
not by data (in the sense of imperative programming), but rather one or
more functions.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Modern languages are designed with features supporting both paradigms.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; But what about &lt;em&gt;Object-oriented&lt;/em&gt; programming paradigm?&lt;/p&gt;

&lt;h1 id=&#34;concurrency&#34;&gt;Concurrency&lt;/h1&gt;

&lt;p&gt;First of all, &lt;em&gt;concurrency is not parallism&lt;/em&gt;.
&lt;a href=&#34;https://talks.golang.org/2012/waza.slide#1&#34;&gt;1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s the distinction?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Concurrency is about the &lt;em&gt;programming&lt;/em&gt; constructs that allow &lt;em&gt;programmers&lt;/em&gt; to
compose multiple interdependent (but non-sequential) units of computation.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Parallelism is about &lt;em&gt;executing&lt;/em&gt; units of computation using multiple
interdependent processors.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Parallelism&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Multi-core&lt;/li&gt;
&lt;li&gt;Cluster&lt;/li&gt;
&lt;li&gt;The Internet&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Concurrency&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Code constructs (threads, goroutines, channels, futures, promises, async,
scatter-gather, &amp;hellip;)&lt;/li&gt;
&lt;li&gt;Even single-core, one-process program can be &lt;em&gt;concurrent&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;concurrency-supset-parallelism&#34;&gt;Concurrency $\supset$ Parallelism&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrency is about &lt;em&gt;programming&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concurrency is about a way to &lt;em&gt;think&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Concurrent programming is to adapt to the ever increasing parallel runtime
environments.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;                    +------------------------+
                    | Concurrent Programming |
                    +-----------+------------+
                                |
      +--------------+----------+-----+------------------+
      |              |                |                  |
      |              |                |                  |
+----------+    +----------+   +-------------+   +-----------------+
| IPHONE   |    | ANDROID  |   | Desktop     |   | Cluster         |
| 2 cores  |    | 4 cores  |   | 16-32 cores |   | ~500-1000 cores |
+----------+    +----------+   +-------------+   +-----------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;concurrent-programming&#34;&gt;Concurrent programming&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Concurrent programming is not an extention of imperative programming.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java&amp;rsquo;s threading model is fundamentally prohibitive from a programmer&amp;rsquo;s
perspective.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-composition&#34;&gt;Computation &amp;amp; Composition&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Composition&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(x)
let z = h(y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let z = h(g(f(...)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;No concurrency.&lt;/p&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Independent computation&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(...)
let z = h(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can evaluate &lt;code&gt;f, g&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; on separate processors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;spawn { x = f(...) }
spawn { y = g(...) }
spawn { z = h(...) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_8&#34;&gt;_________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Partial composition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-rust&#34;&gt;let x = f(...)
let y = g(...)
let z = h(x, y)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We can evaluate &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; on separate processors, and use the results to
evaluate &lt;code&gt;h&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x = result of spawn { f(...) }
y = result of spawn { g(...) }

wait-for-all(x, y) as (x, y) {
    z = h(x, y)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;____________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Partial composition&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x = f(...)
let y = g(...)
let z = x or y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;x = result of spawn { f(...) }
y = result of spawn { g(...) }

wait-for-any(x, y) as (u) {
    z = u
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_10&#34;&gt;________________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Transaction&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions may &lt;em&gt;fail&lt;/em&gt; to complete, and result in error.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Transaction:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;snapshot()
h(g(f(...)))

if error:
  reverse back to snapshot()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;transaction {
    f()
    g()
    h()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_11&#34;&gt;_______________________&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Data exchange&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Long running functions that require data from one another mutually
recursively.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;***&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;F() {
  get x from G
  send x&#39; back to G
  ...
}

G() {
  send x to F
  get x&#39; from F
  ...
}

spawn F()
spawn G()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We can have multi-way data exchange among multiple long running
functions.&lt;/p&gt;

&lt;h1 id=&#34;let-s-get-practical&#34;&gt;Let&amp;rsquo;s get &lt;em&gt;practical&lt;/em&gt; ✌&lt;/h1&gt;

&lt;p&gt;Multicore&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1) Go&lt;/p&gt;

&lt;p&gt;2) Clojure&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Hundreds of cores&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;3) RabbitMQ&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;go-independent-computation&#34;&gt;Go: independent computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func is_prime(n int64) bool {
    for(i := 2; i &amp;lt; n; i++) {
        if n % i == 0 {
            return false
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compute the 1000th prime number.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func is_perfect(n int64) bool {
    var total int64 = 0
    for i := int64(1); i &amp;lt; n; i++ {
        if n % i == 0 {
            total += i
        }
    }
    return total == n
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compute the 4th perfect number.&lt;/p&gt;

&lt;h1 id=&#34;toc_14&#34;&gt;__________________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func nth_prime(nth int) int64 {
    found := 0
    var n int64
    for n = 2; found &amp;lt; nth; i++ {
        if is_prime(n) {
            found += 1
        }
    }

    if found == nth {
        prime_1000 = n
    }
}

ans1 := nth_prime(1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s do some refactoring so we can reuse the code for the 4th perfect number.&lt;/p&gt;

&lt;h1 id=&#34;toc_15&#34;&gt;______________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm clipboard&#34;&gt;func look_for(predicate func(int64) bool, nth int) {
    found := 0
    var n int64
    for n = 2; found &amp;lt; nth; i++ {
        if predicate(n) {
            found += 1
        }
    }
    if found == nth {
        return n
    } else {
        return 0
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_16&#34;&gt;__________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var prime_1000 int
var perfect_4 int

go func() {
    prime_1000 = look_for(is_prime, 1000)
}()

go func() {
    perfect_4 = look_for(is_perfect, 4)
}()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-independent-computation&#34;&gt;Clojure: Independent computation&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn prime? [n]
  (every? #(not (zero? (mod n %1))) (range 2 n)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn perfect? [n]
  (let [factors (filter #(zero? (mod n %)) (range 1 n))]
    (reduce + 0 factors)))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn look-for [pred n]
  (nth (filter pred (iterate inc 2)) n))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_18&#34;&gt;_______________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def prime-1000 (future (look-for prime? 1000)))

(def perfect-4  (future (look-for perfect? 4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
&lt;code&gt;(future ...)&lt;/code&gt; evaluates the expression in the background.  When it&amp;rsquo;s complete,
the result is saved in the &lt;em&gt;reference&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;partial-composition&#34;&gt;Partial composition&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Problem to solve&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;Find the sum of the 1000-th prime and the 4th perfect number.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Solutions&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Goroutine &amp;amp; channels&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clojure futures and deref of futures&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;goroutine-and-channels&#34;&gt;Goroutine and channels&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;We have already seen goroutines:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;go f(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Channels are native type in Go.  You can send &lt;em&gt;anything&lt;/em&gt; over a channel.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var ch = make(chan int)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Create a bi-directional channel for exchanging integers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;var i int = &amp;lt;- ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Read an integer from the channel.  If nothing is in the channel, this
will block.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;ch &amp;lt;- 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Writes an integer into the channel.&lt;/p&gt;

&lt;h1 id=&#34;toc_21&#34;&gt;______________________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm nu&#34;&gt;func computation() int64 {
    var ch chan int64 = make(chan int64)

    go func() {
        p := look_for(is_prime, 1000)
        ch &amp;lt;- p
    }()

    go func() {
        q := look_for(is_perfect, 4)
        ch &amp;lt;- q
    }()

    result := (&amp;lt;-ch) + (&amp;lt;-ch)
    return result
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Line 14. blocks until both prime/perfect numbers are computed.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-solution&#34;&gt;Clojure&amp;rsquo;s solution&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def prime-1000 (future (look-for prime? 1000)))
(def perfect-4  (future (look-for perfect? 4)))
(println (+ (deref prime-1000) (deref perfect-4)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
&lt;code&gt;deref&lt;/code&gt; blocks until the result of the &lt;code&gt;future&lt;/code&gt;s are available, and returns the
result.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Here is a more functional style:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(let [a (future (look-for prime? 1000))
      b (future (look-for perfect? 4))
      result (+ @a @b)]
  (println result))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;partial-composition-1&#34;&gt;Partial composition&lt;/h1&gt;

&lt;p&gt;Now, let&amp;rsquo;s consider a different problem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Compute either the 1000th prime, or the 4th perfect number.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The strategy is to concurrently evaluate both computations, and as soon as one
is done, return it.&lt;/p&gt;

&lt;h1 id=&#34;go-s-channel-selection&#34;&gt;Go&amp;rsquo;s channel selection&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;select {
case v1 = &amp;lt;- ch1:
    ...
case v2 = &amp;lt;- ch2:
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
This tries to read from &lt;code&gt;ch1&lt;/code&gt; or &lt;code&gt;ch2&lt;/code&gt;, and it guarantees to read only at most one of
them.  If both channels are empty, then &lt;code&gt;default&lt;/code&gt; case is evaluated.&lt;/p&gt;

&lt;h1 id=&#34;go-s-solution-using-select&#34;&gt;Go&amp;rsquo;s solution using &lt;code&gt;select&lt;/code&gt;&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func async_look_for(cond func(int64) bool, nth int) chan int64 {
    ch := make(chan int64)
    go func() {
        ch&amp;lt;- look_for(cond, nth)
    }()
    return ch
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; Pretty cool.  Instead of returning the result, we wrap the result in a
channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func computation() int64 {
    result1 := async_look_for(is_prime, 1000)
    result2 := async_look_for(is_perfect, 4)

    var answer int64
    select {
    case answer = &amp;lt;-result1:
    case answer = &amp;lt;-result2:
    }
    return answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note 3&#34;&gt;!&lt;/a&gt; The &lt;code&gt;select { ... }&lt;/code&gt; will block until the first prime/perfect number
is computed.&lt;/p&gt;

&lt;h1 id=&#34;go-s-solution-using-pure-channel-operations&#34;&gt;Go&amp;rsquo;s solution using pure channel operations&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func async_look_for(cond func(int64) bool, nth int, results chan int64) {
    ch := make(chan int64)
    go func() {
        results&amp;lt;- look_for(cond, nth)
    }()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go sm&#34;&gt;func computation() {
    results = chan int64

    async_look_for(is_prime, 1000, results)
    async_look_for(is_perfect, 4, results)

    answer := &amp;lt;-results
    close(results)
    return answer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We pass a channel into &lt;code&gt;async_look_for&lt;/code&gt; to collect their results of
computation.  As soon as one result appears in the channel, we are done.&lt;/p&gt;

&lt;h1 id=&#34;conclusion-for-go&#34;&gt;Conclusion for Go:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Channels + Goroutines = Really powerful and universal solution&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;This is called the &lt;em&gt;Communicating Sequential Processes&lt;/em&gt; (CSP)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;clojure-s-csp&#34;&gt;Clojure&amp;rsquo;s CSP&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;(require &#39;[clojure.core.async :as async :refer :all])&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(go ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Starts a go-routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(chan)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Constructs a bi-directional channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(&amp;lt;! ch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Read one value from the channel.  It blocks in the go-routine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(&amp;gt;! ch x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Writes one value into the channel.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(close! ch)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Closes the channel.&lt;/p&gt;

&lt;h1 id=&#34;clojure-s-solution-using-alt&#34;&gt;Clojure&amp;rsquo;s solution - using alt!&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(let [[val ch] (alt! [ch1 ch2 ...])]
    ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;alt!&lt;/code&gt; blocks until one of the channels receives some value.
Returns the value and the channel it comes from.&lt;/p&gt;

&lt;p&gt;There are two version:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alt!&lt;/code&gt; is used in a go-routine.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alt!!&lt;/code&gt; is used in the context of an actual thread.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toc_30&#34;&gt;___________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn async-look-for [pred n]
  (let [ch (chan)]
    (go (&amp;gt;! ch (look-for pred n)))
    ch))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn computation []
  (let [ch1 (async-look-for prime? 1000)
        ch2 (async-look-for perfect? 4)]
    (let [ans ch] (alt!! [ch1 ch2])
      ans)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;clojure-s-solution-using-pure-channel-operations&#34;&gt;Clojure&amp;rsquo;s solution - using pure channel operations&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn async-look-for [pred n results]
  (go (&amp;gt;! results (look-for pred n))))
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn computation []
  (let [ch (chan)]
    (future
      (do (async-look-for prime? 1000 ch)
          (async-look-for perfect? 4 ch)))
    (let [ans (&amp;lt;!! ch)]
      (close! ch)
      ans)))
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Clojure already had a rich set of concurrency constructs (2007-2015).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CSP is so successful as a model to express concurrency compositions that
Clojure added support for CSP, and it is the preferred way.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;scaling-to-multiple-machines&#34;&gt;Scaling to multiple machines&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s revisit CSP:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Go routines&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Channels&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We just need to implement go-routines and channels over the network.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;go-routines = processes&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;channels = message queues&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;introducing-rabbitmq&#34;&gt;Introducing RabbitMQ&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;rabbitmq.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Provides queueing service as a standalone server, or a server cluster.&lt;/p&gt;

&lt;h1 id=&#34;message-queues-are-channels-between-machines&#34;&gt;Message queues are channels between machines&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;rmq-example.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;discovering-primes&#34;&gt;Discovering primes&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn feed []
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;input-queue&amp;quot;]
    (doseq [i (iterate inc 0)]
      (publish ch queue i))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Places all numbers on the queue called &lt;em&gt;input-queue&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&#34;toc_37&#34;&gt;___________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(def output
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;output-queue&amp;quot;]
    {:ch ch
     :queue queue}))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; Declare the queue that will gather the answers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt;(defn task []
  (let [server (connect connection-info)
        ch (open server)
        queue &amp;quot;input-queue&amp;quot;]
    (subscribe ch queue 
            (fn [i] (when (__prime__? i)
                      (publish output i))))))
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Get a job, &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Performs the computation &lt;code&gt;(prime? i)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If we get a prime, send it to the output queue.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure sm&#34;&gt; (defn worker []
  (dotimes [i 32] (future (task))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; start 32 concurrent sessions to do the tasks assuming we have 32 cores.&lt;/p&gt;

&lt;h1 id=&#34;toc_38&#34;&gt;_____________________&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## Start the job feeder
nohup clojure feed.clj &amp;amp;

## start the remote workers
for m in $machines
do
    ssh $m nohup clojure worker.clj
done

## Subscribe to output queue, and save to database
nohup clojure result-to-db.clj
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; &lt;code&gt;$machine&lt;/code&gt; may have 100 AWS instances = $32\times 100 = 3,200$ cores.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Symposium</title>
      <link>http://db.science.uoit.ca/slides/talks/symposium-on-teaching/</link>
      <pubDate>Thu, 01 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/slides/talks/symposium-on-teaching/</guid>
      <description>

&lt;h1 id=&#34;instant-gratification&#34;&gt;Instant gratification&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p style=text-align:right&gt;
&lt;i&gt;Ken Pu&lt;/i&gt; &lt;br&gt;

September 1, 2016 &lt;br&gt;

Symposium on teaching
&lt;/p&gt;

&lt;h1 id=&#34;tl-tr&#34;&gt;TL;TR&lt;/h1&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Instant gratification is a powerful equalizer
&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instant gratification is dangerous
&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Technology is almost there
&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Yes, you can use it now&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;the-equalizer&#34;&gt;The Equalizer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-equalizer-1&#34;&gt;The equalizer (1)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:2:5&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;fragment&#34; src=&#34;degrasse.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=margin-top:200px;font-size:500%&gt;=&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;fragment&#34; src=&#34;Instant-Gratification.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;the-equalizer-2&#34;&gt;The equalizer (2)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 10:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;engineer.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Google Engineer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=font-size:500%&gt;=&lt;/div&gt;

&lt;h1 id=&#34;the-equalizer-2-1&#34;&gt;The equalizer (2)&lt;/h1&gt;

&lt;p&gt;&lt;img style=height:500px src=&#34;women-in-cs.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;example-1&#34;&gt;Example (1)&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Finding the courses I teach.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql sm clipboard&#34;&gt;select distinct code, title from schedule where instructor like &amp;quot;Ken Pu&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;iframe class=fragment data-src=&#34;http://db.science.uoit.ca:8080&#34; style=&#34;max-width:1024px; width:100%; height:400px&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;example-2&#34;&gt;Example (2)&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Anything that is early in the morning?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql sm clipboard&#34;&gt;select distinct code, title, weekday, starthour || &amp;quot;:&amp;quot; || startmin as t from schedule
where starthour &amp;lt; 9 and instructor like &amp;quot;Ken Pu&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;iframe data-src=&#34;http://db.science.uoit.ca:8080&#34; style=&#34;max-width:1024px; width:100%; height:300px&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;example-3&#34;&gt;Example (3)&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Can I find an empty room?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql sm clipboard&#34;&gt;with R(room, weekday, t) as (
    select distinct room, weekday, min(starthour) from schedule where room like &#39;% A1 %&#39; and weekday = &amp;quot;T&amp;quot; group by room order by room
) select * from R where t &amp;gt;= 10;
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;iframe data-src=&#34;http://db.science.uoit.ca:8080&#34; style=&#34;max-width:1024px; width:100%; height:300px&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;on-the-distribution-of-primes&#34;&gt;On the distribution of primes&lt;/h1&gt;

&lt;iframe class=fragment data-src=&#34;http://db.science.uoit.ca:3000/notebooks/HelloWorld.ipynb&#34; style=&#34;max-width:1024px; width:100%; height:500px&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;data-science-visualization&#34;&gt;Data Science &amp;amp; Visualization&lt;/h1&gt;

&lt;iframe data-src=&#34;http://db.science.uoit.ca:3000/notebooks/DataScience.ipynb&#34; style=&#34;max-width:1024px; width:100%; height:500px&#34;&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;the-danger&#34;&gt;The Danger&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;danger-of-instant-gratification&#34;&gt;Danger of instant gratification&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;claim&#34;&gt;Claim:&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;We just covered the following topics&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Data analysis using relational query language&lt;/li&gt;
&lt;li&gt;Python list comprehension&lt;/li&gt;
&lt;li&gt;Numerical approximation of the distribution of the primes&lt;/li&gt;
&lt;li&gt;Visualization of potential fields&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;div style=height:150px&gt;&lt;/div&gt;

&lt;h2 id=&#34;reality-zero-working-knowledge-even-after-hands-on-practice&#34;&gt;Reality: &lt;em&gt;Zero working knowledge&lt;/em&gt; even after hands on practice!&lt;/h2&gt;

&lt;h1 id=&#34;instant-gratification-br-for-the-instructors&#34;&gt;Instant gratification &lt;br&gt; for the instructors&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;don-t-discount-google-education-app&#34;&gt;Don&amp;rsquo;t discount Google Education App&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;UOIT is paying for it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;activate-your-uoit-net-account-today&#34;&gt;Activate your &lt;code&gt;uoit.net&lt;/code&gt; account &lt;strong&gt;today&lt;/strong&gt;.&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://ssbp.mycampus.ca/apex/f?p=340:101:17205337333607&#34;&gt;https://ssbp.mycampus.ca/apex/f?p=340:101:17205337333607&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;the-benefit&#34;&gt;The benefit&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Google Drive &lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Google Plus &lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;h2 id=&#34;google-quiz&#34;&gt;Google Quiz&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://support.google.com/docs/answer/7032287?hl=en&#34;&gt;https://support.google.com/docs/answer/7032287?hl=en&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;test-your-working-knowledge&#34;&gt;Test your working knowledge&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;iframe
data-src=&#34;https://docs.google.com/forms/d/e/1FAIpQLScAHM9K4G_cZLIbOsjQUvIZJPzUYH33OI7qu-tvWckF45FMWw/viewform?embedded=true&#34;
width=&#34;760&#34; height=&#34;500&#34; frameborder=&#34;0&#34; marginheight=&#34;0&#34;
marginwidth=&#34;0&#34;&gt;Loading...&lt;/iframe&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Separate Window&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://goo.gl/lijEIT&#34;&gt;http://goo.gl/lijEIT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Realtime monitoring&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://goo.gl/xKUzKf&#34;&gt;http://goo.gl/xKUzKf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;closing-remarks&#34;&gt;Closing Remarks&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;First, I try to dramatically increase a student&amp;rsquo;s self-expectations and, of
course, their knowledge about the subject. Being a good teacher means
stretching students without discouraging them or destroying their confidence.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Terence Parr, Professor of CS, University of San Francisco&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Technology is inherently disruptive.  Disruptive technology is &lt;strong&gt;bad&lt;/strong&gt; 51% of the time.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip; but good 45% of the time.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip; and transformational 3.99999% of the time.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;vnc.jpg&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;ama-on&#34;&gt;AMA on&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;experimental-technology&#34;&gt;&lt;em&gt;Experimental technology&lt;/em&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Docker&lt;/li&gt;
&lt;li&gt;SSH over HTTPS&lt;/li&gt;
&lt;li&gt;Jupyter Notebook&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;rock-solid&#34;&gt;&lt;em&gt;Rock solid&lt;/em&gt;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Google Quiz, but still&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&amp;ldquo;In the midst of chaos, there is also opportunity&amp;rdquo;&lt;/p&gt;

&lt;p&gt;危中機 (\ˈwā\ zhü \ˈȯn \ˈjē)&lt;/p&gt;

&lt;p style=text-align:right&gt;
&lt;i&gt;Sun Tzu&lt;/i&gt;, Art of War
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building a desk</title>
      <link>http://db.science.uoit.ca/writings/build-desk/</link>
      <pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/writings/build-desk/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-0.jpg&#34; alt=&#34;The block in its initial condition&#34; /&gt;
Someone gave me a really gorgeous piece of wood.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s exactly what I was hoping to get my hands on.  Given that I have
absolutely minimal experience working with woods.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I got a steel brush for a few bucks.
The wood is completely dry, and it was surprisingly easy to remove the dusty
layer off the surface with some hard brushing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-1-brush.jpg&#34; alt=&#34;Steel brush&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-2-corner.jpg&#34; alt=&#34;Rough corner&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The block of wood is full of unique characteristics.  After all, it&amp;rsquo;s these
things that make it so much fun.
This particular piece has a rough corner.  I didn&amp;rsquo;t want to do much about it
except sawing it lightly, and sanding down possible splitters.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I got some wood oil and stains from Canadian Tires.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-3-stain.jpg&#34; alt=&#34;Starting to stain the wood&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-4-stained.jpg&#34; alt=&#34;The next day...&#34; /&gt;
After a few coats of wood stain and gloss finish, it looks absolutely great.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;The legs are from IKEA.  Putting the legs are easy enough.  The wood is quite
soft, and it&amp;rsquo;s really quite easy to drill the guiding holes for the screws.&lt;/p&gt;

&lt;p&gt;The only really hard part is that the wood is not perfectly flat, so I had to
put some inserts and adjusted them repeated to make sure that the legs are
perfectly leveled.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-5-legs.jpg&#34; alt=&#34;Putting on the legs&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;wood-6-finished.jpg&#34; alt=&#34;All done.&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Finally&lt;/em&gt;, it&amp;rsquo;s all done.  Actually, it was so much easier than I thought It
would have been.  I am so thankful that the wood was already nicely polished
to start with.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;I am happy to report that this blog is written on the desk.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;wood-7-workstation.jpg&#34; alt=&#34;Workstation...&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&#34;sign&#34;&gt;Ken Pu &lt;br&gt; July 15, Oshawa&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/insert-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/insert-sort/</guid>
      <description>

&lt;h1 id=&#34;basic-programming&#34;&gt;Basic programming&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We use &lt;em&gt;Python&lt;/em&gt; for this course.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Basic Python will do for the most part of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you are not used to Python (anymore), you are only &lt;em&gt;one&lt;/em&gt; day away
of catching up.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.codecademy.com/learn/python&#34;&gt;https://www.codecademy.com/learn/python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;programming-this-course&#34;&gt;Programming &amp;amp; This Course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:6&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t need much programming for this course because we absolutely will be
focused on the &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;But &amp;hellip;&lt;/p&gt;

&lt;p&gt;The reality is that &lt;em&gt;programming&lt;/em&gt; is absolutely essential.&lt;/p&gt;

&lt;h1 id=&#34;basic-programming-for-this-course&#34;&gt;Basic programming for this course&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [1, 2, 3]

print &amp;quot;The middle number is %d&amp;quot; % x[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need arrays as a fundamental data structure.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student:
    name = &amp;quot;Unknown&amp;quot;
    age = 18

    def __init__(self, name):
        self.name = name

jack = Student(&amp;quot;Jack&amp;quot;)

print &amp;quot;%s: %s&amp;quot; % (jack.name, jack.age)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need objects.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;i = 0
while i &amp;lt; 10:
  print i
  i += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for i in range(10):
  print i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Various loops are needed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ==================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def reverse_string(s):
    reversed_s = &amp;quot;&amp;quot;
    for c in s:
      reversed_s += c
    return reversed_s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We need functions, mostly to better organize the implementation of an algorithm.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; ============&lt;/p&gt;

&lt;p&gt;We may need to rely on external Python libraries for data generation and visualization of algorithmic actions.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;random-graph.png&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import networkx as nx
import matplotlib.pyplot as plot

G = nx.erdos_renyi_graph(100, 0.015)
nx.draw(G)
plot.save(&amp;quot;random-graph.png&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-sorting-problem&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 9:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Input:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;An array of elements: $x$
where the elements are to be compared by a &lt;em&gt;comparator&lt;/em&gt; function:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$f(x_1, x_2) \in \left[
\begin{array}{cc}
-1 &amp;amp; x_1 &amp;lt; x_2 \\
0 &amp;amp; x_1 = x_2 \\
1 &amp;amp; x_1 &amp;gt; x_2
\end{array}\right.$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Output:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A permutation $y$ of the array of $x$, such that&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\forall i,j\in[0, \mathrm{length}(y)],\quad i\leq j \implies y[i] \leq y[j]$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This is called &lt;em&gt;comparison based sorting&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The comparison function can be arbitrary, and it defines the ordering.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-sorting-problem-1&#34;&gt;The sorting problem&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Permutation $\pi : [0, n] \to [0, n]$ such that &lt;code&gt;$i\not= j\implies \pi(i)\not=\pi(j)$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Given a sorting problem $(x, f)$, there can be multiple non-unique permutations that sorts $x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x = [3, 2, 2, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;insertion-sort&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a highly &lt;em&gt;inefficient&lt;/em&gt; sorting algorithm.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It&amp;rsquo;s simple enough that:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It&amp;rsquo;s intuitive.&lt;/li&gt;
&lt;li&gt;It can be fully analyzed relatively easily.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;insertion-sort-the-intuition&#34;&gt;Insertion sort: the intuition&lt;/h1&gt;

&lt;p&gt;Suppose you have an array such that the &lt;em&gt;initial&lt;/em&gt; subarray is already sorted.  But the last element may be out of place.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-x&#34;&gt;+---+---+---+----+---+
| 2 | 4 | 5 | 10 | x |
+---+---+---+----+---+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What is a procedure to rearrange such array?  Imagine that &lt;code&gt;x=7&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;insertion-sort-1&#34;&gt;Insertion sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=cards.png width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;Chapter 2, Figure 2.1 of textbook.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python nu&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;try-it-out&#34;&gt;Try it out&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;import random
A = [random.randint(0, 100) for i in range(10)]
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;insertion_sort(A)
print A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;



&lt;iframe 
    
    data-src=&#39;http://db.science.uoit.ca:8080/?arg=kenpu/python&#39;
    
    style=&#39;max-width:100%;width:100%;height:500px&#39;&gt;&lt;/iframe&gt;



&lt;h1 id=&#34;analysis-of-correctness&#34;&gt;Analysis of correctness&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Intuition is not to be trusted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can formally prove that an algorithm is correct.
But first, we need some machinery.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;loop-invariance&#34;&gt;Loop invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Consider a loop:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;total = 0
count = 0

for v in array:
  total += v
  count += 1

avg = total / count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Precondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; *true at the start of
the loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Postcondition of a loop:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true at by the end of
the loop.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Loop invariance&lt;/strong&gt;:
a statement that is &lt;strong&gt;always&lt;/strong&gt; true
&lt;span style=color:#44f;font-size:120%&gt;right at the end&lt;/span&gt;
of each iteration of
the loop.&lt;/p&gt;

&lt;p&gt;At the &lt;em&gt;end&lt;/em&gt; of the $i$-th iteration:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;count&lt;/code&gt;$_i$ $\not=$ &lt;code&gt;0&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_{i+1} \geq$&lt;/code&gt; &lt;code&gt;total&lt;/code&gt;&lt;code&gt;$_i$&lt;/code&gt;
&lt;i class=&#34;fa fa-thumbs-down&#34;&gt;&lt;/i&gt;:
This is not a loop-invariance because it may not be true.
Consider if $v &amp;lt; 0$ for some iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There are two loops, with &lt;code&gt;while&lt;/code&gt;-loop nested in the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-1&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Inner-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If we assume that $A[0 .. j-1]$ is sorted, then
the following loop invariance holds for the &lt;code&gt;for&lt;/code&gt; loop:&lt;/p&gt;

&lt;p&gt;At the end of the iteration, we have $A[i\dots j]$ is sorted.&lt;/p&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;Can we say anything about &lt;code&gt;A[j+1]&lt;/code&gt; to &lt;code&gt;A[len(A)-1]&lt;/code&gt;?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-2&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outer-loop invariance&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The subarray &lt;code&gt;A[0 .. j]&lt;/code&gt; is sorted after the $j$-th iteration of the &lt;code&gt;for&lt;/code&gt;-loop.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;: We prove by induction on $j$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Base case&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$j=0$, trivially true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Induction&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;A[0 .. j-1]&lt;/code&gt; is sorted, by the inner-loop invariance, moving key to
&lt;code&gt;A[i+1]&lt;/code&gt; makes &lt;code&gt;A[0 .. j]&lt;/code&gt; sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;correctness-of-insertion-sort-by-loop-invariance-3&#34;&gt;Correctness of &lt;code&gt;INSERTION SORT&lt;/code&gt; by loop-invariance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Theorem&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;insertion_sort&lt;/code&gt; algorithm always correctly sorts the input array.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Proof&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By the outer-loop invariance, by the end of the last iteration,
with $j=$&lt;code&gt;len(A)-1&lt;/code&gt;, the entire array &lt;code&gt;A[0 .. len(A)-1]&lt;/code&gt; is sorted.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;h3 id=&#34;every-statement-takes-the-same-amount-of-time&#34;&gt;Every statement takes the same amount of time.&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not exactly correct, but it is accurate enough to gauge the
performance of algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;corollary&#34;&gt;&lt;em&gt;Corollary&lt;/em&gt;&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;We measure the number of lines executed by the program before an array is
completely sorted by &lt;code&gt;insertion_sort&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;$T_\mathrm{LOC}(\mathrm{length}(A)) \Rightarrow T(n)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Best case analysis&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Average case analysis&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python small&#34;&gt;def insertion_sort(A):
  for j in range(1, len(A)):
    key = A[j]
    i = j-1
    while i &amp;gt;= 0 and A[i] &amp;gt; key:
        A[i+1] = A[i]
        i = i - 1
    A[i+1] = key
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Worst case analysis&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let $n = \mathrm{length}(A)$&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The outer-loop &lt;em&gt;always&lt;/em&gt; iterates $n$ times.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The inner loop iterates &lt;em&gt;in the worst case&lt;/em&gt; $j$ times.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;$$ T(n) \leq \sum_{j=0}^n j = \frac{n(n-1)}{2}$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt; =================================================================&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;insert_sort&lt;/code&gt; is a pretty inefficient algorithm.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;45 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;4950&lt;/td&gt;
&lt;td&gt;5 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;499500&lt;/td&gt;
&lt;td&gt;0.5 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;499999500000&lt;/td&gt;
&lt;td&gt;5.9 days&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A more efficient algorithm (to be discussed later):&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;n&lt;/th&gt;
&lt;th&gt;T&lt;/th&gt;
&lt;th&gt;time (1M LOC/s)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;23 $\mu s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;460&lt;/td&gt;
&lt;td&gt;0.46 $ms$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;6907&lt;/td&gt;
&lt;td&gt;6.9 $s$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td&gt;13815510&lt;/td&gt;
&lt;td&gt;13.8 $s$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;INSERTION sort&lt;/li&gt;
&lt;li&gt;Analysis of correctness by loop-invariance&lt;/li&gt;
&lt;li&gt;Performance analysis by counting lines executed&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Text: 2.1, 2.2,&lt;/p&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is INSERTION sort a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/merge-sort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/merge-sort/</guid>
      <description>

&lt;h1 id=&#34;mergesort&#34;&gt;Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Divide and conquer, when and when not&amp;hellip;&lt;/li&gt;
&lt;li&gt;Bottom-up&lt;/li&gt;
&lt;li&gt;Top-down&lt;/li&gt;
&lt;li&gt;Correctness&lt;/li&gt;
&lt;li&gt;Complexity analysis&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;divide-and-conquer&#34;&gt;Divide and conquer&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;It&amp;rsquo;s a way to instruct &amp;ldquo;simple&amp;rdquo; solver to solve a complex problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;Minion.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img data-src=&#34;office-messy-desk.jpg&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;divide-and-conquer-and-combine&#34;&gt;Divide and conquer (and combine)&lt;/h1&gt;

&lt;p&gt;Divide:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a problem $P$, the division of a problem is a procedure
that produces a collection of &lt;em&gt;smaller&lt;/em&gt; problems &lt;code&gt;$\mathbf{Q} = \{Q_1, Q_2, \dots\}$&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each sub-problem &lt;code&gt;$Q_i\in\mathbf{Q}$&lt;/code&gt; (hopefully) is easier to solve.
Let &lt;code&gt;$S_i = \mathrm{solve}(Q_i)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Hopefully, the solutions of subproblems, ${S_i}$, are not useless toward the
solution of $P$.&lt;/p&gt;

&lt;p&gt;We need a procedure to combine:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\mathrm{solve}(P) = \mathrm{combine}(S_1, S_2, S_3, \dots)$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;example-cleaning-a-mess&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;Minion.jpg&#34; style=&#34;float:left;width:80px;margin:0 20px 0px 0&#34;&gt;&lt;/img&gt;
Consider how you can instruct a minion to clean a messy office.  The minion
is overwhelmed by the mess of the entire office.  Divide and conquer is a great
way to solve the cleaning problem.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are some assumptions:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The minion can clean up a very small section of an office - like a drawer, or
a book shelf.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If every section of an office is organized, we deem the whole office
organized.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;example-cleaning-a-mess-1&#34;&gt;Example: cleaning a mess&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide(Office) = &lt;code&gt;{Bookshelf, Desk, Floor, Cabinet, Drawer, $\dots$}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Conquer: the minion can clean up each section&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine: Nothing needs to be done&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Divide &amp;amp; Conquer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A list of numbers can be divided into smaller lists.
If a list is so small, we can sort it trivially.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How small does a list need to be for us to know how to sort it?&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-1&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If we have two lists that are already sorted, can we figure out how to combine
them in a sorted way?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nosyntax&#34;&gt;+---+---+---+---+
| 1 | 5 | 6 | 8 |          \
+---+---+---+---+          |
                           |
                           +------&amp;gt;  combined sorted list
                           |
+---+---+---+---+----+     |
| 3 | 4 | 5 | 8 | 10 |     /
+---+---+---+---+----+
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sorting-with-divide-and-conquer-2&#34;&gt;Sorting with Divide and Conquer&lt;/h1&gt;

&lt;p&gt;Combine:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 10:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def merge(list1, list2):
    i, j = 0, 0
    list3 = []

    while i &amp;lt; len(list1) and j &amp;lt; len(list2):
        if list1[i] &amp;lt;= list2[j]:
            list3.append(list1[i])
            i += 1
        else:
            list3.append(list2[j])
            j += 1

    if i &amp;lt; len(list1): list3.extend(list1[i:])

    if j &amp;lt; len(list2): list3.extend(list2[j:])

    return list3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We want to be able to merge to sorted list into a larger list.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=merge.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;bottom-up-mergesort-1&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;p&gt;We start with a list of arbitrary lenght $n$.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Observe that &lt;em&gt;all&lt;/em&gt; sublist of length 1 is already sorted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 2.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use &lt;code&gt;merge()&lt;/code&gt; to improve the &lt;em&gt;sortedness&lt;/em&gt; of the list to length 4, 8, 16, &amp;hellip;
until the whole list is sorted.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;bottom-up-mergesort-2&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;bottom-up-mergesort-3&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;script src=&#34;//gist.github.com/kenpu/df50d5b42ed4abb0c4749284111005d6.js?file=mergesort.py&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;bottom-up-mergesort-4&#34;&gt;Bottom-up Mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A hierarchy of subproblems&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Small subproblems: sublist of length 1&lt;/p&gt;

&lt;p&gt;Larger subproblems: sublist of length 2, 4, &amp;hellip;&lt;/p&gt;

&lt;p&gt;The largest subproblem: the whole list&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Why is it called &lt;em&gt;bottom-up&lt;/em&gt;?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The procedure, &lt;code&gt;mergesort()&lt;/code&gt;, recognizes the smallest subproblems &lt;em&gt;first&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;divide&lt;/strong&gt; stage starts at the bottom of the hierarchy.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;conquer&lt;/strong&gt; stage &lt;em&gt;always&lt;/em&gt; starts with the bottom of the hierarchy.&lt;/p&gt;

&lt;h1 id=&#34;analysis-correctness&#34;&gt;Analysis: correctness&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop-invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At the end of each loop,&lt;/p&gt;

&lt;p&gt;for all $L[i\Delta \dots (i+1)\Delta]$ is sorted for all $i$,
where $\Delta$ is the sortedness at the end of the iteration.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Overall correctness&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The loop terminates when $\Delta$ exceeds the length of the list, so the
entire list is sorted by the loop invariance.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Guaranteed termination&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration strictly increases the sortedness $\Delta$ (by doubling it).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;analysis-performance&#34;&gt;Analysis: performance&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm&#34;&gt;def mergesort(list):
    sortedness = 1

    while sortedness &amp;lt; len(list):
        for i in range(0, len(list), 2*sortedness):
            list1 = list[i:i+sortedness]
            list2 = list[i+sortedness:i+2*sortedness]
            list3 = merge(list1, list2)
            list[i:i+len(list3)] = list3
        sortedness = 2 * sortedness

    return list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;How many iterations if there are $n$ elements in the list?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration grows the &lt;em&gt;sortedness&lt;/em&gt; by a factor of 2 up to $n$.
So, we need $\log_2(n)$ iterations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;How many instructions does each iteration take?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Each iteration has four steps.  Each step requires no more than a linear scan
of the list.
We can guarantee that number of instructions do not exceed: $k\cdot n$ for some
constant $k$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Putting it together:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;mergesort()&lt;/code&gt; requires no more than $k\cdot n\log(n)$ number of instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;top-down-mergesort-1&#34;&gt;Top-down mergesort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Revisit the hierarchy of subproblems of sorting a list&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We can specify the &lt;em&gt;Divide-and-conquer&lt;/em&gt; top-down:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Divide sorting of $L$ to the first sublist $L[0 \dots \frac{n}{2}]$
and the second sublist $L[\frac{n}{2} \dots n]$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the sub-lists are not easy enough, then break down again.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Recursion&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;correctness&#34;&gt;Correctness:&lt;/h2&gt;

&lt;p&gt;Induction on depth of recursion.&lt;/p&gt;

&lt;p&gt;Base case: depth = 0&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If there is no recursion, than the list $L$ is such that $|L|\leq 1$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Inductive case: depth = $k$, and assume that all mergesort at level $&amp;lt; k$ are
correct.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Let $L_1$ and $L_2$ be the two sublists.  The invocations &lt;code&gt;mergesort($L_i$)&lt;/code&gt;
use $&amp;lt; k$ recursions, and thus, are &lt;em&gt;correct&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since $L_1$ and $L_2$ are properly sorted, and that &lt;code&gt;merge()&lt;/code&gt; is correct,
we conclude that &lt;code&gt;mergesort(L)&lt;/code&gt; is correct.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;top-down-mergesort-analysis-1&#34;&gt;Top-down mergesort: Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python sm clipboard&#34;&gt;def mergesort(L):
    n = len(L)
    if n &amp;lt;= 1:
        return L
    else:
        L1 = mergesort(L[:n/2])
        L2 = mergesort(L[n/2:])
        return merge(L1, L2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;p&gt;Let $n = |L|$.  How much time does it take to complete top-down
&lt;code&gt;mergesort($L$)&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Let $T(n)$ = time of &lt;code&gt;mergesort($L$)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray*}
T(n) &amp;amp;\simeq&amp;amp; T(n/2) + T(n/2) + n \\
  &amp;amp;=&amp;amp; 2 T(n/2) + n
\end{eqnarray*}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will develop an array of techniques to solve &lt;em&gt;recurrence equations&lt;/em&gt; to
analyze recursive algorithms.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Spoiler Alert:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$ T(n) = n\log(n) + n $$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Bottom-up mergesort&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Top-down mergesort&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;MERGESORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/optimal-sorting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/optimal-sorting/</guid>
      <description>

&lt;h1 id=&#34;optimal-comparison-based-sorting-br-v-s-br-numerical-sorting&#34;&gt;Optimal Comparison Based Sorting &lt;br&gt; v.s. &lt;br&gt;  Numerical Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Assumption&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The elements in the array are &lt;em&gt;black boxes&lt;/em&gt;, and only comparison can be made between two elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;The decision-tree model&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a sorting algorithm $A$, we record &lt;em&gt;all&lt;/em&gt; possible comparison operations executed in $A$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; A comparison operation: $(i,j)$ where $i, j$ are the &lt;em&gt;original&lt;/em&gt; index of the elements.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;The leaf records the final ordering of the original index.&lt;/p&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-1&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Q&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;How many comparison operations did $A$ take as illustrated in the diagram?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
&lt;p&gt;What is the worst case number of comparision operations?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;lower-bounds-for-sorting-2&#34;&gt;Lower Bounds for Sorting&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;decision-tree.png&#34; width=&#34;100%&#34;&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What type of tree is the deicion tree?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Binary tree&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How many leaf nodes are there for $n$ elements?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;All possible permutations of $[1, 2, 3, \dots n] = n!$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;What is the height of the tree if there are $n!$ leaf nodes?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\log_2(n!) \approx c\cdot n\log(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Any comparision based sorting algorithm will necessarily take at least $c n\log(n)$ number of comparison operations in the &lt;em&gt;worst&lt;/em&gt; case.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Optimal sorting&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a comparison based sorting algorithm always makes at most $c n\log(n)$ number of comparisons, then it&amp;rsquo;s called &lt;em&gt;optimal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;optimal-comparison-based-sorting-1&#34;&gt;Optimal Comparison Based Sorting&lt;/h1&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Algorithm&lt;/th&gt;
&lt;th&gt;Optimal?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Insertion sort&lt;/td&gt;
&lt;td&gt;No, $n^2$&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Mergesort&lt;/td&gt;
&lt;td&gt;Yes&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Quicksort&lt;/td&gt;
&lt;td&gt;No, $n^2$ in the worst case&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&#34;sorting-integers&#34;&gt;Sorting Integers&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If an array contains (bounded) integers, we can beat optimal comparison based sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Elements are not blackboxes.  We can look at individual digits of an bounded integer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;Assumptions:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;The elements are integers.&lt;/li&gt;
&lt;li&gt;The elements are all in the range of $[0, k-1]$ for some $k \geq 0$.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Amazing fact:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;With $n$ elements, we can do it with only $2\cdot(n+k)$ number of instructions,
compare to $n\log(n)$ in the case of optimal comparison sorting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;counting-sort-1&#34;&gt;Counting sort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def empty_array(size, init=None):
    return [init for i in range(size)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; allocate an empty array with an optional initial value.&lt;/p&gt;

&lt;h1 id=&#34;counting-sort-2&#34;&gt;Counting sort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def COUNTING_SORT(A):
    n = len(A)
    k = max(A) + 1
    B = empty_array(size=n)
    C = empty_array(size=k, init=0)

    for a in A:
        C[a] = C[a] + 1

    for i in range(1,k):
        C[i] = C[i] + C[i-1]

    for a in reversed(A):
        B[C[a]-1] = a
        C[a] = C[a] - 1

    return B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;We compute the frequency of each distinct value in &lt;code&gt;A&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The frequence is then turned into cummulative frequency.  Namely:
&lt;code&gt;$C[x] = |\{y\in A: y\leq x\}|$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;With $C$, we can quickly deduce which each element should be positioned.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;counting-sort-3&#34;&gt;Counting Sort&lt;/h1&gt;

&lt;p&gt;Question:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Is &lt;code&gt;COUNTING_SORT&lt;/code&gt; stable?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Answer:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s crucial to place $x$ into &lt;code&gt;B&lt;/code&gt; from &lt;code&gt;reverse(A)&lt;/code&gt; instead of &lt;code&gt;A&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The best comparison sorting algorithms are in the order of $n\log(n)$.&lt;/li&gt;
&lt;li&gt;The best integer comparison algorithms can achieve the efficiency in the order of $n$.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COUNTING_SORT&lt;/code&gt; requires too much memory in practice to be applied to arrays with large integer values.  However, it will be instrumental later (as part of radix sort).&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;The measure of algorithmic efficiency will be made much more rigorous in the next section of this course.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/algorithms/quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/quicksort/</guid>
      <description>

&lt;h1 id=&#34;quicksort&#34;&gt;Quicksort&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;quicksort-1&#34;&gt;Quicksort&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Divide and conquer&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given a list $L$, we divide the sorting problem into two sub-problems.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Sort the elements in $L$ smaller than $x$: $L_1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Sort the elements in $L$ larger than $x$: $L_2$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Combine&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\mathrm{sorted}(L) = \mathrm{sorted}(L_1) \oplus \{x\} \oplus \mathrm{sorted}(L_2)$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;partition&#34;&gt;Partition&lt;/h1&gt;

&lt;p&gt;Given a list &lt;code&gt;$L$&lt;/code&gt; and an element $x$ in $L$, &lt;em&gt;partitioning&lt;/em&gt; $L[p \dots r]$ by the &lt;em&gt;pivot&lt;/em&gt;
element $x$ does the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Rearrange the elements in $L[p\dots r]$ so that there exists a position $q$
such that &lt;em&gt;after&lt;/em&gt; rearrangment:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;$L[q] = x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [p, q-1],\ L[i] \leq x$&lt;/li&gt;
&lt;li&gt;$\forall i\in [q+1, r],\ L[i] \geq x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-1-simple-but-takes-more-memory&#34;&gt;Version 0.1: simple, but takes more memory&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement &lt;code&gt;partition(L, p, r)&lt;/code&gt; with the minimal effort:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pick $x = L[r]$&lt;/li&gt;
&lt;li&gt;Filter the list for smaller elements: &lt;code&gt;$L_1 = \{y\in L[p\dots r-1]: y\leq x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Filter the list for larger elements: &lt;code&gt;$L_2 = \{y\in L[p\dots r-1]: y &amp;gt; x\}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Reconstruct: &lt;code&gt;$L[p \dots r] = L_1 \oplus \{x\} \oplus L_2$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def partition(L, p, r):
    x = L[r]
    L1 = [y for y in L[p:r] if y &amp;lt;= x]
    L2 = [y for y in L[p:r] if y &amp;gt; x]
    L[p:r+1] = L1 + [x] + L2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;version-0-2-more-involved-but-takes-no-additional-memory&#34;&gt;Version 0.2: more involved, but takes no additional memory&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It only involves element swapping, so it requires &lt;em&gt;zero&lt;/em&gt; additional memory.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;But its correctness is much less obvious.&lt;/p&gt;

&lt;h1 id=&#34;analysis-of-partition&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Bookkeeping is the key:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;$p$ and $r$ are the boundaries of the sublist to be partitioned.&lt;/li&gt;
&lt;li&gt;$r$ also holds the value of the pivot element.&lt;/li&gt;
&lt;li&gt;Elements in $[p\dots j]$ are processed.&lt;/li&gt;
&lt;li&gt;$i$ is a marker of the boundary between smaller and larger elements.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;analysis-of-partition-1&#34;&gt;Analysis of partition&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 7:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python clipboard&#34;&gt;def partition(L, p, r):
    x = L[r]
    i = p - 1
    for j in range(p, r):
        if L[j] &amp;lt;= x:
            i += 1
            L[i], L[j] = L[j], L[i]
    L[i+1], L[r] = L[r], L[i+1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Loop invariance:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;After each iteration, $L[p, j]$ is properly partitioned:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$L[p, i] \leq x$&lt;/li&gt;
&lt;li&gt;$L[i+1, j] &amp;gt; x$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;quicksort-2&#34;&gt;Quicksort&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def quicksort(L, p, r):
    if p &amp;lt; r:
        k = partition(L, p, r)
        quicksort(L, p, k-1)
        quicksort(L, k+1, r)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;performance-analysis&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will only give a terse outline of the analysis.  The full version is deferred to later lectures.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-1&#34;&gt;Performance Analysis&lt;/h1&gt;

&lt;p&gt;Let there be $n$ elements in the array.&lt;/p&gt;

&lt;p&gt;Key obsevation:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;partition(L, p, r)&lt;/code&gt; takes $(r - p)$ iterations.  Each iteration has a fixed number of instructions.  So, $T_\mathrm{partition} = c_1 (r-p) \leq c\cdot n$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;At each &lt;em&gt;invocation&lt;/em&gt; of &lt;code&gt;quicksort(L, p, k-1)&lt;/code&gt; and &lt;code&gt;quicksort(L, k+1, r)&lt;/code&gt;, we need to determine the number of elements: $k-1-p$, and $r-k-1$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;performance-analysis-worst-case&#34;&gt;Performance Analysis: Worst-case&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The worst case for $T_\mathrm{partition} = n$&lt;/li&gt;
&lt;li&gt;The worst case for $k-1-p = n-1$&lt;/li&gt;
&lt;li&gt;The worst case for $r-k-1 = n-1$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;We have enough to set-up an equation to estimate the number of instructions of &lt;code&gt;quicksort(L, a, b)&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;Let $|L[a\dots b]| = n$.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n-1)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This leads to a (poor) performance characteristics of: $\approx n^2$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We will show how to solve such equations (known as recurrence equations) in the next section of this course.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;performance-analysis-average-case&#34;&gt;Performance Analysis: average case&lt;/h1&gt;

&lt;p&gt;Quicksort as the name suggests is actually quite quick (most of the time&amp;hellip;)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting &lt;code&gt;k = partition(L, p, q)&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The pivot value should be somewhere in the middle of the subarray.
Namely: $k\approx p+q/2$, and so $k-1-p \approx n/2$, and $q-k-1\approx n/2$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Revisiting the recurrence equation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\begin{eqnarray}
T_\mathrm{quicksort}(n) &amp;amp;=&amp;amp; n + 2\cdot T_\mathrm{quicksort}(n/2)
\end{eqnarray}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;This leads to a satisfying performance characteristics of: $\approx n\log(n)$&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Partition: a simple version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partition: a zero-memory version&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quicksort: a recursive sorting algorithm&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;challenge&#34;&gt;Challenge&lt;/h1&gt;

&lt;p&gt;Is &lt;code&gt;QUICKSORT&lt;/code&gt; a stable sorting algorithm?&lt;/p&gt;

&lt;p&gt;Recall:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Stable sorting requires an additional condition on the permutation:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ \forall i,j\in [0, \mathrm{length}(x)],\ i &amp;lt; j\ \mathrm{and}\ f(x[i], x[j]) = 0 \implies \pi(i) &amp;lt; \pi(j) $$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/functional-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/functional-computation/</guid>
      <description>

&lt;h1 id=&#34;lambda-calculus-symbolic-computation&#34;&gt;$\lambda$-Calculus: symbolic computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;lambda-calculus&#34;&gt;$\lambda$-Calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Proposed by Alonzo Church in ~1930.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;intented to formalize mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Syntactic expressions that represent &lt;em&gt;functions&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;designed to represent the entire foundation of mathematics.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Rules of rewriting the syntactic expression&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;rewrite rules represent mathematical reasoning.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;expressions&#34;&gt;Expressions&lt;/h1&gt;

&lt;p&gt;Values&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Literals: 1, 2, 3, &amp;ldquo;Hello world&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Variables: $x, y, z, \dots$&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Functions&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$+ : (x,y)\mapsto x+y$&lt;/li&gt;
&lt;li&gt;$\mathrm{inc} : x\mapsto x+1$&lt;/li&gt;
&lt;li&gt;$\dots$&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Always returns &lt;em&gt;one&lt;/em&gt; value.&lt;/li&gt;
&lt;li&gt;Takes a fixed number of inputs: arity of the function
&lt;span style=color:red&gt;*&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;value-as-function&#34;&gt;Value as function&lt;/h1&gt;

&lt;p&gt;A value is a zero-arity function.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;function-as-value&#34;&gt;Function as value&lt;/h1&gt;

&lt;p&gt;We want to extend the idea of &lt;em&gt;things&lt;/em&gt; to include functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;This is a central idea in functional programming&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&#34;value-equiv-function-everything&#34;&gt;Value $\equiv$ Function = Everything&lt;/h2&gt;

&lt;h1 id=&#34;syntax-for-expressions-value-function&#34;&gt;Syntax for expressions (value / function)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;$x, y, z, \dots$ are expressions&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;Abstraction:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $x$ is a variable, and $e$ is an expression, then
$\lambda x. e$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;If $e_1$ is a function with arity 1,
&lt;code&gt;$e_2$&lt;/code&gt; is an expression, then
$e_1 e_2$ is an expression&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We assume that all functions are with arity 1.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is not a restriction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;the-weird-syntax-of-lambda-calculus&#34;&gt;The &lt;em&gt;weird&lt;/em&gt; syntax of $\lambda$ calculus&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\lambda x.e$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is a function taking &lt;em&gt;one&lt;/em&gt; input, represented by the variable $x$.
It returns &lt;em&gt;one&lt;/em&gt; value, which is evaluated as the expression $e$.
The expression $e$ usually makes uses of $x$, but not necessarily.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This is passing $e_2$ as an argument to the expression $e_1$.  Recall that
everything is a function.  So $e_1$ is a function with &lt;em&gt;one&lt;/em&gt; argument.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$e_1 e_2 e_3 = ((e_1 e_2) e_3)$&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;This shows that $e_1$ takes one argument ($e_2$), and returns an
expression which is yet again a function which takes $e_3$ as an input.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;defining-things&#34;&gt;Defining things&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identity function&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$\lambda x.x$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functions with multiple arity&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose we have a function $f(x,y,z) = e$ where the expression
involves all three input variables $x, y, z$.&lt;/p&gt;

&lt;p&gt;We can use the following expression to build $f$:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$\lambda x.(\lambda y.(\lambda z. e))$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;This is a big deal.&lt;/strong&gt; &lt;br&gt;
&lt;strong&gt;Functions as values in action here.&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:220px&gt;&lt;/div&gt;

&lt;p&gt;We can write it conveniently as $\lambda xyz.e$&lt;/p&gt;

&lt;h1 id=&#34;computing-with-lambda-calculus&#34;&gt;Computing with $\lambda$-Calculus&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We rely on string-rewriting to evaluate
LC expressions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;substitution-of-variables-in-function-applications&#34;&gt;Substitution of variables in function applications&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Notation&lt;/strong&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$e[x/e&amp;rsquo;]$ is the expression obtained by substituting all occurances of $x$ in
the expression $e$ with the expression $e&amp;rsquo;$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Substition&lt;/strong&gt; as a way to evaluate function application:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$(\lambda x. e) e&amp;rsquo; \implies e[x/e&amp;rsquo;]$.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
&amp;amp;&amp;amp; (\lambda x.x x) (\lambda y. y) \\
&amp;amp;\implies&amp;amp; (x x)[x/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)(\lambda y.y) \\
&amp;amp;\implies&amp;amp; y[y/(\lambda y.y)] \\
&amp;amp;\implies&amp;amp; (\lambda y.y)
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split note&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We can easily get into trouble.&lt;/p&gt;

&lt;p&gt;Substitution cannot be used freely.&lt;/p&gt;

&lt;h1 id=&#34;free-bound-variables&#34;&gt;Free &amp;amp; Bound Variables&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Variables in a function abstraction expression can be &lt;em&gt;free&lt;/em&gt; or &lt;em&gt;bound&lt;/em&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a variable represents the input parameter in a function expression, then
it&amp;rsquo;s considered &lt;em&gt;bound&lt;/em&gt;.  Otherwise, it&amp;rsquo;s &lt;em&gt;free&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;$\mathbf{FV}(e)$ are the free variables of $e$&lt;/li&gt;
&lt;li&gt;$\mathbf{BV}(e)$ are the bound variables&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;variable-capturing&#34;&gt;Variable Capturing&lt;/h1&gt;

&lt;p&gt;Consider an expression:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;There are multiple occurrences of $x$, so let&amp;rsquo;s label them so we can refer to
the individual occurrences.&lt;/p&gt;

&lt;p&gt;$$\lambda x_1. (\lambda x_2.x_3)$$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Which input variable does $x_3$ refer to?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is called capturing.&lt;/p&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;There is a rewrite rule that allows us to rename the parameter variables without
changing the meaning of the expression.&lt;/p&gt;

&lt;p&gt;$$ \lambda x. x \equiv \lambda y.y \equiv \lambda \mathsf{hello}.\mathsf{hello} $$&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Renaming&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Suppose that $x$ is a free variable of $e$, and $y$ does not appear in $e$ at
all.&lt;/p&gt;

&lt;p&gt;Then $\lambda x.e \implies \lambda y.e[x/y]$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;elimination-of-variable-capturing-1&#34;&gt;Elimination of Variable Capturing&lt;/h1&gt;

&lt;p&gt;Back to:&lt;/p&gt;

&lt;p&gt;$$\lambda x. (\lambda x.x)$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;First we consider the sub expression $\lambda x.x$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Using renaming, we can rewrite it to $\lambda y.y$.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Then we get:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$$\lambda x. (\lambda x.x) \implies \lambda x.\lambda y. y$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt;
Generally, we only apply &lt;strong&gt;substitution&lt;/strong&gt; to evaluate function applications
if there is &lt;em&gt;no&lt;/em&gt; variable capturing; and this can be achieved by &lt;strong&gt;renaming&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&#34;how-to-perform-computation-using-lc&#34;&gt;How to perform computation using LC?&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Natural numbers&lt;/li&gt;
&lt;li&gt;Arithmetics&lt;/li&gt;
&lt;li&gt;Loop and conditional branching&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;-----&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;All can be done using LC&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Express the algorithm in terms of natural numbers, arithmetics,
 loops and conditional branches.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Encode the algorithm in LC.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Apply syntax rewriting until no more rewriting is possible.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;a-glance-of-lc-in-action&#34;&gt;A glance of LC in action&lt;/h1&gt;

&lt;p&gt;A bit of notation:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$\lambda x.\lambda y. \lambda z. e$ is written as as $\lambda xyz. e$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;Now we can encode numbers:&lt;/p&gt;

&lt;p&gt;$0 \equiv \lambda sx. x$ (takes two inputs, but only keep the second one.)&lt;/p&gt;

&lt;p&gt;$1 \equiv \lambda sx. sx$&lt;/p&gt;

&lt;p&gt;$2 \equiv \lambda sx. ssx$&lt;/p&gt;

&lt;p&gt;$\vdots$&lt;/p&gt;

&lt;h1 id=&#34;arithmetics&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;Consider the simplest arithmetics: increment by 1.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def succ(n):
    return n + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$S \equiv \lambda n. \lambda yx.y(nyx)$$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let&amp;rsquo;s try this out.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\begin{eqnarray}
S 0 &amp;amp;=&amp;amp; (\lambda n. \lambda yx.ynyx)0 \\
    &amp;amp;=&amp;amp; (\lambda yx.ynyx)[n/0] \\
    &amp;amp;=&amp;amp; \lambda yx.y(0yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y((\lambda sz.z)yx) \\
    &amp;amp;=&amp;amp; \lambda yx.y(x) \\
    &amp;amp;=&amp;amp; 1
\end{eqnarray}&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;arithmetics-1&#34;&gt;Arithmetics&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(n1, n2):
    return n1 + n2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Observe:&lt;/p&gt;

&lt;p&gt;$2 S 3 = 5$ (work it out, it&amp;rsquo;s quite incredible.)&lt;/p&gt;

&lt;p&gt;So, we have:&lt;/p&gt;

&lt;p&gt;$$+ \equiv \lambda mn. mSn$$&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;------&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Can you guess the LC expression for multiplication?&lt;/p&gt;

&lt;h1 id=&#34;recursion&#34;&gt;Recursion&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;LC does not require assigning aliases to functions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Technically, there is just &lt;strong&gt;ONE&lt;/strong&gt; expression for the entire algorthm.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Why it&amp;rsquo;s hard to do recursion without aliases?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def factorial(n):
    if n &amp;lt;= 1:
        return n
    else:
        return n * factorial(n-1)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Is it even possible?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Yes.  It&amp;rsquo;s called the &lt;strong&gt;Y&lt;/strong&gt;-combinator.&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} \equiv (\lambda y.(\lambda x.y(xx))(\lambda x.y(xx)))$$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;y-combinator&#34;&gt;Y-combinator&lt;/h1&gt;

&lt;p&gt;$$ \mathbf{Y} f = f (\mathbf{Y} f) $$&lt;/p&gt;

&lt;p&gt;So,&lt;/p&gt;

&lt;p&gt;$$ \mathbf{Y} f x \implies f (\mathbf{Y} f) x \implies f f \dots f x $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; $\mathbf{Y} f$ is a &lt;em&gt;fixed point&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;using-y-combinator-to-implement-factorial&#34;&gt;Using Y-combinator to implement factorial&lt;/h1&gt;

&lt;p&gt;Consider a function $F$ as:&lt;/p&gt;

&lt;p&gt;$$\lambda fx. (\mathrm{ifzero}\ x)\ 1\ (*\ x\ (f\ (\mathrm{dec}\ x)))$$&lt;/p&gt;

&lt;p&gt;If we apply the Y-combinator to $F$, we get:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = F (\mathbf{Y} F) n $$&lt;/p&gt;

&lt;p&gt;You can check the following:&lt;/p&gt;

&lt;p&gt;$$ (\mathbf{Y} F) n = (\mathrm{ifzero}\ n)\ 1\ (*\ n\ ((\mathbf{Y} F)\ (\mathrm{dec}\ n))) $$&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is really quite amazing.  We have achieved Turing-completeness via recursion.  The amazing part is that we don&amp;rsquo;t need variables to refer to any values.  So $F$ is just for convenience and readability.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;LC is purely symbolic.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It carries out computation by very simple string rewrites:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Function application&lt;/li&gt;
&lt;li&gt;Variable renaming&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It solves problem by:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Encode the problem as a single (huge) string of LC expression.&lt;/li&gt;
&lt;li&gt;Using the rules to rewrite the string to a &lt;em&gt;normal&lt;/em&gt; form.&lt;/li&gt;
&lt;li&gt;The resulting LC expression is the answer.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No variables are needed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/old/intro-to-languages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/old/intro-to-languages/</guid>
      <description>

&lt;h1 id=&#34;computation-in-practice&#34;&gt;Computation in practice&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Languages based on stateful computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Languages based on functional computation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hybrid languages&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;stateful-computation&#34;&gt;Stateful computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 4:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Languages&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Javascript&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Task&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Quicksort&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;X = [6, 3, 4, 8, 1, 4]

def quicksort(X, i, j):
  if i &amp;lt; j:
    p = partition(X, i, j)
    quicksort(X, i, p-1)
    quicksort(X, p+1, j)

def partition(X, i, j):
  pivot = X[j]
  m = i
  for n in range(i, j):
    if X[n] &amp;lt;= pivot:
      X[m], X[n] = X[n], X[m]
      m += 1
  X[m], X[j] = X[j], X[m]
  return m

def QuickSort(X):
  return quicksort(X, 0, len(X)-1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;breakdown-of-python&#34;&gt;Breakdown of python&lt;/h1&gt;

&lt;div pdf=&#34;qsort-py.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;python-v-s-javascript&#34;&gt;Python v.s. Javascript&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.py&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;div style=height:600px;overflow:auto&gt;
&lt;script
src=&#34;https://gist.github.com/kenpu/e2e3fcc9feea16fb14a84c7ec98cdd75.js?file=qsort.js&#34;&gt;&lt;/script&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/courses/programming-languages/stateful-computation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/stateful-computation/</guid>
      <description>

&lt;h1 id=&#34;computation-the-turing-machine&#34;&gt;Computation &amp;amp; the Turing Machine&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;computation&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;david-hilbert.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Hilbert&amp;rsquo;s Ten&amp;rsquo;s problem, 1900&lt;/li&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-1&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;kurt-godel.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Gödel&amp;rsquo;s incompleteness theorem&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-2&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 5:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alan-turing.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;Turing machine&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-3&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;alonzo-church.png&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Entscheidungsproblem, 1928&lt;/li&gt;
&lt;li&gt;$\lambda$-calculus&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computation-4&#34;&gt;Computation&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;john-von-neumann.jpg&#34; width=100%&gt;&lt;/img&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;von Neumann computing model&lt;/li&gt;
&lt;li&gt;EDVAC&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;turing-machine&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A completely mechanical device (1928)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;envisioned by Alan Turing as an intuitive formalism to
describe the non-existing phenomenon of machine driven
reasoning, now known as &lt;em&gt;computation&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Realized into an actual design (1945)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;John von Neumann designed an electronic version to simulate
the mechanical definition of a TM in a document known as &lt;em&gt;First Draft of a
Report on the EDVAC&lt;/em&gt;, 1945.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Turing-complete&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;TM is the most powerful computing model we know.
Up to now, we don&amp;rsquo;t know any other computing models more powerful than
a TM.&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;turing-machine-1&#34;&gt;Turing Machine&lt;/h1&gt;

&lt;div pdf=&#34;turing-machine.pdf&#34; scale=0.8&gt;&lt;/div&gt;

&lt;h1 id=&#34;computational-power-of-tm&#34;&gt;Computational power of TM&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Church-Turing Thesis&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a procedure (algorithm) can be executed by &lt;em&gt;any&lt;/em&gt; computer, then it can be
executed by a Turing Machine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Turing Complete&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If a mechanism is equivalent to TM, then it&amp;rsquo;s called &lt;em&gt;Turing Complete&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;simulation-of-a-function&#34;&gt;Simulation of a function&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 8:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Computable functions&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A function $f$ is computable if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Its input can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its output can be encoded as a binary string: &lt;code&gt;$2^*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Its evaluation can always be carried out by a TM.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Any computable function can be implemented by a TM.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Any TM is some computable function.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Why is a TM always a function (over binary strings)?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;break&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;universal-tm&#34;&gt;Universal TM&lt;/h1&gt;

&lt;p&gt;Consider a TM: $M$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s a function &lt;code&gt;$M:2^*\to 2^*$&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It&amp;rsquo;s mechanical description can be encoded as a binary string.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Function &lt;em&gt;eval&lt;/em&gt; takes two inputs - a TM and an input, and it computes the
output.&lt;/p&gt;

&lt;p&gt;$$\mathrm{eval} :\mathrm{TM} \times 2^* \to 2^*$$&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;It&amp;rsquo;s input can be encoded as binary strings.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It can be carried out by a procedure.
&lt;i style=&#34;font-size:200%;color:#faa;vertical-align:middle;margin-left:10px&#34; class=&#34;fa fa-thumbs-up&#34;&gt;&lt;/i&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;By Church-Turing thesis, &lt;strong&gt;eval&lt;/strong&gt; is computable, so there is a TM for it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Definition&lt;/em&gt; &lt;strong&gt;Universal TM&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The TM $\mathbf{U}$ that computes &lt;strong&gt;eval&lt;/strong&gt; is called &lt;em&gt;universal&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;universal-tm-1&#34;&gt;Universal TM&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The TM $\mathbf{U}$ initializes the tape with the binary encoding of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;a TM, $M$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;an input, $x$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;It outputs $\mathbf{eval}(M, x)$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Modern Computer:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$M$ is the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$x$ is the input to the program&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\mathbf{U}$ is the general purpose computer&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;tm-programming&#34;&gt;TM-Programming&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We just need a single TM, namely $\mathbf{U}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The universal programming language is the encoding of $M$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Turing Machine is a mechanically realizable device.&lt;/li&gt;
&lt;li&gt;TM is as powerful (but a lot slower) as any modern computers.&lt;/li&gt;
&lt;li&gt;There is a very special TM that is called the &lt;em&gt;Universal TM&lt;/em&gt;.  It can be
&lt;em&gt;programmed&lt;/em&gt;!&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://db.science.uoit.ca/people/kenpu/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/people/kenpu/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Ken Pu&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Associate Professor &lt;br&gt;
&lt;a href=&#34;http://www.science.uoit.ca/undergraduate/programs-and-information-for-prospective-students/computing-science/&#34;&gt;Computer Science&lt;/a&gt; /
&lt;a href=&#34;http://science.uoit.ca&#34;&gt;Faculty of Science, UOIT&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Contact&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Email: &lt;code&gt;ken.pu@uoit.ca&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Address:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Faculty of Science, 2000 Simcoe Street North, Oshawa ON, L1H 7K3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Office and telephone:
&lt;a href=&#34;https://ssbp.mycampus.ca/prod/www_directory.directory_uoit.p_ShowPeople?first_name_in=ken&amp;amp;last_name_in=pu&amp;amp;button_text_in=Search&#34;&gt;See here&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Algorithms</title>
      <link>http://db.science.uoit.ca/courses/algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/</guid>
      <description>&lt;div class=&#34;jumbotron&#34;&gt;
	&lt;h1&gt;Design &amp; Analysis of Algorithms&lt;/h1&gt;
&lt;/div&gt;

&lt;div class=row&gt;
	&lt;div class=col-md-3&gt;
		&lt;img src=&#34;textbook.jpg&#34; width=100%&gt;&lt;/img&gt;
		&lt;figcaption&gt; Introduction to Algorithms, Third Edition, &lt;i&gt;Coremen, Leiserson, Rivest and Stein&lt;/i&gt; &lt;/figcaption&gt;
	    &lt;p style=margin-top:10px;font-style:italic;font-size:90%&gt;
			This course is about problem solving and computation via algorithms.
			We will cover a number of known algorithms (sorting, hashing, search,
			indexing) and their applications.  We will discuss methods for analyzing
			existing algorithms and designing new algorithms.
			Finally, the students will be introduced to &lt;i&gt;complexity classes&lt;/i&gt;, in
			particular the class of &lt;i&gt;NP-completeness&lt;/i&gt;.
		&lt;/p&gt;
	&lt;/div&gt;
	&lt;div class=col-md-9&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Sorting&lt;/h1&gt;
				&lt;p&gt; Chapter 2.1, 2.3, 6, 7, 8&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;insert-sort&#34;&gt;Insertion sort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;merge-sort&#34;&gt;Mergesort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;quicksort&#34;&gt;Quicksort&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;optimal-sorting&#34;&gt;
							Comparision based sorting versus numeric sorting
						&lt;/a&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;sorting-numbers&#34;&gt;Sorting integers&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Analysis of Complexity&lt;/h1&gt;
				&lt;p&gt; Chapter 3, 4, 5&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;
						&lt;a href=&#34;big-o&#34;&gt;Asymptotic notations&lt;/a&gt;
					&lt;/li&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;recurrence-equation&#34;&gt;Recurrence equations&lt;/a&gt;
                    &lt;/li&gt;
                    &lt;!--
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;&#34;&gt;Probabilistic analysis of randomized algorithms&lt;/a&gt;
						&lt;span style=&#34;float:right&#34; class=&#34;label label-warning&#34;&gt;DRAFT&lt;/span&gt;
                    &lt;/li&gt;
                    --&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Data structures&lt;/h1&gt;
				&lt;p&gt;Chapter 11&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
                    &lt;!--
					&lt;li class=list-group-item&gt;&lt;a href=&#34;&#34;&gt;Elementary data structures&lt;/a&gt;&lt;/li&gt;
                    --&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;hash-table&#34;&gt;Hash tables&lt;/a&gt;
                    &lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
        &lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Graphs&lt;/h1&gt;
				&lt;p&gt;Chapter 22&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;
                        &lt;a href=&#34;graph-algorithms&#34;&gt;Graph Algorithms&lt;/a&gt;
                    &lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;mst&#34;&gt;Spanning trees&lt;/a&gt;&lt;/li&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;shortest-path&#34;&gt;Shortest path algorithms&lt;/a&gt;&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Optimization&lt;/h1&gt;
				&lt;p&gt;Chapter 15, 16&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
					&lt;li class=list-group-item&gt;&lt;a href=&#34;dynamic-programming&#34;&gt;Dynamic programming&lt;/a&gt;&lt;/li&gt;
                    &lt;li class=list-group-item&gt;
                        &lt;a href=&#34;greedy-algorithms&#34;&gt;Greedy algorithms&lt;/a&gt;
                        &lt;span class=&#34;label label-info&#34;&gt;New&lt;/span&gt;
                    &lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div class=&#34;panel panel-info&#34;&gt;
			&lt;div class=&#34;panel-heading&#34;&gt;
				&lt;h1 class=&#34;panel-title&#34;&gt;Complexity &amp; Tractability&lt;/h1&gt;
				&lt;p&gt;Chapter 34&lt;/p&gt;
			&lt;/div&gt;
			&lt;div class=&#34;panel-body&#34;&gt;
				&lt;ul class=list-group&gt;
                    &lt;li class=list-group-item&gt;
                        &lt;a href=&#34;np-complete&#34;&gt;Decision problems &amp; NP-completeness&lt;/a&gt;
                        &lt;span class=&#34;label label-danger&#34;&gt;DRAFT&lt;/span&gt;
                    &lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;

	&lt;/div&gt;
&lt;/div&gt;

&lt;style&gt; a[href=&#34;&#34;] {color: #888;} &lt;/style&gt;
</description>
    </item>
    
    <item>
      <title>Asymptotic notation</title>
      <link>http://db.science.uoit.ca/courses/algorithms/big-o/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/algorithms/big-o/</guid>
      <description>

&lt;h1 id=&#34;complexity-classes&#34;&gt;Complexity classes&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Asymptotic notations and complexity classes&lt;/li&gt;
&lt;li&gt;Intuition&lt;/li&gt;
&lt;li&gt;Properties&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;asymptotic-notation&#34;&gt;Asymptotic notation&lt;/h1&gt;

&lt;p&gt;We will develop a way to measure the efficiency of algorithms which is &lt;em&gt;invariant&lt;/em&gt; to the non-essential issues such as the speed of computer hardware and the effiency of the programming language used.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The measurement functions is only sensitive to the &lt;em&gt;growth&lt;/em&gt; of the time it takes for an algorithm to complete with respect to the size of the input.&lt;/p&gt;

&lt;h1 id=&#34;measure&#34;&gt;Measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The size of the input is an integer $n$&lt;/li&gt;
&lt;li&gt;We use functions over integers to measure the efficiency of an algorithm.&lt;/li&gt;
&lt;li&gt;$f(n)$ is the &lt;strong&gt;time&lt;/strong&gt; it takes to process input of size $n$ in the &lt;em&gt;worst case&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;$f$ is monotonic: if $m \leq n$, then $f(m)\leq f(n)$.&lt;/li&gt;
&lt;li&gt;$f$ is strictly positive: $f(n) &amp;gt; 0$ for all $n$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;using-functions-as-measurement-of-algorithmic-complexity&#34;&gt;Using functions as measurement of algorithmic complexity&lt;/h1&gt;

&lt;p&gt;We want to use functions to measure the inherit &lt;em&gt;complexity&lt;/em&gt; of &lt;em&gt;algorithms&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is not very straight-forward.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;---&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We don&amp;rsquo;t care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Runtime environment&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CPU speed&lt;/li&gt;
&lt;li&gt;Start-up time of the program&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Implementation issues&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Speed of the language&lt;/li&gt;
&lt;li&gt;Number of statements used&lt;/li&gt;
&lt;li&gt;Overhead in memory data structure&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We do care about&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Inherit complexity of the algorithm&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;capturing-the-essentials&#34;&gt;Capturing the essentials&lt;/h1&gt;

&lt;p&gt;Suppose that we have an algorithm $P$.  Let&amp;rsquo;s use some function $f(n)$ to represent the time, in the &lt;em&gt;worst case&lt;/em&gt;, that $P$ takes to process an input of size $n$.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at the effects of various environmental factors on the measure $f(n)$.&lt;/p&gt;

&lt;h1 id=&#34;effects-on-the-measure&#34;&gt;Effects on the measure&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$P$ is reimplemented using C (from Python), so it runs 20 times faster now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = \frac{1}{20} f(n)$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$P$ runs inside a &lt;em&gt;docker&lt;/em&gt; image, so it takes an additional 300 ms to start.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$f&amp;rsquo;(n) = f(n) + 300\mathrm{ms}$&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But we don&amp;rsquo;t want to care about these implementation and runtime factors when investigating the complexity of algorithms.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Intuition: given $f(n)$, we define family of (infinite) functions&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfort&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{better\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{worse\ than}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\{g(n): g(n)\ \mathrm{equivalent\ to}\ f(n) \}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;mathcal-o-notation-better-than&#34;&gt;$\mathcal{O}$-notation - better than&lt;/h1&gt;

&lt;p&gt;We want to define all function which are measure of algorithms which are better than (or same as) $g(n)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The Big-O notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\mathcal{O}(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0 &amp;lt; f(n) &amp;lt; c\cdot g(n)\}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We call $g(n)$ the asymptotic upper bound of the functions in $\mathcal{O}(g(n))$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;big-o.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;significance-of-asymptotic-analysis&#34;&gt;Significance of asymptotic analysis&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If we have an algorithm $A$, and its precise time measurement (on a specific hardware) is given precisely as &lt;code&gt;$T(n)$&lt;/code&gt;, where $n$ is the input size in &lt;em&gt;bytes&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If &lt;code&gt;$T(n)\in\mathcal{O}(g(n))$&lt;/code&gt;, we are saying that $A$ is &lt;strong&gt;better&lt;/strong&gt; than $g(n)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Challenge&lt;/em&gt;:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Check that the variations on the way that the efficiency of $A$ is
measured also are in $\mathcal{O}(g(n))$.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$T_1(n)$ is the time that $A$ runs on a slow processor.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$T_2(n)$ is the time that $A$ if the input is measured in the array length.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;omega-notation-worse-than&#34;&gt;$\Omega$-notation - worse than&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The $\Omega$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\Omega(g(n)) = \{f(n) : \exists n_0, c &amp;gt; 0,\forall n &amp;gt; n_0, \ 0  &amp;lt; c\cdot g(n) &amp;lt; f(n) \}$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We say that $g(n)$ is the asymptotic lower bound of the functions in $\Omega(g(n))$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;omega.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;theta-notation-same-as&#34;&gt;$\Theta$-notation - same as&lt;/h1&gt;

&lt;p&gt;*&lt;em&gt;Definition&lt;/em&gt;: The $\Theta$-notation&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;$$\Theta(g(n)) = \mathcal{O}(g(n)) \cap \Omega(g(n))$$&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;More precisely,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$
\begin{eqnarray}
&amp;amp;&amp;amp; \Theta(g(n)) \\
&amp;amp;=&amp;amp; 
\{f(n): \exists n_0, c_1, c_2 &amp;gt; 0,\forall n &amp;gt; n_0,\ 0 \leq c_1\cdot g(n) \leq f(n) \leq c_2\cdot g(n)\}
\end{eqnarray}
$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;theta.png&#34; style=float:right;height:300px&gt;&lt;/img&gt;&lt;/p&gt;

&lt;h1 id=&#34;recap&#34;&gt;Recap&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$\mathcal{O}(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are better (or equivalent) to $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\Omega(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are worse (or equivalent) to $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$\Theta(g(n))$ is the collection of &lt;strong&gt;all&lt;/strong&gt; the performance measures that are equivalent to $g(n)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;functions-we-use&#34;&gt;Functions we use:&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Polynomials:&lt;/p&gt;

&lt;p&gt;$$f(n) = \sum_{i=0}^d a_i n^i$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exponentials:&lt;/p&gt;

&lt;p&gt;$$f(n) = a^n$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Logorithms&lt;/p&gt;

&lt;p&gt;$$f(n) = \log_a(n)$$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Factorials&lt;/p&gt;

&lt;p&gt;$$f(n) = n!$$&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-exponents&#34;&gt;More about Exponents&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(a^m)^n = a^{mn}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(a^m) (a^n) = a^{m+n}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\lim_{n\to\infty} \frac{n^d}{a^n} = 0$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-logorithms&#34;&gt;More about Logorithms&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;comfortable&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$a^{\log_a(n)} = n$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_a(mn) = \log_a(m) + \log_a(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_a(n^d) = d\cdot \log_a(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$\log_b(a) \cdot \log_a(n) = \log_b(n)$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$a^{\log_a (n)} = n^{\log_b(a)}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;more-about-factorial&#34;&gt;More about Factorial&lt;/h1&gt;

&lt;p&gt;Stirling&amp;rsquo;s approximation:&lt;/p&gt;

&lt;p&gt;$$ n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^n $$&lt;/p&gt;

&lt;h1 id=&#34;comparisons&#34;&gt;Comparisons&lt;/h1&gt;

&lt;p&gt;For any $a &amp;gt; 1$, $b &amp;gt; 0$ and $c &amp;gt; 1$, we have:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$$ 
\mathcal{O}(\log_a(n)) \subseteq \mathcal{O}(n^b) \subseteq \mathcal{O}(c^n)
$$&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;We can show that:&lt;/p&gt;

&lt;p&gt;$$ n! \in\mathcal{O}(n^n) $$&lt;/p&gt;

&lt;p&gt;In fact:&lt;/p&gt;

&lt;p&gt;$$ \mathcal{O}(2^n) \subset \mathcal{O}(n^n) $$&lt;/p&gt;

&lt;h1 id=&#34;notation&#34;&gt;Notation&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;s convenient to treat complexity classes as &lt;em&gt;variables&lt;/em&gt; in equations.&lt;/p&gt;

&lt;p&gt;So, we use the following notations:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If $f\in \mathcal{O}(g)$, we write it as equality $f=\mathcal{O}(g)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;test-your-understanding&#34;&gt;Test your understanding&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;If $f = \mathcal{O}(g)$ and $g = \mathcal{O}(h)$, can you prove that $f =
\mathcal{O}(h)$?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Does it make sense intuitively?&lt;/p&gt;

&lt;p&gt;Does it work out mathematically?&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;So that $n^2 + 10000= \mathcal{O}(n^3)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Basics of Scala</title>
      <link>http://db.science.uoit.ca/courses/programming-languages/scala-basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://db.science.uoit.ca/courses/programming-languages/scala-basics/</guid>
      <description>

&lt;h1 id=&#34;basics-of-scala&#34;&gt;Basics of Scala&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;objects&#34;&gt;Objects&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;var name : String = &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
This creates a &lt;strong&gt;variable&lt;/strong&gt;, with the type &lt;code&gt;String&lt;/code&gt;, and it&amp;rsquo;s initialized to
&amp;ldquo;hello&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;name.CharAt(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
Java-style method invocation&lt;/p&gt;

&lt;h1 id=&#34;toc_2&#34;&gt;______&lt;/h1&gt;

&lt;p&gt;Scala uses the same scoping and symbol bindings.&lt;/p&gt;

&lt;p&gt;There are two types of &lt;em&gt;symbols&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Variables&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bindings to &lt;code&gt;var&lt;/code&gt; can be updated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;var name:String = &amp;quot;Albert&amp;quot;
name = &amp;quot;Einstein&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Values&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Bindings to &lt;code&gt;val&lt;/code&gt; is permanent.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val name : String = &amp;quot;Alert&amp;quot;
name = &amp;quot;Einstein&amp;quot;
// error: reassignment to val
//       x = &amp;quot;Einstein&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;box&#34;&gt;!&lt;/a&gt; This is the same as Clojure, and it&amp;rsquo;s preferred over &lt;code&gt;var&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;type-inference&#34;&gt;Type Inference&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Definition&lt;/em&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A statically typed language is one that requires the compiler to have complete
type information on all the symbols in the source code &lt;strong&gt;at&lt;/strong&gt; compile-time.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;Java &lt;strong&gt;and&lt;/strong&gt; Scala are statically typed languages.&lt;/li&gt;
&lt;li&gt;Clojure and Python are not statically typed, but typed (at runtime).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;&amp;amp;&amp;amp;&amp;amp;&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The compiler needs type information specified for &lt;em&gt;all&lt;/em&gt; the symbols.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String name;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val name : String = ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_4&#34;&gt;____&lt;/h1&gt;

&lt;p&gt;Scala has a feature, known as &lt;em&gt;type inference&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;At compile-time, the compiler makes a best attempt to fill in the missing type
information.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val small_integer = 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The compiler will see that &lt;code&gt;small_integer&lt;/code&gt; should be &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;var x = y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The compiler will use the type of &lt;code&gt;y&lt;/code&gt; to infer the type of &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the interactive interpreter session, you can always inspect the type
information of existing symbols:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;:t small_integer
Int
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;procedural-programming&#34;&gt;Procedural programming&lt;/h1&gt;

&lt;h2 id=&#34;if&#34;&gt;IF&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;if (&amp;lt;cond&amp;gt;) {
  &amp;lt;expression&amp;gt;
} else if (&amp;lt;cond&amp;gt;) {
  &amp;lt;expression&amp;gt;
} else {
  &amp;lt;expression&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
The classic Java-style branching.  Scala has better pattern matching
which is preferred over if-else.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if-else&lt;/code&gt; is an expression, not a statement.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;columns 6:&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val age = 65
var senior:String = &amp;quot;&amp;quot;
if(age &amp;lt; 65) {
  senior = &amp;quot;Not senior&amp;quot;
} else {
  senior = &amp;quot;Senior&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;split&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;val age = 65
val senior = if(age &amp;lt; 65) 
               &amp;quot;Not senior&amp;quot;
             else
               &amp;quot;Senior&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_7&#34;&gt;_____&lt;/h1&gt;

&lt;h2 id=&#34;for&#34;&gt;FOR&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;for(&amp;lt;val&amp;gt; &amp;lt;- &amp;lt;iterable&amp;gt;) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;All container data structures are iterables: arrays, lists, map, &amp;hellip;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Scala has a nice way to generate iterables over integer ranges:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;1 to 10     // 1, 2, ... 10
1 until 10  // 1, 2, ... 9
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;for(x &amp;lt;- 1 to 10) {
  println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;
Scala&amp;rsquo;s &lt;code&gt;for&lt;/code&gt; loop is much more powerful then simple iteration.  More on this
in lectures on programming with sequences.&lt;/p&gt;

&lt;h1 id=&#34;toc_9&#34;&gt;_____________&lt;/h1&gt;

&lt;h2 id=&#34;loops&#34;&gt;Loops&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;while(&amp;lt;cond&amp;gt;) {
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;do {
    ...
} while(&amp;lt;cond&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;syntax-rules&#34;&gt;Syntax rules&lt;/h1&gt;

&lt;p&gt;Suppose that an object has zero or one argument.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.method()
obj.method(arg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the parenthesis can be omitted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.method
obj.method arg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The dot can also be omitted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj method
obj method arg
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;toc_12&#34;&gt;_____&lt;/h1&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 + 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; This is actually a method invocation in disguise.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1.+(2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; The equivalent syntax in method invocation.  The method name is &lt;code&gt;+&lt;/code&gt;,
the object is &lt;code&gt;1&lt;/code&gt;, and the argument is &lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This type of syntax rule allows us to introduce user-defined operators to
support programming constructs such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x multiplyWith y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt; We assume that the object &lt;code&gt;x&lt;/code&gt; has a method called &lt;code&gt;multiplyWith&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can also invoke Java methods like operators&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;hello&amp;quot; charAt 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;syntax-rules-1&#34;&gt;Syntax rules&lt;/h1&gt;

&lt;p&gt;More syntax rules to come.&lt;/p&gt;

&lt;h1 id=&#34;functions&#34;&gt;Functions&lt;/h1&gt;

&lt;p&gt;Functions are in fact objects of a &lt;em&gt;function&lt;/em&gt; class.  Scala offers a succinct
syntax for defining functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm&#34;&gt;import scala.math
val area = {(count:Int, radius:Float) =&amp;gt; x * scala.math.Pi * radius * radius}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala sm clipboard&#34;&gt;val area : (Int, Float) =&amp;gt; Double = {
  (count, radius) =&amp;gt; {
    var total: Double = 0
    for(i &amp;lt;- 0 until count) {
        total += scala.math.Pi * radius * radius
    }
    total
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;The type of the &lt;code&gt;val&lt;/code&gt; is &lt;code&gt;(Int, Float) =&amp;gt; Double&lt;/code&gt;.  This is also known as
the &lt;em&gt;function signature&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;The value is a function (instance of a class Function2).&lt;/li&gt;
&lt;li&gt;The inputs are bound to symbols &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;radius&lt;/code&gt;.
Note the binding types are inferred based on the function signature.
&lt;a href=&#34;note&#34;&gt;!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;highlight&#34;&gt;!&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bindings&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Procedural programming&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Object method invocation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Function as data&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>